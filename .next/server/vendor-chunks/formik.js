"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/formik";
exports.ids = ["vendor-chunks/formik"];
exports.modules = {

/***/ "(ssr)/./node_modules/formik/dist/formik.esm.js":
/*!************************************************!*\
  !*** ./node_modules/formik/dist/formik.esm.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorMessage: () => (/* binding */ ErrorMessage),\n/* harmony export */   FastField: () => (/* binding */ FastField),\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FieldArray: () => (/* binding */ FieldArray),\n/* harmony export */   Form: () => (/* binding */ Form),\n/* harmony export */   Formik: () => (/* binding */ Formik),\n/* harmony export */   FormikConsumer: () => (/* binding */ FormikConsumer),\n/* harmony export */   FormikContext: () => (/* binding */ FormikContext),\n/* harmony export */   FormikProvider: () => (/* binding */ FormikProvider),\n/* harmony export */   connect: () => (/* binding */ connect),\n/* harmony export */   getActiveElement: () => (/* binding */ getActiveElement),\n/* harmony export */   getIn: () => (/* binding */ getIn),\n/* harmony export */   insert: () => (/* binding */ insert),\n/* harmony export */   isEmptyArray: () => (/* binding */ isEmptyArray),\n/* harmony export */   isEmptyChildren: () => (/* binding */ isEmptyChildren),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isInputEvent: () => (/* binding */ isInputEvent),\n/* harmony export */   isInteger: () => (/* binding */ isInteger),\n/* harmony export */   isNaN: () => (/* binding */ isNaN$1),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isPromise: () => (/* binding */ isPromise),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   move: () => (/* binding */ move),\n/* harmony export */   prepareDataForValidation: () => (/* binding */ prepareDataForValidation),\n/* harmony export */   replace: () => (/* binding */ replace),\n/* harmony export */   setIn: () => (/* binding */ setIn),\n/* harmony export */   setNestedObjectValues: () => (/* binding */ setNestedObjectValues),\n/* harmony export */   swap: () => (/* binding */ swap),\n/* harmony export */   useField: () => (/* binding */ useField),\n/* harmony export */   useFormik: () => (/* binding */ useFormik),\n/* harmony export */   useFormikContext: () => (/* binding */ useFormikContext),\n/* harmony export */   validateYupSchema: () => (/* binding */ validateYupSchema),\n/* harmony export */   withFormik: () => (/* binding */ withFormik),\n/* harmony export */   yupToFormErrors: () => (/* binding */ yupToFormErrors)\n/* harmony export */ });\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deepmerge */ \"(ssr)/./node_modules/deepmerge/dist/es.js\");\n/* harmony import */ var lodash_es_isPlainObject__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash-es/isPlainObject */ \"(ssr)/./node_modules/lodash-es/isPlainObject.js\");\n/* harmony import */ var lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash-es/cloneDeep */ \"(ssr)/./node_modules/lodash-es/cloneDeep.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_fast_compare__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-fast-compare */ \"(ssr)/./node_modules/react-fast-compare/index.js\");\n/* harmony import */ var react_fast_compare__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_fast_compare__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tiny-warning */ \"(ssr)/./node_modules/tiny-warning/dist/tiny-warning.esm.js\");\n/* harmony import */ var lodash_es_clone__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash-es/clone */ \"(ssr)/./node_modules/lodash-es/clone.js\");\n/* harmony import */ var lodash_es_toPath__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es/toPath */ \"(ssr)/./node_modules/lodash-es/toPath.js\");\n/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! hoist-non-react-statics */ \"(ssr)/./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js\");\n/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n\n\n\n\n\nfunction _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nvar FormikContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nFormikContext.displayName = \"FormikContext\";\nvar FormikProvider = FormikContext.Provider;\nvar FormikConsumer = FormikContext.Consumer;\nfunction useFormikContext() {\n    var formik = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(FormikContext);\n    !!!formik ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, \"Formik context is undefined, please verify you are calling useFormikContext() as child of a <Formik> component.\") : 0 : void 0;\n    return formik;\n}\n/** @private is the value an empty array? */ var isEmptyArray = function isEmptyArray(value) {\n    return Array.isArray(value) && value.length === 0;\n};\n/** @private is the given object a Function? */ var isFunction = function isFunction(obj) {\n    return typeof obj === \"function\";\n};\n/** @private is the given object an Object? */ var isObject = function isObject(obj) {\n    return obj !== null && typeof obj === \"object\";\n};\n/** @private is the given object an integer? */ var isInteger = function isInteger(obj) {\n    return String(Math.floor(Number(obj))) === obj;\n};\n/** @private is the given object a string? */ var isString = function isString(obj) {\n    return Object.prototype.toString.call(obj) === \"[object String]\";\n};\n/** @private is the given object a NaN? */ // eslint-disable-next-line no-self-compare\nvar isNaN$1 = function isNaN1(obj) {\n    return obj !== obj;\n};\n/** @private Does a React component have exactly 0 children? */ var isEmptyChildren = function isEmptyChildren(children) {\n    return react__WEBPACK_IMPORTED_MODULE_1__.Children.count(children) === 0;\n};\n/** @private is the given object/value a promise? */ var isPromise = function isPromise(value) {\n    return isObject(value) && isFunction(value.then);\n};\n/** @private is the given object/value a type of synthetic event? */ var isInputEvent = function isInputEvent(value) {\n    return value && isObject(value) && isObject(value.target);\n};\n/**\r\n * Same as document.activeElement but wraps in a try-catch block. In IE it is\r\n * not safe to call document.activeElement if there is nothing focused.\r\n *\r\n * The activeElement will be null only if the document or document body is not\r\n * yet defined.\r\n *\r\n * @param {?Document} doc Defaults to current document.\r\n * @return {Element | null}\r\n * @see https://github.com/facebook/fbjs/blob/master/packages/fbjs/src/core/dom/getActiveElement.js\r\n */ function getActiveElement(doc) {\n    doc = doc || (typeof document !== \"undefined\" ? document : undefined);\n    if (typeof doc === \"undefined\") {\n        return null;\n    }\n    try {\n        return doc.activeElement || doc.body;\n    } catch (e) {\n        return doc.body;\n    }\n}\n/**\r\n * Deeply get a value from an object via its path.\r\n */ function getIn(obj, key, def, p) {\n    if (p === void 0) {\n        p = 0;\n    }\n    var path = (0,lodash_es_toPath__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(key);\n    while(obj && p < path.length){\n        obj = obj[path[p++]];\n    } // check if path is not in the end\n    if (p !== path.length && !obj) {\n        return def;\n    }\n    return obj === undefined ? def : obj;\n}\n/**\r\n * Deeply set a value from in object via it's path. If the value at `path`\r\n * has changed, return a shallow copy of obj with `value` set at `path`.\r\n * If `value` has not changed, return the original `obj`.\r\n *\r\n * Existing objects / arrays along `path` are also shallow copied. Sibling\r\n * objects along path retain the same internal js reference. Since new\r\n * objects / arrays are only created along `path`, we can test if anything\r\n * changed in a nested structure by comparing the object's reference in\r\n * the old and new object, similar to how russian doll cache invalidation\r\n * works.\r\n *\r\n * In earlier versions of this function, which used cloneDeep, there were\r\n * issues whereby settings a nested value would mutate the parent\r\n * instead of creating a new object. `clone` avoids that bug making a\r\n * shallow copy of the objects along the update path\r\n * so no object is mutated in place.\r\n *\r\n * Before changing this function, please read through the following\r\n * discussions.\r\n *\r\n * @see https://github.com/developit/linkstate\r\n * @see https://github.com/jaredpalmer/formik/pull/123\r\n */ function setIn(obj, path, value) {\n    var res = (0,lodash_es_clone__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(obj); // this keeps inheritance when obj is a class\n    var resVal = res;\n    var i = 0;\n    var pathArray = (0,lodash_es_toPath__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(path);\n    for(; i < pathArray.length - 1; i++){\n        var currentPath = pathArray[i];\n        var currentObj = getIn(obj, pathArray.slice(0, i + 1));\n        if (currentObj && (isObject(currentObj) || Array.isArray(currentObj))) {\n            resVal = resVal[currentPath] = (0,lodash_es_clone__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(currentObj);\n        } else {\n            var nextPath = pathArray[i + 1];\n            resVal = resVal[currentPath] = isInteger(nextPath) && Number(nextPath) >= 0 ? [] : {};\n        }\n    } // Return original object if new value is the same as current\n    if ((i === 0 ? obj : resVal)[pathArray[i]] === value) {\n        return obj;\n    }\n    if (value === undefined) {\n        delete resVal[pathArray[i]];\n    } else {\n        resVal[pathArray[i]] = value;\n    } // If the path array has a single element, the loop did not run.\n    // Deleting on `resVal` had no effect in this scenario, so we delete on the result instead.\n    if (i === 0 && value === undefined) {\n        delete res[pathArray[i]];\n    }\n    return res;\n}\n/**\r\n * Recursively a set the same value for all keys and arrays nested object, cloning\r\n * @param object\r\n * @param value\r\n * @param visited\r\n * @param response\r\n */ function setNestedObjectValues(object, value, visited, response) {\n    if (visited === void 0) {\n        visited = new WeakMap();\n    }\n    if (response === void 0) {\n        response = {};\n    }\n    for(var _i = 0, _Object$keys = Object.keys(object); _i < _Object$keys.length; _i++){\n        var k = _Object$keys[_i];\n        var val = object[k];\n        if (isObject(val)) {\n            if (!visited.get(val)) {\n                visited.set(val, true); // In order to keep array values consistent for both dot path  and\n                // bracket syntax, we need to check if this is an array so that\n                // this will output  { friends: [true] } and not { friends: { \"0\": true } }\n                response[k] = Array.isArray(val) ? [] : {};\n                setNestedObjectValues(val, value, visited, response[k]);\n            }\n        } else {\n            response[k] = value;\n        }\n    }\n    return response;\n}\nfunction formikReducer(state, msg) {\n    switch(msg.type){\n        case \"SET_VALUES\":\n            return _extends({}, state, {\n                values: msg.payload\n            });\n        case \"SET_TOUCHED\":\n            return _extends({}, state, {\n                touched: msg.payload\n            });\n        case \"SET_ERRORS\":\n            if (react_fast_compare__WEBPACK_IMPORTED_MODULE_2___default()(state.errors, msg.payload)) {\n                return state;\n            }\n            return _extends({}, state, {\n                errors: msg.payload\n            });\n        case \"SET_STATUS\":\n            return _extends({}, state, {\n                status: msg.payload\n            });\n        case \"SET_ISSUBMITTING\":\n            return _extends({}, state, {\n                isSubmitting: msg.payload\n            });\n        case \"SET_ISVALIDATING\":\n            return _extends({}, state, {\n                isValidating: msg.payload\n            });\n        case \"SET_FIELD_VALUE\":\n            return _extends({}, state, {\n                values: setIn(state.values, msg.payload.field, msg.payload.value)\n            });\n        case \"SET_FIELD_TOUCHED\":\n            return _extends({}, state, {\n                touched: setIn(state.touched, msg.payload.field, msg.payload.value)\n            });\n        case \"SET_FIELD_ERROR\":\n            return _extends({}, state, {\n                errors: setIn(state.errors, msg.payload.field, msg.payload.value)\n            });\n        case \"RESET_FORM\":\n            return _extends({}, state, msg.payload);\n        case \"SET_FORMIK_STATE\":\n            return msg.payload(state);\n        case \"SUBMIT_ATTEMPT\":\n            return _extends({}, state, {\n                touched: setNestedObjectValues(state.values, true),\n                isSubmitting: true,\n                submitCount: state.submitCount + 1\n            });\n        case \"SUBMIT_FAILURE\":\n            return _extends({}, state, {\n                isSubmitting: false\n            });\n        case \"SUBMIT_SUCCESS\":\n            return _extends({}, state, {\n                isSubmitting: false\n            });\n        default:\n            return state;\n    }\n} // Initial empty states // objects\nvar emptyErrors = {};\nvar emptyTouched = {};\nfunction useFormik(_ref) {\n    var _ref$validateOnChange = _ref.validateOnChange, validateOnChange = _ref$validateOnChange === void 0 ? true : _ref$validateOnChange, _ref$validateOnBlur = _ref.validateOnBlur, validateOnBlur = _ref$validateOnBlur === void 0 ? true : _ref$validateOnBlur, _ref$validateOnMount = _ref.validateOnMount, validateOnMount = _ref$validateOnMount === void 0 ? false : _ref$validateOnMount, isInitialValid = _ref.isInitialValid, _ref$enableReinitiali = _ref.enableReinitialize, enableReinitialize = _ref$enableReinitiali === void 0 ? false : _ref$enableReinitiali, onSubmit = _ref.onSubmit, rest = _objectWithoutPropertiesLoose(_ref, [\n        \"validateOnChange\",\n        \"validateOnBlur\",\n        \"validateOnMount\",\n        \"isInitialValid\",\n        \"enableReinitialize\",\n        \"onSubmit\"\n    ]);\n    var props = _extends({\n        validateOnChange: validateOnChange,\n        validateOnBlur: validateOnBlur,\n        validateOnMount: validateOnMount,\n        onSubmit: onSubmit\n    }, rest);\n    var initialValues = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(props.initialValues);\n    var initialErrors = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(props.initialErrors || emptyErrors);\n    var initialTouched = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(props.initialTouched || emptyTouched);\n    var initialStatus = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(props.initialStatus);\n    var isMounted = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    var fieldRegistry = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({});\n    if (true) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n            !(typeof isInitialValid === \"undefined\") ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, \"isInitialValid has been deprecated and will be removed in future versions of Formik. Please use initialErrors or validateOnMount instead.\") : 0 : void 0; // eslint-disable-next-line\n        }, []);\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        isMounted.current = true;\n        return function() {\n            isMounted.current = false;\n        };\n    }, []);\n    var _React$useState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0), setIteration = _React$useState[1];\n    var stateRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        values: (0,lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(props.initialValues),\n        errors: (0,lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(props.initialErrors) || emptyErrors,\n        touched: (0,lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(props.initialTouched) || emptyTouched,\n        status: (0,lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(props.initialStatus),\n        isSubmitting: false,\n        isValidating: false,\n        submitCount: 0\n    });\n    var state = stateRef.current;\n    var dispatch = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(action) {\n        var prev = stateRef.current;\n        stateRef.current = formikReducer(prev, action); // force rerender\n        if (prev !== stateRef.current) setIteration(function(x) {\n            return x + 1;\n        });\n    }, []);\n    var runValidateHandler = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(values, field) {\n        return new Promise(function(resolve, reject) {\n            var maybePromisedErrors = props.validate(values, field);\n            if (maybePromisedErrors == null) {\n                // use loose null check here on purpose\n                resolve(emptyErrors);\n            } else if (isPromise(maybePromisedErrors)) {\n                maybePromisedErrors.then(function(errors) {\n                    resolve(errors || emptyErrors);\n                }, function(actualException) {\n                    if (true) {\n                        console.warn(\"Warning: An unhandled error was caught during validation in <Formik validate />\", actualException);\n                    }\n                    reject(actualException);\n                });\n            } else {\n                resolve(maybePromisedErrors);\n            }\n        });\n    }, [\n        props.validate\n    ]);\n    /**\r\n   * Run validation against a Yup schema and optionally run a function if successful\r\n   */ var runValidationSchema = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(values, field) {\n        var validationSchema = props.validationSchema;\n        var schema = isFunction(validationSchema) ? validationSchema(field) : validationSchema;\n        var promise = field && schema.validateAt ? schema.validateAt(field, values) : validateYupSchema(values, schema);\n        return new Promise(function(resolve, reject) {\n            promise.then(function() {\n                resolve(emptyErrors);\n            }, function(err) {\n                // Yup will throw a validation error if validation fails. We catch those and\n                // resolve them into Formik errors. We can sniff if something is a Yup error\n                // by checking error.name.\n                // @see https://github.com/jquense/yup#validationerrorerrors-string--arraystring-value-any-path-string\n                if (err.name === \"ValidationError\") {\n                    resolve(yupToFormErrors(err));\n                } else {\n                    // We throw any other errors\n                    if (true) {\n                        console.warn(\"Warning: An unhandled error was caught during validation in <Formik validationSchema />\", err);\n                    }\n                    reject(err);\n                }\n            });\n        });\n    }, [\n        props.validationSchema\n    ]);\n    var runSingleFieldLevelValidation = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(field, value) {\n        return new Promise(function(resolve) {\n            return resolve(fieldRegistry.current[field].validate(value));\n        });\n    }, []);\n    var runFieldLevelValidations = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(values) {\n        var fieldKeysWithValidation = Object.keys(fieldRegistry.current).filter(function(f) {\n            return isFunction(fieldRegistry.current[f].validate);\n        }); // Construct an array with all of the field validation functions\n        var fieldValidations = fieldKeysWithValidation.length > 0 ? fieldKeysWithValidation.map(function(f) {\n            return runSingleFieldLevelValidation(f, getIn(values, f));\n        }) : [\n            Promise.resolve(\"DO_NOT_DELETE_YOU_WILL_BE_FIRED\")\n        ]; // use special case ;)\n        return Promise.all(fieldValidations).then(function(fieldErrorsList) {\n            return fieldErrorsList.reduce(function(prev, curr, index) {\n                if (curr === \"DO_NOT_DELETE_YOU_WILL_BE_FIRED\") {\n                    return prev;\n                }\n                if (curr) {\n                    prev = setIn(prev, fieldKeysWithValidation[index], curr);\n                }\n                return prev;\n            }, {});\n        });\n    }, [\n        runSingleFieldLevelValidation\n    ]); // Run all validations and return the result\n    var runAllValidations = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(values) {\n        return Promise.all([\n            runFieldLevelValidations(values),\n            props.validationSchema ? runValidationSchema(values) : {},\n            props.validate ? runValidateHandler(values) : {}\n        ]).then(function(_ref2) {\n            var fieldErrors = _ref2[0], schemaErrors = _ref2[1], validateErrors = _ref2[2];\n            var combinedErrors = deepmerge__WEBPACK_IMPORTED_MODULE_0__[\"default\"].all([\n                fieldErrors,\n                schemaErrors,\n                validateErrors\n            ], {\n                arrayMerge: arrayMerge\n            });\n            return combinedErrors;\n        });\n    }, [\n        props.validate,\n        props.validationSchema,\n        runFieldLevelValidations,\n        runValidateHandler,\n        runValidationSchema\n    ]); // Run all validations methods and update state accordingly\n    var validateFormWithHighPriority = useEventCallback(function(values) {\n        if (values === void 0) {\n            values = state.values;\n        }\n        dispatch({\n            type: \"SET_ISVALIDATING\",\n            payload: true\n        });\n        return runAllValidations(values).then(function(combinedErrors) {\n            if (!!isMounted.current) {\n                dispatch({\n                    type: \"SET_ISVALIDATING\",\n                    payload: false\n                });\n                dispatch({\n                    type: \"SET_ERRORS\",\n                    payload: combinedErrors\n                });\n            }\n            return combinedErrors;\n        });\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        if (validateOnMount && isMounted.current === true && react_fast_compare__WEBPACK_IMPORTED_MODULE_2___default()(initialValues.current, props.initialValues)) {\n            validateFormWithHighPriority(initialValues.current);\n        }\n    }, [\n        validateOnMount,\n        validateFormWithHighPriority\n    ]);\n    var resetForm = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(nextState) {\n        var values = nextState && nextState.values ? nextState.values : initialValues.current;\n        var errors = nextState && nextState.errors ? nextState.errors : initialErrors.current ? initialErrors.current : props.initialErrors || {};\n        var touched = nextState && nextState.touched ? nextState.touched : initialTouched.current ? initialTouched.current : props.initialTouched || {};\n        var status = nextState && nextState.status ? nextState.status : initialStatus.current ? initialStatus.current : props.initialStatus;\n        initialValues.current = values;\n        initialErrors.current = errors;\n        initialTouched.current = touched;\n        initialStatus.current = status;\n        var dispatchFn = function dispatchFn() {\n            dispatch({\n                type: \"RESET_FORM\",\n                payload: {\n                    isSubmitting: !!nextState && !!nextState.isSubmitting,\n                    errors: errors,\n                    touched: touched,\n                    status: status,\n                    values: values,\n                    isValidating: !!nextState && !!nextState.isValidating,\n                    submitCount: !!nextState && !!nextState.submitCount && typeof nextState.submitCount === \"number\" ? nextState.submitCount : 0\n                }\n            });\n        };\n        if (props.onReset) {\n            var maybePromisedOnReset = props.onReset(state.values, imperativeMethods);\n            if (isPromise(maybePromisedOnReset)) {\n                maybePromisedOnReset.then(dispatchFn);\n            } else {\n                dispatchFn();\n            }\n        } else {\n            dispatchFn();\n        }\n    }, [\n        props.initialErrors,\n        props.initialStatus,\n        props.initialTouched,\n        props.onReset\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        if (isMounted.current === true && !react_fast_compare__WEBPACK_IMPORTED_MODULE_2___default()(initialValues.current, props.initialValues)) {\n            if (enableReinitialize) {\n                initialValues.current = props.initialValues;\n                resetForm();\n                if (validateOnMount) {\n                    validateFormWithHighPriority(initialValues.current);\n                }\n            }\n        }\n    }, [\n        enableReinitialize,\n        props.initialValues,\n        resetForm,\n        validateOnMount,\n        validateFormWithHighPriority\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        if (enableReinitialize && isMounted.current === true && !react_fast_compare__WEBPACK_IMPORTED_MODULE_2___default()(initialErrors.current, props.initialErrors)) {\n            initialErrors.current = props.initialErrors || emptyErrors;\n            dispatch({\n                type: \"SET_ERRORS\",\n                payload: props.initialErrors || emptyErrors\n            });\n        }\n    }, [\n        enableReinitialize,\n        props.initialErrors\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        if (enableReinitialize && isMounted.current === true && !react_fast_compare__WEBPACK_IMPORTED_MODULE_2___default()(initialTouched.current, props.initialTouched)) {\n            initialTouched.current = props.initialTouched || emptyTouched;\n            dispatch({\n                type: \"SET_TOUCHED\",\n                payload: props.initialTouched || emptyTouched\n            });\n        }\n    }, [\n        enableReinitialize,\n        props.initialTouched\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        if (enableReinitialize && isMounted.current === true && !react_fast_compare__WEBPACK_IMPORTED_MODULE_2___default()(initialStatus.current, props.initialStatus)) {\n            initialStatus.current = props.initialStatus;\n            dispatch({\n                type: \"SET_STATUS\",\n                payload: props.initialStatus\n            });\n        }\n    }, [\n        enableReinitialize,\n        props.initialStatus,\n        props.initialTouched\n    ]);\n    var validateField = useEventCallback(function(name) {\n        // This will efficiently validate a single field by avoiding state\n        // changes if the validation function is synchronous. It's different from\n        // what is called when using validateForm.\n        if (fieldRegistry.current[name] && isFunction(fieldRegistry.current[name].validate)) {\n            var value = getIn(state.values, name);\n            var maybePromise = fieldRegistry.current[name].validate(value);\n            if (isPromise(maybePromise)) {\n                // Only flip isValidating if the function is async.\n                dispatch({\n                    type: \"SET_ISVALIDATING\",\n                    payload: true\n                });\n                return maybePromise.then(function(x) {\n                    return x;\n                }).then(function(error) {\n                    dispatch({\n                        type: \"SET_FIELD_ERROR\",\n                        payload: {\n                            field: name,\n                            value: error\n                        }\n                    });\n                    dispatch({\n                        type: \"SET_ISVALIDATING\",\n                        payload: false\n                    });\n                });\n            } else {\n                dispatch({\n                    type: \"SET_FIELD_ERROR\",\n                    payload: {\n                        field: name,\n                        value: maybePromise\n                    }\n                });\n                return Promise.resolve(maybePromise);\n            }\n        } else if (props.validationSchema) {\n            dispatch({\n                type: \"SET_ISVALIDATING\",\n                payload: true\n            });\n            return runValidationSchema(state.values, name).then(function(x) {\n                return x;\n            }).then(function(error) {\n                dispatch({\n                    type: \"SET_FIELD_ERROR\",\n                    payload: {\n                        field: name,\n                        value: getIn(error, name)\n                    }\n                });\n                dispatch({\n                    type: \"SET_ISVALIDATING\",\n                    payload: false\n                });\n            });\n        }\n        return Promise.resolve();\n    });\n    var registerField = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(name, _ref3) {\n        var validate = _ref3.validate;\n        fieldRegistry.current[name] = {\n            validate: validate\n        };\n    }, []);\n    var unregisterField = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(name) {\n        delete fieldRegistry.current[name];\n    }, []);\n    var setTouched = useEventCallback(function(touched, shouldValidate) {\n        dispatch({\n            type: \"SET_TOUCHED\",\n            payload: touched\n        });\n        var willValidate = shouldValidate === undefined ? validateOnBlur : shouldValidate;\n        return willValidate ? validateFormWithHighPriority(state.values) : Promise.resolve();\n    });\n    var setErrors = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(errors) {\n        dispatch({\n            type: \"SET_ERRORS\",\n            payload: errors\n        });\n    }, []);\n    var setValues = useEventCallback(function(values, shouldValidate) {\n        var resolvedValues = isFunction(values) ? values(state.values) : values;\n        dispatch({\n            type: \"SET_VALUES\",\n            payload: resolvedValues\n        });\n        var willValidate = shouldValidate === undefined ? validateOnChange : shouldValidate;\n        return willValidate ? validateFormWithHighPriority(resolvedValues) : Promise.resolve();\n    });\n    var setFieldError = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(field, value) {\n        dispatch({\n            type: \"SET_FIELD_ERROR\",\n            payload: {\n                field: field,\n                value: value\n            }\n        });\n    }, []);\n    var setFieldValue = useEventCallback(function(field, value, shouldValidate) {\n        dispatch({\n            type: \"SET_FIELD_VALUE\",\n            payload: {\n                field: field,\n                value: value\n            }\n        });\n        var willValidate = shouldValidate === undefined ? validateOnChange : shouldValidate;\n        return willValidate ? validateFormWithHighPriority(setIn(state.values, field, value)) : Promise.resolve();\n    });\n    var executeChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(eventOrTextValue, maybePath) {\n        // By default, assume that the first argument is a string. This allows us to use\n        // handleChange with React Native and React Native Web's onChangeText prop which\n        // provides just the value of the input.\n        var field = maybePath;\n        var val = eventOrTextValue;\n        var parsed; // If the first argument is not a string though, it has to be a synthetic React Event (or a fake one),\n        // so we handle like we would a normal HTML change event.\n        if (!isString(eventOrTextValue)) {\n            // If we can, persist the event\n            // @see https://reactjs.org/docs/events.html#event-pooling\n            if (eventOrTextValue.persist) {\n                eventOrTextValue.persist();\n            }\n            var target = eventOrTextValue.target ? eventOrTextValue.target : eventOrTextValue.currentTarget;\n            var type = target.type, name = target.name, id = target.id, value = target.value, checked = target.checked, outerHTML = target.outerHTML, options = target.options, multiple = target.multiple;\n            field = maybePath ? maybePath : name ? name : id;\n            if (!field && \"development\" !== \"production\") {\n                warnAboutMissingIdentifier({\n                    htmlContent: outerHTML,\n                    documentationAnchorLink: \"handlechange-e-reactchangeeventany--void\",\n                    handlerName: \"handleChange\"\n                });\n            }\n            val = /number|range/.test(type) ? (parsed = parseFloat(value), isNaN(parsed) ? \"\" : parsed) : /checkbox/.test(type) // checkboxes\n             ? getValueForCheckbox(getIn(state.values, field), checked, value) : options && multiple // <select multiple>\n             ? getSelectedValues(options) : value;\n        }\n        if (field) {\n            // Set form fields by name\n            setFieldValue(field, val);\n        }\n    }, [\n        setFieldValue,\n        state.values\n    ]);\n    var handleChange = useEventCallback(function(eventOrPath) {\n        if (isString(eventOrPath)) {\n            return function(event) {\n                return executeChange(event, eventOrPath);\n            };\n        } else {\n            executeChange(eventOrPath);\n        }\n    });\n    var setFieldTouched = useEventCallback(function(field, touched, shouldValidate) {\n        if (touched === void 0) {\n            touched = true;\n        }\n        dispatch({\n            type: \"SET_FIELD_TOUCHED\",\n            payload: {\n                field: field,\n                value: touched\n            }\n        });\n        var willValidate = shouldValidate === undefined ? validateOnBlur : shouldValidate;\n        return willValidate ? validateFormWithHighPriority(state.values) : Promise.resolve();\n    });\n    var executeBlur = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(e, path) {\n        if (e.persist) {\n            e.persist();\n        }\n        var _e$target = e.target, name = _e$target.name, id = _e$target.id, outerHTML = _e$target.outerHTML;\n        var field = path ? path : name ? name : id;\n        if (!field && \"development\" !== \"production\") {\n            warnAboutMissingIdentifier({\n                htmlContent: outerHTML,\n                documentationAnchorLink: \"handleblur-e-any--void\",\n                handlerName: \"handleBlur\"\n            });\n        }\n        setFieldTouched(field, true);\n    }, [\n        setFieldTouched\n    ]);\n    var handleBlur = useEventCallback(function(eventOrString) {\n        if (isString(eventOrString)) {\n            return function(event) {\n                return executeBlur(event, eventOrString);\n            };\n        } else {\n            executeBlur(eventOrString);\n        }\n    });\n    var setFormikState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(stateOrCb) {\n        if (isFunction(stateOrCb)) {\n            dispatch({\n                type: \"SET_FORMIK_STATE\",\n                payload: stateOrCb\n            });\n        } else {\n            dispatch({\n                type: \"SET_FORMIK_STATE\",\n                payload: function payload() {\n                    return stateOrCb;\n                }\n            });\n        }\n    }, []);\n    var setStatus = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(status) {\n        dispatch({\n            type: \"SET_STATUS\",\n            payload: status\n        });\n    }, []);\n    var setSubmitting = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(isSubmitting) {\n        dispatch({\n            type: \"SET_ISSUBMITTING\",\n            payload: isSubmitting\n        });\n    }, []);\n    var submitForm = useEventCallback(function() {\n        dispatch({\n            type: \"SUBMIT_ATTEMPT\"\n        });\n        return validateFormWithHighPriority().then(function(combinedErrors) {\n            // In case an error was thrown and passed to the resolved Promise,\n            // `combinedErrors` can be an instance of an Error. We need to check\n            // that and abort the submit.\n            // If we don't do that, calling `Object.keys(new Error())` yields an\n            // empty array, which causes the validation to pass and the form\n            // to be submitted.\n            var isInstanceOfError = combinedErrors instanceof Error;\n            var isActuallyValid = !isInstanceOfError && Object.keys(combinedErrors).length === 0;\n            if (isActuallyValid) {\n                // Proceed with submit...\n                //\n                // To respect sync submit fns, we can't simply wrap executeSubmit in a promise and\n                // _always_ dispatch SUBMIT_SUCCESS because isSubmitting would then always be false.\n                // This would be fine in simple cases, but make it impossible to disable submit\n                // buttons where people use callbacks or promises as side effects (which is basically\n                // all of v1 Formik code). Instead, recall that we are inside of a promise chain already,\n                //  so we can try/catch executeSubmit(), if it returns undefined, then just bail.\n                // If there are errors, throw em. Otherwise, wrap executeSubmit in a promise and handle\n                // cleanup of isSubmitting on behalf of the consumer.\n                var promiseOrUndefined;\n                try {\n                    promiseOrUndefined = executeSubmit(); // Bail if it's sync, consumer is responsible for cleaning up\n                    // via setSubmitting(false)\n                    if (promiseOrUndefined === undefined) {\n                        return;\n                    }\n                } catch (error) {\n                    throw error;\n                }\n                return Promise.resolve(promiseOrUndefined).then(function(result) {\n                    if (!!isMounted.current) {\n                        dispatch({\n                            type: \"SUBMIT_SUCCESS\"\n                        });\n                    }\n                    return result;\n                })[\"catch\"](function(_errors) {\n                    if (!!isMounted.current) {\n                        dispatch({\n                            type: \"SUBMIT_FAILURE\"\n                        }); // This is a legit error rejected by the onSubmit fn\n                        // so we don't want to break the promise chain\n                        throw _errors;\n                    }\n                });\n            } else if (!!isMounted.current) {\n                // ^^^ Make sure Formik is still mounted before updating state\n                dispatch({\n                    type: \"SUBMIT_FAILURE\"\n                }); // throw combinedErrors;\n                if (isInstanceOfError) {\n                    throw combinedErrors;\n                }\n            }\n            return;\n        });\n    });\n    var handleSubmit = useEventCallback(function(e) {\n        if (e && e.preventDefault && isFunction(e.preventDefault)) {\n            e.preventDefault();\n        }\n        if (e && e.stopPropagation && isFunction(e.stopPropagation)) {\n            e.stopPropagation();\n        } // Warn if form submission is triggered by a <button> without a\n        // specified `type` attribute during development. This mitigates\n        // a common gotcha in forms with both reset and submit buttons,\n        // where the dev forgets to add type=\"button\" to the reset button.\n        if ( true && typeof document !== \"undefined\") {\n            // Safely get the active element (works with IE)\n            var activeElement = getActiveElement();\n            if (activeElement !== null && activeElement instanceof HTMLButtonElement) {\n                !(activeElement.attributes && activeElement.attributes.getNamedItem(\"type\")) ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, 'You submitted a Formik form using a button with an unspecified `type` attribute.  Most browsers default button elements to `type=\"submit\"`. If this is not a submit button, please add `type=\"button\"`.') : 0 : void 0;\n            }\n        }\n        submitForm()[\"catch\"](function(reason) {\n            console.warn(\"Warning: An unhandled error was caught from submitForm()\", reason);\n        });\n    });\n    var imperativeMethods = {\n        resetForm: resetForm,\n        validateForm: validateFormWithHighPriority,\n        validateField: validateField,\n        setErrors: setErrors,\n        setFieldError: setFieldError,\n        setFieldTouched: setFieldTouched,\n        setFieldValue: setFieldValue,\n        setStatus: setStatus,\n        setSubmitting: setSubmitting,\n        setTouched: setTouched,\n        setValues: setValues,\n        setFormikState: setFormikState,\n        submitForm: submitForm\n    };\n    var executeSubmit = useEventCallback(function() {\n        return onSubmit(state.values, imperativeMethods);\n    });\n    var handleReset = useEventCallback(function(e) {\n        if (e && e.preventDefault && isFunction(e.preventDefault)) {\n            e.preventDefault();\n        }\n        if (e && e.stopPropagation && isFunction(e.stopPropagation)) {\n            e.stopPropagation();\n        }\n        resetForm();\n    });\n    var getFieldMeta = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(name) {\n        return {\n            value: getIn(state.values, name),\n            error: getIn(state.errors, name),\n            touched: !!getIn(state.touched, name),\n            initialValue: getIn(initialValues.current, name),\n            initialTouched: !!getIn(initialTouched.current, name),\n            initialError: getIn(initialErrors.current, name)\n        };\n    }, [\n        state.errors,\n        state.touched,\n        state.values\n    ]);\n    var getFieldHelpers = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(name) {\n        return {\n            setValue: function setValue(value, shouldValidate) {\n                return setFieldValue(name, value, shouldValidate);\n            },\n            setTouched: function setTouched(value, shouldValidate) {\n                return setFieldTouched(name, value, shouldValidate);\n            },\n            setError: function setError(value) {\n                return setFieldError(name, value);\n            }\n        };\n    }, [\n        setFieldValue,\n        setFieldTouched,\n        setFieldError\n    ]);\n    var getFieldProps = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function(nameOrOptions) {\n        var isAnObject = isObject(nameOrOptions);\n        var name = isAnObject ? nameOrOptions.name : nameOrOptions;\n        var valueState = getIn(state.values, name);\n        var field = {\n            name: name,\n            value: valueState,\n            onChange: handleChange,\n            onBlur: handleBlur\n        };\n        if (isAnObject) {\n            var type = nameOrOptions.type, valueProp = nameOrOptions.value, is = nameOrOptions.as, multiple = nameOrOptions.multiple;\n            if (type === \"checkbox\") {\n                if (valueProp === undefined) {\n                    field.checked = !!valueState;\n                } else {\n                    field.checked = !!(Array.isArray(valueState) && ~valueState.indexOf(valueProp));\n                    field.value = valueProp;\n                }\n            } else if (type === \"radio\") {\n                field.checked = valueState === valueProp;\n                field.value = valueProp;\n            } else if (is === \"select\" && multiple) {\n                field.value = field.value || [];\n                field.multiple = true;\n            }\n        }\n        return field;\n    }, [\n        handleBlur,\n        handleChange,\n        state.values\n    ]);\n    var dirty = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function() {\n        return !react_fast_compare__WEBPACK_IMPORTED_MODULE_2___default()(initialValues.current, state.values);\n    }, [\n        initialValues.current,\n        state.values\n    ]);\n    var isValid = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function() {\n        return typeof isInitialValid !== \"undefined\" ? dirty ? state.errors && Object.keys(state.errors).length === 0 : isInitialValid !== false && isFunction(isInitialValid) ? isInitialValid(props) : isInitialValid : state.errors && Object.keys(state.errors).length === 0;\n    }, [\n        isInitialValid,\n        dirty,\n        state.errors,\n        props\n    ]);\n    var ctx = _extends({}, state, {\n        initialValues: initialValues.current,\n        initialErrors: initialErrors.current,\n        initialTouched: initialTouched.current,\n        initialStatus: initialStatus.current,\n        handleBlur: handleBlur,\n        handleChange: handleChange,\n        handleReset: handleReset,\n        handleSubmit: handleSubmit,\n        resetForm: resetForm,\n        setErrors: setErrors,\n        setFormikState: setFormikState,\n        setFieldTouched: setFieldTouched,\n        setFieldValue: setFieldValue,\n        setFieldError: setFieldError,\n        setStatus: setStatus,\n        setSubmitting: setSubmitting,\n        setTouched: setTouched,\n        setValues: setValues,\n        submitForm: submitForm,\n        validateForm: validateFormWithHighPriority,\n        validateField: validateField,\n        isValid: isValid,\n        dirty: dirty,\n        unregisterField: unregisterField,\n        registerField: registerField,\n        getFieldProps: getFieldProps,\n        getFieldMeta: getFieldMeta,\n        getFieldHelpers: getFieldHelpers,\n        validateOnBlur: validateOnBlur,\n        validateOnChange: validateOnChange,\n        validateOnMount: validateOnMount\n    });\n    return ctx;\n}\nfunction Formik(props) {\n    var formikbag = useFormik(props);\n    var component = props.component, children = props.children, render = props.render, innerRef = props.innerRef; // This allows folks to pass a ref to <Formik />\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle)(innerRef, function() {\n        return formikbag;\n    });\n    if (true) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n            !!props.render ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, \"<Formik render> has been deprecated and will be removed in future versions of Formik. Please use a child callback function instead. To get rid of this warning, replace <Formik render={(props) => ...} /> with <Formik>{(props) => ...}</Formik>\") : 0 : void 0; // eslint-disable-next-line\n        }, []);\n    }\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(FormikProvider, {\n        value: formikbag\n    }, component ? /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(component, formikbag) : render ? render(formikbag) : children // children come last, always called\n     ? isFunction(children) ? children(formikbag) : !isEmptyChildren(children) ? react__WEBPACK_IMPORTED_MODULE_1__.Children.only(children) : null : null);\n}\nfunction warnAboutMissingIdentifier(_ref4) {\n    var htmlContent = _ref4.htmlContent, documentationAnchorLink = _ref4.documentationAnchorLink, handlerName = _ref4.handlerName;\n    console.warn(\"Warning: Formik called `\" + handlerName + \"`, but you forgot to pass an `id` or `name` attribute to your input:\\n    \" + htmlContent + \"\\n    Formik cannot determine which value to update. For more info see https://formik.org/docs/api/formik#\" + documentationAnchorLink + \"\\n  \");\n}\n/**\r\n * Transform Yup ValidationError to a more usable object\r\n */ function yupToFormErrors(yupError) {\n    var errors = {};\n    if (yupError.inner) {\n        if (yupError.inner.length === 0) {\n            return setIn(errors, yupError.path, yupError.message);\n        }\n        for(var _iterator = yupError.inner, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;){\n            var _ref5;\n            if (_isArray) {\n                if (_i >= _iterator.length) break;\n                _ref5 = _iterator[_i++];\n            } else {\n                _i = _iterator.next();\n                if (_i.done) break;\n                _ref5 = _i.value;\n            }\n            var err = _ref5;\n            if (!getIn(errors, err.path)) {\n                errors = setIn(errors, err.path, err.message);\n            }\n        }\n    }\n    return errors;\n}\n/**\r\n * Validate a yup schema.\r\n */ function validateYupSchema(values, schema, sync, context) {\n    if (sync === void 0) {\n        sync = false;\n    }\n    var normalizedValues = prepareDataForValidation(values);\n    return schema[sync ? \"validateSync\" : \"validate\"](normalizedValues, {\n        abortEarly: false,\n        context: context || normalizedValues\n    });\n}\n/**\r\n * Recursively prepare values.\r\n */ function prepareDataForValidation(values) {\n    var data = Array.isArray(values) ? [] : {};\n    for(var k in values){\n        if (Object.prototype.hasOwnProperty.call(values, k)) {\n            var key = String(k);\n            if (Array.isArray(values[key]) === true) {\n                data[key] = values[key].map(function(value) {\n                    if (Array.isArray(value) === true || (0,lodash_es_isPlainObject__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(value)) {\n                        return prepareDataForValidation(value);\n                    } else {\n                        return value !== \"\" ? value : undefined;\n                    }\n                });\n            } else if ((0,lodash_es_isPlainObject__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(values[key])) {\n                data[key] = prepareDataForValidation(values[key]);\n            } else {\n                data[key] = values[key] !== \"\" ? values[key] : undefined;\n            }\n        }\n    }\n    return data;\n}\n/**\r\n * deepmerge array merging algorithm\r\n * https://github.com/KyleAMathews/deepmerge#combine-array\r\n */ function arrayMerge(target, source, options) {\n    var destination = target.slice();\n    source.forEach(function merge(e, i) {\n        if (typeof destination[i] === \"undefined\") {\n            var cloneRequested = options.clone !== false;\n            var shouldClone = cloneRequested && options.isMergeableObject(e);\n            destination[i] = shouldClone ? (0,deepmerge__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(Array.isArray(e) ? [] : {}, e, options) : e;\n        } else if (options.isMergeableObject(e)) {\n            destination[i] = (0,deepmerge__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target[i], e, options);\n        } else if (target.indexOf(e) === -1) {\n            destination.push(e);\n        }\n    });\n    return destination;\n}\n/** Return multi select values based on an array of options */ function getSelectedValues(options) {\n    return Array.from(options).filter(function(el) {\n        return el.selected;\n    }).map(function(el) {\n        return el.value;\n    });\n}\n/** Return the next value for a checkbox */ function getValueForCheckbox(currentValue, checked, valueProp) {\n    // If the current value was a boolean, return a boolean\n    if (typeof currentValue === \"boolean\") {\n        return Boolean(checked);\n    } // If the currentValue was not a boolean we want to return an array\n    var currentArrayOfValues = [];\n    var isValueInArray = false;\n    var index = -1;\n    if (!Array.isArray(currentValue)) {\n        // eslint-disable-next-line eqeqeq\n        if (!valueProp || valueProp == \"true\" || valueProp == \"false\") {\n            return Boolean(checked);\n        }\n    } else {\n        // If the current value is already an array, use it\n        currentArrayOfValues = currentValue;\n        index = currentValue.indexOf(valueProp);\n        isValueInArray = index >= 0;\n    } // If the checkbox was checked and the value is not already present in the aray we want to add the new value to the array of values\n    if (checked && valueProp && !isValueInArray) {\n        return currentArrayOfValues.concat(valueProp);\n    } // If the checkbox was unchecked and the value is not in the array, simply return the already existing array of values\n    if (!isValueInArray) {\n        return currentArrayOfValues;\n    } // If the checkbox was unchecked and the value is in the array, remove the value and return the array\n    return currentArrayOfValues.slice(0, index).concat(currentArrayOfValues.slice(index + 1));\n} // React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\n// @see https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85\nvar useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_1__.useEffect;\nfunction useEventCallback(fn) {\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(fn); // we copy a ref to the callback scoped to the current state/props on each render\n    useIsomorphicLayoutEffect(function() {\n        ref.current = fn;\n    });\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return ref.current.apply(void 0, args);\n    }, []);\n}\nfunction useField(propsOrFieldName) {\n    var formik = useFormikContext();\n    var getFieldProps = formik.getFieldProps, getFieldMeta = formik.getFieldMeta, getFieldHelpers = formik.getFieldHelpers, registerField = formik.registerField, unregisterField = formik.unregisterField;\n    var isAnObject = isObject(propsOrFieldName); // Normalize propsOrFieldName to FieldHookConfig<Val>\n    var props = isAnObject ? propsOrFieldName : {\n        name: propsOrFieldName\n    };\n    var fieldName = props.name, validateFn = props.validate;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        if (fieldName) {\n            registerField(fieldName, {\n                validate: validateFn\n            });\n        }\n        return function() {\n            if (fieldName) {\n                unregisterField(fieldName);\n            }\n        };\n    }, [\n        registerField,\n        unregisterField,\n        fieldName,\n        validateFn\n    ]);\n    if (true) {\n        !formik ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, \"useField() / <Field /> must be used underneath a <Formik> component or withFormik() higher order component\") : 0 : void 0;\n    }\n    !fieldName ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, \"Invalid field name. Either pass `useField` a string or an object containing a `name` key.\") : 0 : void 0;\n    var fieldHelpers = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function() {\n        return getFieldHelpers(fieldName);\n    }, [\n        getFieldHelpers,\n        fieldName\n    ]);\n    return [\n        getFieldProps(props),\n        getFieldMeta(fieldName),\n        fieldHelpers\n    ];\n}\nfunction Field(_ref) {\n    var validate = _ref.validate, name = _ref.name, render = _ref.render, children = _ref.children, is = _ref.as, component = _ref.component, className = _ref.className, props = _objectWithoutPropertiesLoose(_ref, [\n        \"validate\",\n        \"name\",\n        \"render\",\n        \"children\",\n        \"as\",\n        \"component\",\n        \"className\"\n    ]);\n    var _useFormikContext = useFormikContext(), formik = _objectWithoutPropertiesLoose(_useFormikContext, [\n        \"validate\",\n        \"validationSchema\"\n    ]);\n    if (true) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n            !!render ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, '<Field render> has been deprecated and will be removed in future versions of Formik. Please use a child callback function instead. To get rid of this warning, replace <Field name=\"' + name + '\" render={({field, form}) => ...} /> with <Field name=\"' + name + '\">{({field, form, meta}) => ...}</Field>') : 0 : void 0;\n            !!(is && children && isFunction(children)) ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, \"You should not use <Field as> and <Field children> as a function in the same <Field> component; <Field as> will be ignored.\") : 0 : void 0;\n            !!(component && children && isFunction(children)) ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, \"You should not use <Field component> and <Field children> as a function in the same <Field> component; <Field component> will be ignored.\") : 0 : void 0;\n            !!(render && children && !isEmptyChildren(children)) ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, \"You should not use <Field render> and <Field children> in the same <Field> component; <Field children> will be ignored\") : 0 : void 0; // eslint-disable-next-line\n        }, []);\n    } // Register field and field-level validation with parent <Formik>\n    var registerField = formik.registerField, unregisterField = formik.unregisterField;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        registerField(name, {\n            validate: validate\n        });\n        return function() {\n            unregisterField(name);\n        };\n    }, [\n        registerField,\n        unregisterField,\n        name,\n        validate\n    ]);\n    var field = formik.getFieldProps(_extends({\n        name: name\n    }, props));\n    var meta = formik.getFieldMeta(name);\n    var legacyBag = {\n        field: field,\n        form: formik\n    };\n    if (render) {\n        return render(_extends({}, legacyBag, {\n            meta: meta\n        }));\n    }\n    if (isFunction(children)) {\n        return children(_extends({}, legacyBag, {\n            meta: meta\n        }));\n    }\n    if (component) {\n        // This behavior is backwards compat with earlier Formik 0.9 to 1.x\n        if (typeof component === \"string\") {\n            var innerRef = props.innerRef, rest = _objectWithoutPropertiesLoose(props, [\n                \"innerRef\"\n            ]);\n            return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(component, _extends({\n                ref: innerRef\n            }, field, rest, {\n                className: className\n            }), children);\n        } // We don't pass `meta` for backwards compat\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(component, _extends({\n            field: field,\n            form: formik\n        }, props, {\n            className: className\n        }), children);\n    } // default to input here so we can check for both `as` and `children` above\n    var asElement = is || \"input\";\n    if (typeof asElement === \"string\") {\n        var _innerRef = props.innerRef, _rest = _objectWithoutPropertiesLoose(props, [\n            \"innerRef\"\n        ]);\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(asElement, _extends({\n            ref: _innerRef\n        }, field, _rest, {\n            className: className\n        }), children);\n    }\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(asElement, _extends({}, field, props, {\n        className: className\n    }), children);\n}\nvar Form = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(function(props, ref) {\n    // iOS needs an \"action\" attribute for nice input: https://stackoverflow.com/a/39485162/406725\n    // We default the action to \"#\" in case the preventDefault fails (just updates the URL hash)\n    var action = props.action, rest = _objectWithoutPropertiesLoose(props, [\n        \"action\"\n    ]);\n    var _action = action != null ? action : \"#\";\n    var _useFormikContext = useFormikContext(), handleReset = _useFormikContext.handleReset, handleSubmit = _useFormikContext.handleSubmit;\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"form\", _extends({\n        onSubmit: handleSubmit,\n        ref: ref,\n        onReset: handleReset,\n        action: _action\n    }, rest));\n});\nForm.displayName = \"Form\";\n/**\r\n * A public higher-order component to access the imperative API\r\n */ function withFormik(_ref) {\n    var _ref$mapPropsToValues = _ref.mapPropsToValues, mapPropsToValues = _ref$mapPropsToValues === void 0 ? function(vanillaProps) {\n        var val = {};\n        for(var k in vanillaProps){\n            if (vanillaProps.hasOwnProperty(k) && typeof vanillaProps[k] !== \"function\") {\n                // @todo TypeScript fix\n                val[k] = vanillaProps[k];\n            }\n        }\n        return val;\n    } : _ref$mapPropsToValues, config = _objectWithoutPropertiesLoose(_ref, [\n        \"mapPropsToValues\"\n    ]);\n    return function createFormik(Component$1) {\n        var componentDisplayName = Component$1.displayName || Component$1.name || Component$1.constructor && Component$1.constructor.name || \"Component\";\n        /**\r\n     * We need to use closures here for to provide the wrapped component's props to\r\n     * the respective withFormik config methods.\r\n     */ var C = /*#__PURE__*/ function(_React$Component) {\n            _inheritsLoose(C, _React$Component);\n            function C() {\n                var _this;\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                _this = _React$Component.call.apply(_React$Component, [\n                    this\n                ].concat(args)) || this;\n                _this.validate = function(values) {\n                    return config.validate(values, _this.props);\n                };\n                _this.validationSchema = function() {\n                    return isFunction(config.validationSchema) ? config.validationSchema(_this.props) : config.validationSchema;\n                };\n                _this.handleSubmit = function(values, actions) {\n                    return config.handleSubmit(values, _extends({}, actions, {\n                        props: _this.props\n                    }));\n                };\n                _this.renderFormComponent = function(formikProps) {\n                    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(Component$1, _extends({}, _this.props, formikProps));\n                };\n                return _this;\n            }\n            var _proto = C.prototype;\n            _proto.render = function render() {\n                var _this$props = this.props, props = _objectWithoutPropertiesLoose(_this$props, [\n                    \"children\"\n                ]);\n                return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(Formik, _extends({}, props, config, {\n                    validate: config.validate && this.validate,\n                    validationSchema: config.validationSchema && this.validationSchema,\n                    initialValues: mapPropsToValues(this.props),\n                    initialStatus: config.mapPropsToStatus && config.mapPropsToStatus(this.props),\n                    initialErrors: config.mapPropsToErrors && config.mapPropsToErrors(this.props),\n                    initialTouched: config.mapPropsToTouched && config.mapPropsToTouched(this.props),\n                    onSubmit: this.handleSubmit,\n                    children: this.renderFormComponent\n                }));\n            };\n            return C;\n        }(react__WEBPACK_IMPORTED_MODULE_1__.Component);\n        C.displayName = \"WithFormik(\" + componentDisplayName + \")\";\n        return hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_3___default()(C, Component$1 // cast type to ComponentClass (even if SFC)\n        );\n    };\n}\n/**\r\n * Connect any component to Formik context, and inject as a prop called `formik`;\r\n * @param Comp React Component\r\n */ function connect(Comp) {\n    var C = function C(props) {\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(FormikConsumer, null, function(formik) {\n            !!!formik ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, \"Formik context is undefined, please verify you are rendering <Form>, <Field>, <FastField>, <FieldArray>, or your custom context-using component as a child of a <Formik> component. Component name: \" + Comp.name) : 0 : void 0;\n            return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(Comp, _extends({}, props, {\n                formik: formik\n            }));\n        });\n    };\n    var componentDisplayName = Comp.displayName || Comp.name || Comp.constructor && Comp.constructor.name || \"Component\"; // Assign Comp to C.WrappedComponent so we can access the inner component in tests\n    // For example, <Field.WrappedComponent /> gets us <FieldInner/>\n    C.WrappedComponent = Comp;\n    C.displayName = \"FormikConnect(\" + componentDisplayName + \")\";\n    return hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_3___default()(C, Comp // cast type to ComponentClass (even if SFC)\n    );\n}\n/**\r\n * Some array helpers!\r\n */ var move = function move(array, from, to) {\n    var copy = copyArrayLike(array);\n    var value = copy[from];\n    copy.splice(from, 1);\n    copy.splice(to, 0, value);\n    return copy;\n};\nvar swap = function swap(arrayLike, indexA, indexB) {\n    var copy = copyArrayLike(arrayLike);\n    var a = copy[indexA];\n    copy[indexA] = copy[indexB];\n    copy[indexB] = a;\n    return copy;\n};\nvar insert = function insert(arrayLike, index, value) {\n    var copy = copyArrayLike(arrayLike);\n    copy.splice(index, 0, value);\n    return copy;\n};\nvar replace = function replace(arrayLike, index, value) {\n    var copy = copyArrayLike(arrayLike);\n    copy[index] = value;\n    return copy;\n};\nvar copyArrayLike = function copyArrayLike(arrayLike) {\n    if (!arrayLike) {\n        return [];\n    } else if (Array.isArray(arrayLike)) {\n        return [].concat(arrayLike);\n    } else {\n        var maxIndex = Object.keys(arrayLike).map(function(key) {\n            return parseInt(key);\n        }).reduce(function(max, el) {\n            return el > max ? el : max;\n        }, 0);\n        return Array.from(_extends({}, arrayLike, {\n            length: maxIndex + 1\n        }));\n    }\n};\nvar createAlterationHandler = function createAlterationHandler(alteration, defaultFunction) {\n    var fn = typeof alteration === \"function\" ? alteration : defaultFunction;\n    return function(data) {\n        if (Array.isArray(data) || isObject(data)) {\n            var clone = copyArrayLike(data);\n            return fn(clone);\n        } // This can be assumed to be a primitive, which\n        // is a case for top level validation errors\n        return data;\n    };\n};\nvar FieldArrayInner = /*#__PURE__*/ function(_React$Component) {\n    _inheritsLoose(FieldArrayInner, _React$Component);\n    function FieldArrayInner(props) {\n        var _this;\n        _this = _React$Component.call(this, props) || this; // We need TypeScript generics on these, so we'll bind them in the constructor\n        // @todo Fix TS 3.2.1\n        _this.updateArrayField = function(fn, alterTouched, alterErrors) {\n            var _this$props = _this.props, name = _this$props.name, setFormikState = _this$props.formik.setFormikState;\n            setFormikState(function(prevState) {\n                var updateErrors = createAlterationHandler(alterErrors, fn);\n                var updateTouched = createAlterationHandler(alterTouched, fn); // values fn should be executed before updateErrors and updateTouched,\n                // otherwise it causes an error with unshift.\n                var values = setIn(prevState.values, name, fn(getIn(prevState.values, name)));\n                var fieldError = alterErrors ? updateErrors(getIn(prevState.errors, name)) : undefined;\n                var fieldTouched = alterTouched ? updateTouched(getIn(prevState.touched, name)) : undefined;\n                if (isEmptyArray(fieldError)) {\n                    fieldError = undefined;\n                }\n                if (isEmptyArray(fieldTouched)) {\n                    fieldTouched = undefined;\n                }\n                return _extends({}, prevState, {\n                    values: values,\n                    errors: alterErrors ? setIn(prevState.errors, name, fieldError) : prevState.errors,\n                    touched: alterTouched ? setIn(prevState.touched, name, fieldTouched) : prevState.touched\n                });\n            });\n        };\n        _this.push = function(value) {\n            return _this.updateArrayField(function(arrayLike) {\n                return [].concat(copyArrayLike(arrayLike), [\n                    (0,lodash_es_cloneDeep__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(value)\n                ]);\n            }, false, false);\n        };\n        _this.handlePush = function(value) {\n            return function() {\n                return _this.push(value);\n            };\n        };\n        _this.swap = function(indexA, indexB) {\n            return _this.updateArrayField(function(array) {\n                return swap(array, indexA, indexB);\n            }, true, true);\n        };\n        _this.handleSwap = function(indexA, indexB) {\n            return function() {\n                return _this.swap(indexA, indexB);\n            };\n        };\n        _this.move = function(from, to) {\n            return _this.updateArrayField(function(array) {\n                return move(array, from, to);\n            }, true, true);\n        };\n        _this.handleMove = function(from, to) {\n            return function() {\n                return _this.move(from, to);\n            };\n        };\n        _this.insert = function(index, value) {\n            return _this.updateArrayField(function(array) {\n                return insert(array, index, value);\n            }, function(array) {\n                return insert(array, index, null);\n            }, function(array) {\n                return insert(array, index, null);\n            });\n        };\n        _this.handleInsert = function(index, value) {\n            return function() {\n                return _this.insert(index, value);\n            };\n        };\n        _this.replace = function(index, value) {\n            return _this.updateArrayField(function(array) {\n                return replace(array, index, value);\n            }, false, false);\n        };\n        _this.handleReplace = function(index, value) {\n            return function() {\n                return _this.replace(index, value);\n            };\n        };\n        _this.unshift = function(value) {\n            var length = -1;\n            _this.updateArrayField(function(array) {\n                var arr = array ? [\n                    value\n                ].concat(array) : [\n                    value\n                ];\n                length = arr.length;\n                return arr;\n            }, function(array) {\n                return array ? [\n                    null\n                ].concat(array) : [\n                    null\n                ];\n            }, function(array) {\n                return array ? [\n                    null\n                ].concat(array) : [\n                    null\n                ];\n            });\n            return length;\n        };\n        _this.handleUnshift = function(value) {\n            return function() {\n                return _this.unshift(value);\n            };\n        };\n        _this.handleRemove = function(index) {\n            return function() {\n                return _this.remove(index);\n            };\n        };\n        _this.handlePop = function() {\n            return function() {\n                return _this.pop();\n            };\n        };\n        _this.remove = _this.remove.bind(_assertThisInitialized(_this));\n        _this.pop = _this.pop.bind(_assertThisInitialized(_this));\n        return _this;\n    }\n    var _proto = FieldArrayInner.prototype;\n    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n        if (this.props.validateOnChange && this.props.formik.validateOnChange && !react_fast_compare__WEBPACK_IMPORTED_MODULE_2___default()(getIn(prevProps.formik.values, prevProps.name), getIn(this.props.formik.values, this.props.name))) {\n            this.props.formik.validateForm(this.props.formik.values);\n        }\n    };\n    _proto.remove = function remove(index) {\n        // We need to make sure we also remove relevant pieces of `touched` and `errors`\n        var result;\n        this.updateArrayField(function(array) {\n            var copy = array ? copyArrayLike(array) : [];\n            if (!result) {\n                result = copy[index];\n            }\n            if (isFunction(copy.splice)) {\n                copy.splice(index, 1);\n            } // if the array only includes undefined values we have to return an empty array\n            return isFunction(copy.every) ? copy.every(function(v) {\n                return v === undefined;\n            }) ? [] : copy : copy;\n        }, true, true);\n        return result;\n    };\n    _proto.pop = function pop() {\n        // Remove relevant pieces of `touched` and `errors` too!\n        var result;\n        this.updateArrayField(function(array) {\n            var tmp = array.slice();\n            if (!result) {\n                result = tmp && tmp.pop && tmp.pop();\n            }\n            return tmp;\n        }, true, true);\n        return result;\n    };\n    _proto.render = function render() {\n        var arrayHelpers = {\n            push: this.push,\n            pop: this.pop,\n            swap: this.swap,\n            move: this.move,\n            insert: this.insert,\n            replace: this.replace,\n            unshift: this.unshift,\n            remove: this.remove,\n            handlePush: this.handlePush,\n            handlePop: this.handlePop,\n            handleSwap: this.handleSwap,\n            handleMove: this.handleMove,\n            handleInsert: this.handleInsert,\n            handleReplace: this.handleReplace,\n            handleUnshift: this.handleUnshift,\n            handleRemove: this.handleRemove\n        };\n        var _this$props2 = this.props, component = _this$props2.component, render = _this$props2.render, children = _this$props2.children, name = _this$props2.name, _this$props2$formik = _this$props2.formik, restOfFormik = _objectWithoutPropertiesLoose(_this$props2$formik, [\n            \"validate\",\n            \"validationSchema\"\n        ]);\n        var props = _extends({}, arrayHelpers, {\n            form: restOfFormik,\n            name: name\n        });\n        return component ? /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(component, props) : render ? render(props) : children // children come last, always called\n         ? typeof children === \"function\" ? children(props) : !isEmptyChildren(children) ? react__WEBPACK_IMPORTED_MODULE_1__.Children.only(children) : null : null;\n    };\n    return FieldArrayInner;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component);\nFieldArrayInner.defaultProps = {\n    validateOnChange: true\n};\nvar FieldArray = /*#__PURE__*/ connect(FieldArrayInner);\nvar ErrorMessageImpl = /*#__PURE__*/ function(_React$Component) {\n    _inheritsLoose(ErrorMessageImpl, _React$Component);\n    function ErrorMessageImpl() {\n        return _React$Component.apply(this, arguments) || this;\n    }\n    var _proto = ErrorMessageImpl.prototype;\n    _proto.shouldComponentUpdate = function shouldComponentUpdate(props) {\n        if (getIn(this.props.formik.errors, this.props.name) !== getIn(props.formik.errors, this.props.name) || getIn(this.props.formik.touched, this.props.name) !== getIn(props.formik.touched, this.props.name) || Object.keys(this.props).length !== Object.keys(props).length) {\n            return true;\n        } else {\n            return false;\n        }\n    };\n    _proto.render = function render() {\n        var _this$props = this.props, component = _this$props.component, formik = _this$props.formik, render = _this$props.render, children = _this$props.children, name = _this$props.name, rest = _objectWithoutPropertiesLoose(_this$props, [\n            \"component\",\n            \"formik\",\n            \"render\",\n            \"children\",\n            \"name\"\n        ]);\n        var touch = getIn(formik.touched, name);\n        var error = getIn(formik.errors, name);\n        return !!touch && !!error ? render ? isFunction(render) ? render(error) : null : children ? isFunction(children) ? children(error) : null : component ? /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(component, rest, error) : error : null;\n    };\n    return ErrorMessageImpl;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component);\nvar ErrorMessage = /*#__PURE__*/ connect(ErrorMessageImpl);\n/**\r\n * Custom Field component for quickly hooking into Formik\r\n * context and wiring up forms.\r\n */ var FastFieldInner = /*#__PURE__*/ function(_React$Component) {\n    _inheritsLoose(FastFieldInner, _React$Component);\n    function FastFieldInner(props) {\n        var _this;\n        _this = _React$Component.call(this, props) || this;\n        var render = props.render, children = props.children, component = props.component, is = props.as, name = props.name;\n        !!render ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, \"<FastField render> has been deprecated. Please use a child callback function instead: <FastField name={\" + name + \"}>{props => ...}</FastField> instead.\") : 0 : void 0;\n        !!(component && render) ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, \"You should not use <FastField component> and <FastField render> in the same <FastField> component; <FastField component> will be ignored\") : 0 : void 0;\n        !!(is && children && isFunction(children)) ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, \"You should not use <FastField as> and <FastField children> as a function in the same <FastField> component; <FastField as> will be ignored.\") : 0 : void 0;\n        !!(component && children && isFunction(children)) ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, \"You should not use <FastField component> and <FastField children> as a function in the same <FastField> component; <FastField component> will be ignored.\") : 0 : void 0;\n        !!(render && children && !isEmptyChildren(children)) ?  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, \"You should not use <FastField render> and <FastField children> in the same <FastField> component; <FastField children> will be ignored\") : 0 : void 0;\n        return _this;\n    }\n    var _proto = FastFieldInner.prototype;\n    _proto.shouldComponentUpdate = function shouldComponentUpdate(props) {\n        if (this.props.shouldUpdate) {\n            return this.props.shouldUpdate(props, this.props);\n        } else if (props.name !== this.props.name || getIn(props.formik.values, this.props.name) !== getIn(this.props.formik.values, this.props.name) || getIn(props.formik.errors, this.props.name) !== getIn(this.props.formik.errors, this.props.name) || getIn(props.formik.touched, this.props.name) !== getIn(this.props.formik.touched, this.props.name) || Object.keys(this.props).length !== Object.keys(props).length || props.formik.isSubmitting !== this.props.formik.isSubmitting) {\n            return true;\n        } else {\n            return false;\n        }\n    };\n    _proto.componentDidMount = function componentDidMount() {\n        // Register the Field with the parent Formik. Parent will cycle through\n        // registered Field's validate fns right prior to submit\n        this.props.formik.registerField(this.props.name, {\n            validate: this.props.validate\n        });\n    };\n    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n        if (this.props.name !== prevProps.name) {\n            this.props.formik.unregisterField(prevProps.name);\n            this.props.formik.registerField(this.props.name, {\n                validate: this.props.validate\n            });\n        }\n        if (this.props.validate !== prevProps.validate) {\n            this.props.formik.registerField(this.props.name, {\n                validate: this.props.validate\n            });\n        }\n    };\n    _proto.componentWillUnmount = function componentWillUnmount() {\n        this.props.formik.unregisterField(this.props.name);\n    };\n    _proto.render = function render() {\n        var _this$props = this.props, name = _this$props.name, render = _this$props.render, is = _this$props.as, children = _this$props.children, component = _this$props.component, formik = _this$props.formik, props = _objectWithoutPropertiesLoose(_this$props, [\n            \"validate\",\n            \"name\",\n            \"render\",\n            \"as\",\n            \"children\",\n            \"component\",\n            \"shouldUpdate\",\n            \"formik\"\n        ]);\n        var restOfFormik = _objectWithoutPropertiesLoose(formik, [\n            \"validate\",\n            \"validationSchema\"\n        ]);\n        var field = formik.getFieldProps(_extends({\n            name: name\n        }, props));\n        var meta = {\n            value: getIn(formik.values, name),\n            error: getIn(formik.errors, name),\n            touched: !!getIn(formik.touched, name),\n            initialValue: getIn(formik.initialValues, name),\n            initialTouched: !!getIn(formik.initialTouched, name),\n            initialError: getIn(formik.initialErrors, name)\n        };\n        var bag = {\n            field: field,\n            meta: meta,\n            form: restOfFormik\n        };\n        if (render) {\n            return render(bag);\n        }\n        if (isFunction(children)) {\n            return children(bag);\n        }\n        if (component) {\n            // This behavior is backwards compat with earlier Formik 0.9 to 1.x\n            if (typeof component === \"string\") {\n                var innerRef = props.innerRef, rest = _objectWithoutPropertiesLoose(props, [\n                    \"innerRef\"\n                ]);\n                return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(component, _extends({\n                    ref: innerRef\n                }, field, rest), children);\n            } // We don't pass `meta` for backwards compat\n            return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(component, _extends({\n                field: field,\n                form: formik\n            }, props), children);\n        } // default to input here so we can check for both `as` and `children` above\n        var asElement = is || \"input\";\n        if (typeof asElement === \"string\") {\n            var _innerRef = props.innerRef, _rest = _objectWithoutPropertiesLoose(props, [\n                \"innerRef\"\n            ]);\n            return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(asElement, _extends({\n                ref: _innerRef\n            }, field, _rest), children);\n        }\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(asElement, _extends({}, field, props), children);\n    };\n    return FastFieldInner;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component);\nvar FastField = /*#__PURE__*/ connect(FastFieldInner);\n //# sourceMappingURL=formik.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZm9ybWlrL2Rpc3QvZm9ybWlrLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtDO0FBQ2tCO0FBQ1I7QUFDK0k7QUFDbEo7QUFDSjtBQUNEO0FBQ0U7QUFDcUI7QUFFM0QsU0FBU3FCO0lBQ1BBLFdBQVdDLE9BQU9DLE1BQU0sSUFBSSxTQUFVQyxNQUFNO1FBQzFDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7WUFDekMsSUFBSUcsU0FBU0YsU0FBUyxDQUFDRCxFQUFFO1lBRXpCLElBQUssSUFBSUksT0FBT0QsT0FBUTtnQkFDdEIsSUFBSU4sT0FBT1EsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osUUFBUUMsTUFBTTtvQkFDckRMLE1BQU0sQ0FBQ0ssSUFBSSxHQUFHRCxNQUFNLENBQUNDLElBQUk7Z0JBQzNCO1lBQ0Y7UUFDRjtRQUVBLE9BQU9MO0lBQ1Q7SUFFQSxPQUFPSCxTQUFTWSxLQUFLLENBQUMsSUFBSSxFQUFFUDtBQUM5QjtBQUVBLFNBQVNRLGVBQWVDLFFBQVEsRUFBRUMsVUFBVTtJQUMxQ0QsU0FBU0wsU0FBUyxHQUFHUixPQUFPZSxNQUFNLENBQUNELFdBQVdOLFNBQVM7SUFDdkRLLFNBQVNMLFNBQVMsQ0FBQ1EsV0FBVyxHQUFHSDtJQUNqQ0EsU0FBU0ksU0FBUyxHQUFHSDtBQUN2QjtBQUVBLFNBQVNJLDhCQUE4QlosTUFBTSxFQUFFYSxRQUFRO0lBQ3JELElBQUliLFVBQVUsTUFBTSxPQUFPLENBQUM7SUFDNUIsSUFBSUosU0FBUyxDQUFDO0lBQ2QsSUFBSWtCLGFBQWFwQixPQUFPcUIsSUFBSSxDQUFDZjtJQUM3QixJQUFJQyxLQUFLSjtJQUVULElBQUtBLElBQUksR0FBR0EsSUFBSWlCLFdBQVdmLE1BQU0sRUFBRUYsSUFBSztRQUN0Q0ksTUFBTWEsVUFBVSxD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TzRJO1FBQ2hCO1FBRUEsSUFBSXRXLFdBQVdhLFdBQVc7WUFDeEIsT0FBT0EsU0FBU3lWO1FBQ2xCO1FBRUEsSUFBSTdJLFdBQVc7WUFDYixtRUFBbUU7WUFDbkUsSUFBSSxPQUFPQSxjQUFjLFVBQVU7Z0JBQ2pDLElBQUlFLFdBQVdoSixNQUFNZ0osUUFBUSxFQUN6QmpKLE9BQU9oRyw4QkFBOEJpRyxPQUFPO29CQUFDO2lCQUFXO2dCQUU1RCxxQkFBTzdILG9EQUFhQSxDQUFDMlEsV0FBV2xRLFNBQVM7b0JBQ3ZDeVMsS0FBS3JDO2dCQUNQLEdBQUdqSyxPQUFPZ0IsT0FBTzdEO1lBQ25CLEVBQUUsNENBQTRDO1lBRzlDLHFCQUFPL0Qsb0RBQWFBLENBQUMyUSxXQUFXbFEsU0FBUztnQkFDdkNtRyxPQUFPQTtnQkFDUG9OLE1BQU1wUjtZQUNSLEdBQUdpRixRQUFROUQ7UUFDYixFQUFFLDJFQUEyRTtRQUc3RSxJQUFJa1EsWUFBWTdELE1BQU07UUFFdEIsSUFBSSxPQUFPNkQsY0FBYyxVQUFVO1lBQ2pDLElBQUlDLFlBQVlyTSxNQUFNZ0osUUFBUSxFQUMxQnNELFFBQVF2Uyw4QkFBOEJpRyxPQUFPO2dCQUFDO2FBQVc7WUFFN0QscUJBQU83SCxvREFBYUEsQ0FBQ2lVLFdBQVd4VCxTQUFTO2dCQUN2Q3lTLEtBQUtnQjtZQUNQLEdBQUd0TixPQUFPdU4sUUFBUXBRO1FBQ3BCO1FBRUEscUJBQU8vRCxvREFBYUEsQ0FBQ2lVLFdBQVd4VCxTQUFTLENBQUMsR0FBR21HLE9BQU9pQixRQUFROUQ7SUFDOUQ7SUFFQSxPQUFPcVY7QUFDVCxFQUFFalosNENBQVNBO0FBRVgsSUFBSXNaLFlBQVksV0FBVyxHQUFFaEUsUUFBUTJEO0FBRWlaLENBQ3RiLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Z1c2lvbi1jbHViLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZm9ybWlrL2Rpc3QvZm9ybWlrLmVzbS5qcz8zMzAwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkZWVwbWVyZ2UgZnJvbSAnZGVlcG1lcmdlJztcclxuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QnO1xyXG5pbXBvcnQgY2xvbmVEZWVwIGZyb20gJ2xvZGFzaC1lcy9jbG9uZURlZXAnO1xyXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCBDaGlsZHJlbiwgdXNlUmVmLCB1c2VFZmZlY3QsIHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgdXNlTWVtbywgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgY3JlYXRlRWxlbWVudCwgdXNlTGF5b3V0RWZmZWN0LCBmb3J3YXJkUmVmLCBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBpc0VxdWFsIGZyb20gJ3JlYWN0LWZhc3QtY29tcGFyZSc7XHJcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAndGlueS13YXJuaW5nJztcclxuaW1wb3J0IGNsb25lIGZyb20gJ2xvZGFzaC1lcy9jbG9uZSc7XHJcbmltcG9ydCB0b1BhdGggZnJvbSAnbG9kYXNoLWVzL3RvUGF0aCc7XHJcbmltcG9ydCBob2lzdE5vblJlYWN0U3RhdGljcyBmcm9tICdob2lzdC1ub24tcmVhY3Qtc3RhdGljcyc7XHJcblxyXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcclxuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcclxuXHJcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcclxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xyXG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xyXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xyXG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xyXG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcclxuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcclxuICB2YXIgdGFyZ2V0ID0ge307XHJcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xyXG4gIHZhciBrZXksIGk7XHJcblxyXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xyXG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcclxuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGFyZ2V0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcclxuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XHJcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc2VsZjtcclxufVxyXG5cclxudmFyIEZvcm1pa0NvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xyXG5Gb3JtaWtDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0Zvcm1pa0NvbnRleHQnO1xyXG52YXIgRm9ybWlrUHJvdmlkZXIgPSBGb3JtaWtDb250ZXh0LlByb3ZpZGVyO1xyXG52YXIgRm9ybWlrQ29uc3VtZXIgPSBGb3JtaWtDb250ZXh0LkNvbnN1bWVyO1xyXG5mdW5jdGlvbiB1c2VGb3JtaWtDb250ZXh0KCkge1xyXG4gIHZhciBmb3JtaWsgPSB1c2VDb250ZXh0KEZvcm1pa0NvbnRleHQpO1xyXG4gICEhIWZvcm1payA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJGb3JtaWsgY29udGV4dCBpcyB1bmRlZmluZWQsIHBsZWFzZSB2ZXJpZnkgeW91IGFyZSBjYWxsaW5nIHVzZUZvcm1pa0NvbnRleHQoKSBhcyBjaGlsZCBvZiBhIDxGb3JtaWs+IGNvbXBvbmVudC5cIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xyXG4gIHJldHVybiBmb3JtaWs7XHJcbn1cclxuXHJcbi8qKiBAcHJpdmF0ZSBpcyB0aGUgdmFsdWUgYW4gZW1wdHkgYXJyYXk/ICovXHJcblxyXG52YXIgaXNFbXB0eUFycmF5ID0gZnVuY3Rpb24gaXNFbXB0eUFycmF5KHZhbHVlKSB7XHJcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMDtcclxufTtcclxuLyoqIEBwcml2YXRlIGlzIHRoZSBnaXZlbiBvYmplY3QgYSBGdW5jdGlvbj8gKi9cclxuXHJcbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcclxuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJztcclxufTtcclxuLyoqIEBwcml2YXRlIGlzIHRoZSBnaXZlbiBvYmplY3QgYW4gT2JqZWN0PyAqL1xyXG5cclxudmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XHJcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JztcclxufTtcclxuLyoqIEBwcml2YXRlIGlzIHRoZSBnaXZlbiBvYmplY3QgYW4gaW50ZWdlcj8gKi9cclxuXHJcbnZhciBpc0ludGVnZXIgPSBmdW5jdGlvbiBpc0ludGVnZXIob2JqKSB7XHJcbiAgcmV0dXJuIFN0cmluZyhNYXRoLmZsb29yKE51bWJlcihvYmopKSkgPT09IG9iajtcclxufTtcclxuLyoqIEBwcml2YXRlIGlzIHRoZSBnaXZlbiBvYmplY3QgYSBzdHJpbmc/ICovXHJcblxyXG52YXIgaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcclxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xyXG59O1xyXG4vKiogQHByaXZhdGUgaXMgdGhlIGdpdmVuIG9iamVjdCBhIE5hTj8gKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxyXG5cclxudmFyIGlzTmFOJDEgPSBmdW5jdGlvbiBpc05hTihvYmopIHtcclxuICByZXR1cm4gb2JqICE9PSBvYmo7XHJcbn07XHJcbi8qKiBAcHJpdmF0ZSBEb2VzIGEgUmVhY3QgY29tcG9uZW50IGhhdmUgZXhhY3RseSAwIGNoaWxkcmVuPyAqL1xyXG5cclxudmFyIGlzRW1wdHlDaGlsZHJlbiA9IGZ1bmN0aW9uIGlzRW1wdHlDaGlsZHJlbihjaGlsZHJlbikge1xyXG4gIHJldHVybiBDaGlsZHJlbi5jb3VudChjaGlsZHJlbikgPT09IDA7XHJcbn07XHJcbi8qKiBAcHJpdmF0ZSBpcyB0aGUgZ2l2ZW4gb2JqZWN0L3ZhbHVlIGEgcHJvbWlzZT8gKi9cclxuXHJcbnZhciBpc1Byb21pc2UgPSBmdW5jdGlvbiBpc1Byb21pc2UodmFsdWUpIHtcclxuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGlzRnVuY3Rpb24odmFsdWUudGhlbik7XHJcbn07XHJcbi8qKiBAcHJpdmF0ZSBpcyB0aGUgZ2l2ZW4gb2JqZWN0L3ZhbHVlIGEgdHlwZSBvZiBzeW50aGV0aWMgZXZlbnQ/ICovXHJcblxyXG52YXIgaXNJbnB1dEV2ZW50ID0gZnVuY3Rpb24gaXNJbnB1dEV2ZW50KHZhbHVlKSB7XHJcbiAgcmV0dXJuIHZhbHVlICYmIGlzT2JqZWN0KHZhbHVlKSAmJiBpc09iamVjdCh2YWx1ZS50YXJnZXQpO1xyXG59O1xyXG4vKipcclxuICogU2FtZSBhcyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGJ1dCB3cmFwcyBpbiBhIHRyeS1jYXRjaCBibG9jay4gSW4gSUUgaXQgaXNcclxuICogbm90IHNhZmUgdG8gY2FsbCBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGlmIHRoZXJlIGlzIG5vdGhpbmcgZm9jdXNlZC5cclxuICpcclxuICogVGhlIGFjdGl2ZUVsZW1lbnQgd2lsbCBiZSBudWxsIG9ubHkgaWYgdGhlIGRvY3VtZW50IG9yIGRvY3VtZW50IGJvZHkgaXMgbm90XHJcbiAqIHlldCBkZWZpbmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gez9Eb2N1bWVudH0gZG9jIERlZmF1bHRzIHRvIGN1cnJlbnQgZG9jdW1lbnQuXHJcbiAqIEByZXR1cm4ge0VsZW1lbnQgfCBudWxsfVxyXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL2ZianMvc3JjL2NvcmUvZG9tL2dldEFjdGl2ZUVsZW1lbnQuanNcclxuICovXHJcblxyXG5mdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50KGRvYykge1xyXG4gIGRvYyA9IGRvYyB8fCAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogdW5kZWZpbmVkKTtcclxuXHJcbiAgaWYgKHR5cGVvZiBkb2MgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gZG9jLmFjdGl2ZUVsZW1lbnQgfHwgZG9jLmJvZHk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgcmV0dXJuIGRvYy5ib2R5O1xyXG4gIH1cclxufVxyXG4vKipcclxuICogRGVlcGx5IGdldCBhIHZhbHVlIGZyb20gYW4gb2JqZWN0IHZpYSBpdHMgcGF0aC5cclxuICovXHJcblxyXG5mdW5jdGlvbiBnZXRJbihvYmosIGtleSwgZGVmLCBwKSB7XHJcbiAgaWYgKHAgPT09IHZvaWQgMCkge1xyXG4gICAgcCA9IDA7XHJcbiAgfVxyXG5cclxuICB2YXIgcGF0aCA9IHRvUGF0aChrZXkpO1xyXG5cclxuICB3aGlsZSAob2JqICYmIHAgPCBwYXRoLmxlbmd0aCkge1xyXG4gICAgb2JqID0gb2JqW3BhdGhbcCsrXV07XHJcbiAgfSAvLyBjaGVjayBpZiBwYXRoIGlzIG5vdCBpbiB0aGUgZW5kXHJcblxyXG5cclxuICBpZiAocCAhPT0gcGF0aC5sZW5ndGggJiYgIW9iaikge1xyXG4gICAgcmV0dXJuIGRlZjtcclxuICB9XHJcblxyXG4gIHJldHVybiBvYmogPT09IHVuZGVmaW5lZCA/IGRlZiA6IG9iajtcclxufVxyXG4vKipcclxuICogRGVlcGx5IHNldCBhIHZhbHVlIGZyb20gaW4gb2JqZWN0IHZpYSBpdCdzIHBhdGguIElmIHRoZSB2YWx1ZSBhdCBgcGF0aGBcclxuICogaGFzIGNoYW5nZWQsIHJldHVybiBhIHNoYWxsb3cgY29weSBvZiBvYmogd2l0aCBgdmFsdWVgIHNldCBhdCBgcGF0aGAuXHJcbiAqIElmIGB2YWx1ZWAgaGFzIG5vdCBjaGFuZ2VkLCByZXR1cm4gdGhlIG9yaWdpbmFsIGBvYmpgLlxyXG4gKlxyXG4gKiBFeGlzdGluZyBvYmplY3RzIC8gYXJyYXlzIGFsb25nIGBwYXRoYCBhcmUgYWxzbyBzaGFsbG93IGNvcGllZC4gU2libGluZ1xyXG4gKiBvYmplY3RzIGFsb25nIHBhdGggcmV0YWluIHRoZSBzYW1lIGludGVybmFsIGpzIHJlZmVyZW5jZS4gU2luY2UgbmV3XHJcbiAqIG9iamVjdHMgLyBhcnJheXMgYXJlIG9ubHkgY3JlYXRlZCBhbG9uZyBgcGF0aGAsIHdlIGNhbiB0ZXN0IGlmIGFueXRoaW5nXHJcbiAqIGNoYW5nZWQgaW4gYSBuZXN0ZWQgc3RydWN0dXJlIGJ5IGNvbXBhcmluZyB0aGUgb2JqZWN0J3MgcmVmZXJlbmNlIGluXHJcbiAqIHRoZSBvbGQgYW5kIG5ldyBvYmplY3QsIHNpbWlsYXIgdG8gaG93IHJ1c3NpYW4gZG9sbCBjYWNoZSBpbnZhbGlkYXRpb25cclxuICogd29ya3MuXHJcbiAqXHJcbiAqIEluIGVhcmxpZXIgdmVyc2lvbnMgb2YgdGhpcyBmdW5jdGlvbiwgd2hpY2ggdXNlZCBjbG9uZURlZXAsIHRoZXJlIHdlcmVcclxuICogaXNzdWVzIHdoZXJlYnkgc2V0dGluZ3MgYSBuZXN0ZWQgdmFsdWUgd291bGQgbXV0YXRlIHRoZSBwYXJlbnRcclxuICogaW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyBvYmplY3QuIGBjbG9uZWAgYXZvaWRzIHRoYXQgYnVnIG1ha2luZyBhXHJcbiAqIHNoYWxsb3cgY29weSBvZiB0aGUgb2JqZWN0cyBhbG9uZyB0aGUgdXBkYXRlIHBhdGhcclxuICogc28gbm8gb2JqZWN0IGlzIG11dGF0ZWQgaW4gcGxhY2UuXHJcbiAqXHJcbiAqIEJlZm9yZSBjaGFuZ2luZyB0aGlzIGZ1bmN0aW9uLCBwbGVhc2UgcmVhZCB0aHJvdWdoIHRoZSBmb2xsb3dpbmdcclxuICogZGlzY3Vzc2lvbnMuXHJcbiAqXHJcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2RldmVsb3BpdC9saW5rc3RhdGVcclxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vamFyZWRwYWxtZXIvZm9ybWlrL3B1bGwvMTIzXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gc2V0SW4ob2JqLCBwYXRoLCB2YWx1ZSkge1xyXG4gIHZhciByZXMgPSBjbG9uZShvYmopOyAvLyB0aGlzIGtlZXBzIGluaGVyaXRhbmNlIHdoZW4gb2JqIGlzIGEgY2xhc3NcclxuXHJcbiAgdmFyIHJlc1ZhbCA9IHJlcztcclxuICB2YXIgaSA9IDA7XHJcbiAgdmFyIHBhdGhBcnJheSA9IHRvUGF0aChwYXRoKTtcclxuXHJcbiAgZm9yICg7IGkgPCBwYXRoQXJyYXkubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICB2YXIgY3VycmVudFBhdGggPSBwYXRoQXJyYXlbaV07XHJcbiAgICB2YXIgY3VycmVudE9iaiA9IGdldEluKG9iaiwgcGF0aEFycmF5LnNsaWNlKDAsIGkgKyAxKSk7XHJcblxyXG4gICAgaWYgKGN1cnJlbnRPYmogJiYgKGlzT2JqZWN0KGN1cnJlbnRPYmopIHx8IEFycmF5LmlzQXJyYXkoY3VycmVudE9iaikpKSB7XHJcbiAgICAgIHJlc1ZhbCA9IHJlc1ZhbFtjdXJyZW50UGF0aF0gPSBjbG9uZShjdXJyZW50T2JqKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBuZXh0UGF0aCA9IHBhdGhBcnJheVtpICsgMV07XHJcbiAgICAgIHJlc1ZhbCA9IHJlc1ZhbFtjdXJyZW50UGF0aF0gPSBpc0ludGVnZXIobmV4dFBhdGgpICYmIE51bWJlcihuZXh0UGF0aCkgPj0gMCA/IFtdIDoge307XHJcbiAgICB9XHJcbiAgfSAvLyBSZXR1cm4gb3JpZ2luYWwgb2JqZWN0IGlmIG5ldyB2YWx1ZSBpcyB0aGUgc2FtZSBhcyBjdXJyZW50XHJcblxyXG5cclxuICBpZiAoKGkgPT09IDAgPyBvYmogOiByZXNWYWwpW3BhdGhBcnJheVtpXV0gPT09IHZhbHVlKSB7XHJcbiAgICByZXR1cm4gb2JqO1xyXG4gIH1cclxuXHJcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgIGRlbGV0ZSByZXNWYWxbcGF0aEFycmF5W2ldXTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmVzVmFsW3BhdGhBcnJheVtpXV0gPSB2YWx1ZTtcclxuICB9IC8vIElmIHRoZSBwYXRoIGFycmF5IGhhcyBhIHNpbmdsZSBlbGVtZW50LCB0aGUgbG9vcCBkaWQgbm90IHJ1bi5cclxuICAvLyBEZWxldGluZyBvbiBgcmVzVmFsYCBoYWQgbm8gZWZmZWN0IGluIHRoaXMgc2NlbmFyaW8sIHNvIHdlIGRlbGV0ZSBvbiB0aGUgcmVzdWx0IGluc3RlYWQuXHJcblxyXG5cclxuICBpZiAoaSA9PT0gMCAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICBkZWxldGUgcmVzW3BhdGhBcnJheVtpXV07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzO1xyXG59XHJcbi8qKlxyXG4gKiBSZWN1cnNpdmVseSBhIHNldCB0aGUgc2FtZSB2YWx1ZSBmb3IgYWxsIGtleXMgYW5kIGFycmF5cyBuZXN0ZWQgb2JqZWN0LCBjbG9uaW5nXHJcbiAqIEBwYXJhbSBvYmplY3RcclxuICogQHBhcmFtIHZhbHVlXHJcbiAqIEBwYXJhbSB2aXNpdGVkXHJcbiAqIEBwYXJhbSByZXNwb25zZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHNldE5lc3RlZE9iamVjdFZhbHVlcyhvYmplY3QsIHZhbHVlLCB2aXNpdGVkLCByZXNwb25zZSkge1xyXG4gIGlmICh2aXNpdGVkID09PSB2b2lkIDApIHtcclxuICAgIHZpc2l0ZWQgPSBuZXcgV2Vha01hcCgpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHJlc3BvbnNlID09PSB2b2lkIDApIHtcclxuICAgIHJlc3BvbnNlID0ge307XHJcbiAgfVxyXG5cclxuICBmb3IgKHZhciBfaSA9IDAsIF9PYmplY3Qka2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IF9pIDwgX09iamVjdCRrZXlzLmxlbmd0aDsgX2krKykge1xyXG4gICAgdmFyIGsgPSBfT2JqZWN0JGtleXNbX2ldO1xyXG4gICAgdmFyIHZhbCA9IG9iamVjdFtrXTtcclxuXHJcbiAgICBpZiAoaXNPYmplY3QodmFsKSkge1xyXG4gICAgICBpZiAoIXZpc2l0ZWQuZ2V0KHZhbCkpIHtcclxuICAgICAgICB2aXNpdGVkLnNldCh2YWwsIHRydWUpOyAvLyBJbiBvcmRlciB0byBrZWVwIGFycmF5IHZhbHVlcyBjb25zaXN0ZW50IGZvciBib3RoIGRvdCBwYXRoICBhbmRcclxuICAgICAgICAvLyBicmFja2V0IHN5bnRheCwgd2UgbmVlZCB0byBjaGVjayBpZiB0aGlzIGlzIGFuIGFycmF5IHNvIHRoYXRcclxuICAgICAgICAvLyB0aGlzIHdpbGwgb3V0cHV0ICB7IGZyaWVuZHM6IFt0cnVlXSB9IGFuZCBub3QgeyBmcmllbmRzOiB7IFwiMFwiOiB0cnVlIH0gfVxyXG5cclxuICAgICAgICByZXNwb25zZVtrXSA9IEFycmF5LmlzQXJyYXkodmFsKSA/IFtdIDoge307XHJcbiAgICAgICAgc2V0TmVzdGVkT2JqZWN0VmFsdWVzKHZhbCwgdmFsdWUsIHZpc2l0ZWQsIHJlc3BvbnNlW2tdKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmVzcG9uc2Vba10gPSB2YWx1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiByZXNwb25zZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZm9ybWlrUmVkdWNlcihzdGF0ZSwgbXNnKSB7XHJcbiAgc3dpdGNoIChtc2cudHlwZSkge1xyXG4gICAgY2FzZSAnU0VUX1ZBTFVFUyc6XHJcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcclxuICAgICAgICB2YWx1ZXM6IG1zZy5wYXlsb2FkXHJcbiAgICAgIH0pO1xyXG5cclxuICAgIGNhc2UgJ1NFVF9UT1VDSEVEJzpcclxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xyXG4gICAgICAgIHRvdWNoZWQ6IG1zZy5wYXlsb2FkXHJcbiAgICAgIH0pO1xyXG5cclxuICAgIGNhc2UgJ1NFVF9FUlJPUlMnOlxyXG4gICAgICBpZiAoaXNFcXVhbChzdGF0ZS5lcnJvcnMsIG1zZy5wYXlsb2FkKSkge1xyXG4gICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xyXG4gICAgICAgIGVycm9yczogbXNnLnBheWxvYWRcclxuICAgICAgfSk7XHJcblxyXG4gICAgY2FzZSAnU0VUX1NUQVRVUyc6XHJcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcclxuICAgICAgICBzdGF0dXM6IG1zZy5wYXlsb2FkXHJcbiAgICAgIH0pO1xyXG5cclxuICAgIGNhc2UgJ1NFVF9JU1NVQk1JVFRJTkcnOlxyXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XHJcbiAgICAgICAgaXNTdWJtaXR0aW5nOiBtc2cucGF5bG9hZFxyXG4gICAgICB9KTtcclxuXHJcbiAgICBjYXNlICdTRVRfSVNWQUxJREFUSU5HJzpcclxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xyXG4gICAgICAgIGlzVmFsaWRhdGluZzogbXNnLnBheWxvYWRcclxuICAgICAgfSk7XHJcblxyXG4gICAgY2FzZSAnU0VUX0ZJRUxEX1ZBTFVFJzpcclxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xyXG4gICAgICAgIHZhbHVlczogc2V0SW4oc3RhdGUudmFsdWVzLCBtc2cucGF5bG9hZC5maWVsZCwgbXNnLnBheWxvYWQudmFsdWUpXHJcbiAgICAgIH0pO1xyXG5cclxuICAgIGNhc2UgJ1NFVF9GSUVMRF9UT1VDSEVEJzpcclxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xyXG4gICAgICAgIHRvdWNoZWQ6IHNldEluKHN0YXRlLnRvdWNoZWQsIG1zZy5wYXlsb2FkLmZpZWxkLCBtc2cucGF5bG9hZC52YWx1ZSlcclxuICAgICAgfSk7XHJcblxyXG4gICAgY2FzZSAnU0VUX0ZJRUxEX0VSUk9SJzpcclxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xyXG4gICAgICAgIGVycm9yczogc2V0SW4oc3RhdGUuZXJyb3JzLCBtc2cucGF5bG9hZC5maWVsZCwgbXNnLnBheWxvYWQudmFsdWUpXHJcbiAgICAgIH0pO1xyXG5cclxuICAgIGNhc2UgJ1JFU0VUX0ZPUk0nOlxyXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCBtc2cucGF5bG9hZCk7XHJcblxyXG4gICAgY2FzZSAnU0VUX0ZPUk1JS19TVEFURSc6XHJcbiAgICAgIHJldHVybiBtc2cucGF5bG9hZChzdGF0ZSk7XHJcblxyXG4gICAgY2FzZSAnU1VCTUlUX0FUVEVNUFQnOlxyXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XHJcbiAgICAgICAgdG91Y2hlZDogc2V0TmVzdGVkT2JqZWN0VmFsdWVzKHN0YXRlLnZhbHVlcywgdHJ1ZSksXHJcbiAgICAgICAgaXNTdWJtaXR0aW5nOiB0cnVlLFxyXG4gICAgICAgIHN1Ym1pdENvdW50OiBzdGF0ZS5zdWJtaXRDb3VudCArIDFcclxuICAgICAgfSk7XHJcblxyXG4gICAgY2FzZSAnU1VCTUlUX0ZBSUxVUkUnOlxyXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XHJcbiAgICAgICAgaXNTdWJtaXR0aW5nOiBmYWxzZVxyXG4gICAgICB9KTtcclxuXHJcbiAgICBjYXNlICdTVUJNSVRfU1VDQ0VTUyc6XHJcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcclxuICAgICAgICBpc1N1Ym1pdHRpbmc6IGZhbHNlXHJcbiAgICAgIH0pO1xyXG5cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiBzdGF0ZTtcclxuICB9XHJcbn0gLy8gSW5pdGlhbCBlbXB0eSBzdGF0ZXMgLy8gb2JqZWN0c1xyXG5cclxuXHJcbnZhciBlbXB0eUVycm9ycyA9IHt9O1xyXG52YXIgZW1wdHlUb3VjaGVkID0ge307XHJcbmZ1bmN0aW9uIHVzZUZvcm1payhfcmVmKSB7XHJcbiAgdmFyIF9yZWYkdmFsaWRhdGVPbkNoYW5nZSA9IF9yZWYudmFsaWRhdGVPbkNoYW5nZSxcclxuICAgICAgdmFsaWRhdGVPbkNoYW5nZSA9IF9yZWYkdmFsaWRhdGVPbkNoYW5nZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYkdmFsaWRhdGVPbkNoYW5nZSxcclxuICAgICAgX3JlZiR2YWxpZGF0ZU9uQmx1ciA9IF9yZWYudmFsaWRhdGVPbkJsdXIsXHJcbiAgICAgIHZhbGlkYXRlT25CbHVyID0gX3JlZiR2YWxpZGF0ZU9uQmx1ciA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYkdmFsaWRhdGVPbkJsdXIsXHJcbiAgICAgIF9yZWYkdmFsaWRhdGVPbk1vdW50ID0gX3JlZi52YWxpZGF0ZU9uTW91bnQsXHJcbiAgICAgIHZhbGlkYXRlT25Nb3VudCA9IF9yZWYkdmFsaWRhdGVPbk1vdW50ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkdmFsaWRhdGVPbk1vdW50LFxyXG4gICAgICBpc0luaXRpYWxWYWxpZCA9IF9yZWYuaXNJbml0aWFsVmFsaWQsXHJcbiAgICAgIF9yZWYkZW5hYmxlUmVpbml0aWFsaSA9IF9yZWYuZW5hYmxlUmVpbml0aWFsaXplLFxyXG4gICAgICBlbmFibGVSZWluaXRpYWxpemUgPSBfcmVmJGVuYWJsZVJlaW5pdGlhbGkgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRlbmFibGVSZWluaXRpYWxpLFxyXG4gICAgICBvblN1Ym1pdCA9IF9yZWYub25TdWJtaXQsXHJcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBbXCJ2YWxpZGF0ZU9uQ2hhbmdlXCIsIFwidmFsaWRhdGVPbkJsdXJcIiwgXCJ2YWxpZGF0ZU9uTW91bnRcIiwgXCJpc0luaXRpYWxWYWxpZFwiLCBcImVuYWJsZVJlaW5pdGlhbGl6ZVwiLCBcIm9uU3VibWl0XCJdKTtcclxuXHJcbiAgdmFyIHByb3BzID0gX2V4dGVuZHMoe1xyXG4gICAgdmFsaWRhdGVPbkNoYW5nZTogdmFsaWRhdGVPbkNoYW5nZSxcclxuICAgIHZhbGlkYXRlT25CbHVyOiB2YWxpZGF0ZU9uQmx1cixcclxuICAgIHZhbGlkYXRlT25Nb3VudDogdmFsaWRhdGVPbk1vdW50LFxyXG4gICAgb25TdWJtaXQ6IG9uU3VibWl0XHJcbiAgfSwgcmVzdCk7XHJcblxyXG4gIHZhciBpbml0aWFsVmFsdWVzID0gdXNlUmVmKHByb3BzLmluaXRpYWxWYWx1ZXMpO1xyXG4gIHZhciBpbml0aWFsRXJyb3JzID0gdXNlUmVmKHByb3BzLmluaXRpYWxFcnJvcnMgfHwgZW1wdHlFcnJvcnMpO1xyXG4gIHZhciBpbml0aWFsVG91Y2hlZCA9IHVzZVJlZihwcm9wcy5pbml0aWFsVG91Y2hlZCB8fCBlbXB0eVRvdWNoZWQpO1xyXG4gIHZhciBpbml0aWFsU3RhdHVzID0gdXNlUmVmKHByb3BzLmluaXRpYWxTdGF0dXMpO1xyXG4gIHZhciBpc01vdW50ZWQgPSB1c2VSZWYoZmFsc2UpO1xyXG4gIHZhciBmaWVsZFJlZ2lzdHJ5ID0gdXNlUmVmKHt9KTtcclxuXHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXHJcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAhKHR5cGVvZiBpc0luaXRpYWxWYWxpZCA9PT0gJ3VuZGVmaW5lZCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnaXNJbml0aWFsVmFsaWQgaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBGb3JtaWsuIFBsZWFzZSB1c2UgaW5pdGlhbEVycm9ycyBvciB2YWxpZGF0ZU9uTW91bnQgaW5zdGVhZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG4gICAgfSwgW10pO1xyXG4gIH1cclxuXHJcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgIGlzTW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gIH0sIFtdKTtcclxuXHJcbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IHVzZVN0YXRlKDApLFxyXG4gICAgICBzZXRJdGVyYXRpb24gPSBfUmVhY3QkdXNlU3RhdGVbMV07XHJcblxyXG4gIHZhciBzdGF0ZVJlZiA9IHVzZVJlZih7XHJcbiAgICB2YWx1ZXM6IGNsb25lRGVlcChwcm9wcy5pbml0aWFsVmFsdWVzKSxcclxuICAgIGVycm9yczogY2xvbmVEZWVwKHByb3BzLmluaXRpYWxFcnJvcnMpIHx8IGVtcHR5RXJyb3JzLFxyXG4gICAgdG91Y2hlZDogY2xvbmVEZWVwKHByb3BzLmluaXRpYWxUb3VjaGVkKSB8fCBlbXB0eVRvdWNoZWQsXHJcbiAgICBzdGF0dXM6IGNsb25lRGVlcChwcm9wcy5pbml0aWFsU3RhdHVzKSxcclxuICAgIGlzU3VibWl0dGluZzogZmFsc2UsXHJcbiAgICBpc1ZhbGlkYXRpbmc6IGZhbHNlLFxyXG4gICAgc3VibWl0Q291bnQ6IDBcclxuICB9KTtcclxuICB2YXIgc3RhdGUgPSBzdGF0ZVJlZi5jdXJyZW50O1xyXG4gIHZhciBkaXNwYXRjaCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgIHZhciBwcmV2ID0gc3RhdGVSZWYuY3VycmVudDtcclxuICAgIHN0YXRlUmVmLmN1cnJlbnQgPSBmb3JtaWtSZWR1Y2VyKHByZXYsIGFjdGlvbik7IC8vIGZvcmNlIHJlcmVuZGVyXHJcblxyXG4gICAgaWYgKHByZXYgIT09IHN0YXRlUmVmLmN1cnJlbnQpIHNldEl0ZXJhdGlvbihmdW5jdGlvbiAoeCkge1xyXG4gICAgICByZXR1cm4geCArIDE7XHJcbiAgICB9KTtcclxuICB9LCBbXSk7XHJcbiAgdmFyIHJ1blZhbGlkYXRlSGFuZGxlciA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICh2YWx1ZXMsIGZpZWxkKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICB2YXIgbWF5YmVQcm9taXNlZEVycm9ycyA9IHByb3BzLnZhbGlkYXRlKHZhbHVlcywgZmllbGQpO1xyXG5cclxuICAgICAgaWYgKG1heWJlUHJvbWlzZWRFcnJvcnMgPT0gbnVsbCkge1xyXG4gICAgICAgIC8vIHVzZSBsb29zZSBudWxsIGNoZWNrIGhlcmUgb24gcHVycG9zZVxyXG4gICAgICAgIHJlc29sdmUoZW1wdHlFcnJvcnMpO1xyXG4gICAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZShtYXliZVByb21pc2VkRXJyb3JzKSkge1xyXG4gICAgICAgIG1heWJlUHJvbWlzZWRFcnJvcnMudGhlbihmdW5jdGlvbiAoZXJyb3JzKSB7XHJcbiAgICAgICAgICByZXNvbHZlKGVycm9ycyB8fCBlbXB0eUVycm9ycyk7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKGFjdHVhbEV4Y2VwdGlvbikge1xyXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiV2FybmluZzogQW4gdW5oYW5kbGVkIGVycm9yIHdhcyBjYXVnaHQgZHVyaW5nIHZhbGlkYXRpb24gaW4gPEZvcm1payB2YWxpZGF0ZSAvPlwiLCBhY3R1YWxFeGNlcHRpb24pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJlamVjdChhY3R1YWxFeGNlcHRpb24pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlc29sdmUobWF5YmVQcm9taXNlZEVycm9ycyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0sIFtwcm9wcy52YWxpZGF0ZV0pO1xyXG4gIC8qKlxyXG4gICAqIFJ1biB2YWxpZGF0aW9uIGFnYWluc3QgYSBZdXAgc2NoZW1hIGFuZCBvcHRpb25hbGx5IHJ1biBhIGZ1bmN0aW9uIGlmIHN1Y2Nlc3NmdWxcclxuICAgKi9cclxuXHJcbiAgdmFyIHJ1blZhbGlkYXRpb25TY2hlbWEgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAodmFsdWVzLCBmaWVsZCkge1xyXG4gICAgdmFyIHZhbGlkYXRpb25TY2hlbWEgPSBwcm9wcy52YWxpZGF0aW9uU2NoZW1hO1xyXG4gICAgdmFyIHNjaGVtYSA9IGlzRnVuY3Rpb24odmFsaWRhdGlvblNjaGVtYSkgPyB2YWxpZGF0aW9uU2NoZW1hKGZpZWxkKSA6IHZhbGlkYXRpb25TY2hlbWE7XHJcbiAgICB2YXIgcHJvbWlzZSA9IGZpZWxkICYmIHNjaGVtYS52YWxpZGF0ZUF0ID8gc2NoZW1hLnZhbGlkYXRlQXQoZmllbGQsIHZhbHVlcykgOiB2YWxpZGF0ZVl1cFNjaGVtYSh2YWx1ZXMsIHNjaGVtYSk7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJlc29sdmUoZW1wdHlFcnJvcnMpO1xyXG4gICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgLy8gWXVwIHdpbGwgdGhyb3cgYSB2YWxpZGF0aW9uIGVycm9yIGlmIHZhbGlkYXRpb24gZmFpbHMuIFdlIGNhdGNoIHRob3NlIGFuZFxyXG4gICAgICAgIC8vIHJlc29sdmUgdGhlbSBpbnRvIEZvcm1payBlcnJvcnMuIFdlIGNhbiBzbmlmZiBpZiBzb21ldGhpbmcgaXMgYSBZdXAgZXJyb3JcclxuICAgICAgICAvLyBieSBjaGVja2luZyBlcnJvci5uYW1lLlxyXG4gICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVuc2UveXVwI3ZhbGlkYXRpb25lcnJvcmVycm9ycy1zdHJpbmctLWFycmF5c3RyaW5nLXZhbHVlLWFueS1wYXRoLXN0cmluZ1xyXG4gICAgICAgIGlmIChlcnIubmFtZSA9PT0gJ1ZhbGlkYXRpb25FcnJvcicpIHtcclxuICAgICAgICAgIHJlc29sdmUoeXVwVG9Gb3JtRXJyb3JzKGVycikpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBXZSB0aHJvdyBhbnkgb3RoZXIgZXJyb3JzXHJcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiBBbiB1bmhhbmRsZWQgZXJyb3Igd2FzIGNhdWdodCBkdXJpbmcgdmFsaWRhdGlvbiBpbiA8Rm9ybWlrIHZhbGlkYXRpb25TY2hlbWEgLz5cIiwgZXJyKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfSwgW3Byb3BzLnZhbGlkYXRpb25TY2hlbWFdKTtcclxuICB2YXIgcnVuU2luZ2xlRmllbGRMZXZlbFZhbGlkYXRpb24gPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoZmllbGQsIHZhbHVlKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgcmV0dXJuIHJlc29sdmUoZmllbGRSZWdpc3RyeS5jdXJyZW50W2ZpZWxkXS52YWxpZGF0ZSh2YWx1ZSkpO1xyXG4gICAgfSk7XHJcbiAgfSwgW10pO1xyXG4gIHZhciBydW5GaWVsZExldmVsVmFsaWRhdGlvbnMgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAodmFsdWVzKSB7XHJcbiAgICB2YXIgZmllbGRLZXlzV2l0aFZhbGlkYXRpb24gPSBPYmplY3Qua2V5cyhmaWVsZFJlZ2lzdHJ5LmN1cnJlbnQpLmZpbHRlcihmdW5jdGlvbiAoZikge1xyXG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihmaWVsZFJlZ2lzdHJ5LmN1cnJlbnRbZl0udmFsaWRhdGUpO1xyXG4gICAgfSk7IC8vIENvbnN0cnVjdCBhbiBhcnJheSB3aXRoIGFsbCBvZiB0aGUgZmllbGQgdmFsaWRhdGlvbiBmdW5jdGlvbnNcclxuXHJcbiAgICB2YXIgZmllbGRWYWxpZGF0aW9ucyA9IGZpZWxkS2V5c1dpdGhWYWxpZGF0aW9uLmxlbmd0aCA+IDAgPyBmaWVsZEtleXNXaXRoVmFsaWRhdGlvbi5tYXAoZnVuY3Rpb24gKGYpIHtcclxuICAgICAgcmV0dXJuIHJ1blNpbmdsZUZpZWxkTGV2ZWxWYWxpZGF0aW9uKGYsIGdldEluKHZhbHVlcywgZikpO1xyXG4gICAgfSkgOiBbUHJvbWlzZS5yZXNvbHZlKCdET19OT1RfREVMRVRFX1lPVV9XSUxMX0JFX0ZJUkVEJyldOyAvLyB1c2Ugc3BlY2lhbCBjYXNlIDspXHJcblxyXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGZpZWxkVmFsaWRhdGlvbnMpLnRoZW4oZnVuY3Rpb24gKGZpZWxkRXJyb3JzTGlzdCkge1xyXG4gICAgICByZXR1cm4gZmllbGRFcnJvcnNMaXN0LnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VyciwgaW5kZXgpIHtcclxuICAgICAgICBpZiAoY3VyciA9PT0gJ0RPX05PVF9ERUxFVEVfWU9VX1dJTExfQkVfRklSRUQnKSB7XHJcbiAgICAgICAgICByZXR1cm4gcHJldjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjdXJyKSB7XHJcbiAgICAgICAgICBwcmV2ID0gc2V0SW4ocHJldiwgZmllbGRLZXlzV2l0aFZhbGlkYXRpb25baW5kZXhdLCBjdXJyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwcmV2O1xyXG4gICAgICB9LCB7fSk7XHJcbiAgICB9KTtcclxuICB9LCBbcnVuU2luZ2xlRmllbGRMZXZlbFZhbGlkYXRpb25dKTsgLy8gUnVuIGFsbCB2YWxpZGF0aW9ucyBhbmQgcmV0dXJuIHRoZSByZXN1bHRcclxuXHJcbiAgdmFyIHJ1bkFsbFZhbGlkYXRpb25zID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKHZhbHVlcykge1xyXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtydW5GaWVsZExldmVsVmFsaWRhdGlvbnModmFsdWVzKSwgcHJvcHMudmFsaWRhdGlvblNjaGVtYSA/IHJ1blZhbGlkYXRpb25TY2hlbWEodmFsdWVzKSA6IHt9LCBwcm9wcy52YWxpZGF0ZSA/IHJ1blZhbGlkYXRlSGFuZGxlcih2YWx1ZXMpIDoge31dKS50aGVuKGZ1bmN0aW9uIChfcmVmMikge1xyXG4gICAgICB2YXIgZmllbGRFcnJvcnMgPSBfcmVmMlswXSxcclxuICAgICAgICAgIHNjaGVtYUVycm9ycyA9IF9yZWYyWzFdLFxyXG4gICAgICAgICAgdmFsaWRhdGVFcnJvcnMgPSBfcmVmMlsyXTtcclxuICAgICAgdmFyIGNvbWJpbmVkRXJyb3JzID0gZGVlcG1lcmdlLmFsbChbZmllbGRFcnJvcnMsIHNjaGVtYUVycm9ycywgdmFsaWRhdGVFcnJvcnNdLCB7XHJcbiAgICAgICAgYXJyYXlNZXJnZTogYXJyYXlNZXJnZVxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGNvbWJpbmVkRXJyb3JzO1xyXG4gICAgfSk7XHJcbiAgfSwgW3Byb3BzLnZhbGlkYXRlLCBwcm9wcy52YWxpZGF0aW9uU2NoZW1hLCBydW5GaWVsZExldmVsVmFsaWRhdGlvbnMsIHJ1blZhbGlkYXRlSGFuZGxlciwgcnVuVmFsaWRhdGlvblNjaGVtYV0pOyAvLyBSdW4gYWxsIHZhbGlkYXRpb25zIG1ldGhvZHMgYW5kIHVwZGF0ZSBzdGF0ZSBhY2NvcmRpbmdseVxyXG5cclxuICB2YXIgdmFsaWRhdGVGb3JtV2l0aEhpZ2hQcmlvcml0eSA9IHVzZUV2ZW50Q2FsbGJhY2soZnVuY3Rpb24gKHZhbHVlcykge1xyXG4gICAgaWYgKHZhbHVlcyA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIHZhbHVlcyA9IHN0YXRlLnZhbHVlcztcclxuICAgIH1cclxuXHJcbiAgICBkaXNwYXRjaCh7XHJcbiAgICAgIHR5cGU6ICdTRVRfSVNWQUxJREFUSU5HJyxcclxuICAgICAgcGF5bG9hZDogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcnVuQWxsVmFsaWRhdGlvbnModmFsdWVzKS50aGVuKGZ1bmN0aW9uIChjb21iaW5lZEVycm9ycykge1xyXG4gICAgICBpZiAoISFpc01vdW50ZWQuY3VycmVudCkge1xyXG4gICAgICAgIGRpc3BhdGNoKHtcclxuICAgICAgICAgIHR5cGU6ICdTRVRfSVNWQUxJREFUSU5HJyxcclxuICAgICAgICAgIHBheWxvYWQ6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZGlzcGF0Y2goe1xyXG4gICAgICAgICAgdHlwZTogJ1NFVF9FUlJPUlMnLFxyXG4gICAgICAgICAgcGF5bG9hZDogY29tYmluZWRFcnJvcnNcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGNvbWJpbmVkRXJyb3JzO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh2YWxpZGF0ZU9uTW91bnQgJiYgaXNNb3VudGVkLmN1cnJlbnQgPT09IHRydWUgJiYgaXNFcXVhbChpbml0aWFsVmFsdWVzLmN1cnJlbnQsIHByb3BzLmluaXRpYWxWYWx1ZXMpKSB7XHJcbiAgICAgIHZhbGlkYXRlRm9ybVdpdGhIaWdoUHJpb3JpdHkoaW5pdGlhbFZhbHVlcy5jdXJyZW50KTtcclxuICAgIH1cclxuICB9LCBbdmFsaWRhdGVPbk1vdW50LCB2YWxpZGF0ZUZvcm1XaXRoSGlnaFByaW9yaXR5XSk7XHJcbiAgdmFyIHJlc2V0Rm9ybSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChuZXh0U3RhdGUpIHtcclxuICAgIHZhciB2YWx1ZXMgPSBuZXh0U3RhdGUgJiYgbmV4dFN0YXRlLnZhbHVlcyA/IG5leHRTdGF0ZS52YWx1ZXMgOiBpbml0aWFsVmFsdWVzLmN1cnJlbnQ7XHJcbiAgICB2YXIgZXJyb3JzID0gbmV4dFN0YXRlICYmIG5leHRTdGF0ZS5lcnJvcnMgPyBuZXh0U3RhdGUuZXJyb3JzIDogaW5pdGlhbEVycm9ycy5jdXJyZW50ID8gaW5pdGlhbEVycm9ycy5jdXJyZW50IDogcHJvcHMuaW5pdGlhbEVycm9ycyB8fCB7fTtcclxuICAgIHZhciB0b3VjaGVkID0gbmV4dFN0YXRlICYmIG5leHRTdGF0ZS50b3VjaGVkID8gbmV4dFN0YXRlLnRvdWNoZWQgOiBpbml0aWFsVG91Y2hlZC5jdXJyZW50ID8gaW5pdGlhbFRvdWNoZWQuY3VycmVudCA6IHByb3BzLmluaXRpYWxUb3VjaGVkIHx8IHt9O1xyXG4gICAgdmFyIHN0YXR1cyA9IG5leHRTdGF0ZSAmJiBuZXh0U3RhdGUuc3RhdHVzID8gbmV4dFN0YXRlLnN0YXR1cyA6IGluaXRpYWxTdGF0dXMuY3VycmVudCA/IGluaXRpYWxTdGF0dXMuY3VycmVudCA6IHByb3BzLmluaXRpYWxTdGF0dXM7XHJcbiAgICBpbml0aWFsVmFsdWVzLmN1cnJlbnQgPSB2YWx1ZXM7XHJcbiAgICBpbml0aWFsRXJyb3JzLmN1cnJlbnQgPSBlcnJvcnM7XHJcbiAgICBpbml0aWFsVG91Y2hlZC5jdXJyZW50ID0gdG91Y2hlZDtcclxuICAgIGluaXRpYWxTdGF0dXMuY3VycmVudCA9IHN0YXR1cztcclxuXHJcbiAgICB2YXIgZGlzcGF0Y2hGbiA9IGZ1bmN0aW9uIGRpc3BhdGNoRm4oKSB7XHJcbiAgICAgIGRpc3BhdGNoKHtcclxuICAgICAgICB0eXBlOiAnUkVTRVRfRk9STScsXHJcbiAgICAgICAgcGF5bG9hZDoge1xyXG4gICAgICAgICAgaXNTdWJtaXR0aW5nOiAhIW5leHRTdGF0ZSAmJiAhIW5leHRTdGF0ZS5pc1N1Ym1pdHRpbmcsXHJcbiAgICAgICAgICBlcnJvcnM6IGVycm9ycyxcclxuICAgICAgICAgIHRvdWNoZWQ6IHRvdWNoZWQsXHJcbiAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcclxuICAgICAgICAgIHZhbHVlczogdmFsdWVzLFxyXG4gICAgICAgICAgaXNWYWxpZGF0aW5nOiAhIW5leHRTdGF0ZSAmJiAhIW5leHRTdGF0ZS5pc1ZhbGlkYXRpbmcsXHJcbiAgICAgICAgICBzdWJtaXRDb3VudDogISFuZXh0U3RhdGUgJiYgISFuZXh0U3RhdGUuc3VibWl0Q291bnQgJiYgdHlwZW9mIG5leHRTdGF0ZS5zdWJtaXRDb3VudCA9PT0gJ251bWJlcicgPyBuZXh0U3RhdGUuc3VibWl0Q291bnQgOiAwXHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgaWYgKHByb3BzLm9uUmVzZXQpIHtcclxuICAgICAgdmFyIG1heWJlUHJvbWlzZWRPblJlc2V0ID0gcHJvcHMub25SZXNldChzdGF0ZS52YWx1ZXMsIGltcGVyYXRpdmVNZXRob2RzKTtcclxuXHJcbiAgICAgIGlmIChpc1Byb21pc2UobWF5YmVQcm9taXNlZE9uUmVzZXQpKSB7XHJcbiAgICAgICAgbWF5YmVQcm9taXNlZE9uUmVzZXQudGhlbihkaXNwYXRjaEZuKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkaXNwYXRjaEZuKCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRpc3BhdGNoRm4oKTtcclxuICAgIH1cclxuICB9LCBbcHJvcHMuaW5pdGlhbEVycm9ycywgcHJvcHMuaW5pdGlhbFN0YXR1cywgcHJvcHMuaW5pdGlhbFRvdWNoZWQsIHByb3BzLm9uUmVzZXRdKTtcclxuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKGlzTW91bnRlZC5jdXJyZW50ID09PSB0cnVlICYmICFpc0VxdWFsKGluaXRpYWxWYWx1ZXMuY3VycmVudCwgcHJvcHMuaW5pdGlhbFZhbHVlcykpIHtcclxuICAgICAgaWYgKGVuYWJsZVJlaW5pdGlhbGl6ZSkge1xyXG4gICAgICAgIGluaXRpYWxWYWx1ZXMuY3VycmVudCA9IHByb3BzLmluaXRpYWxWYWx1ZXM7XHJcbiAgICAgICAgcmVzZXRGb3JtKCk7XHJcblxyXG4gICAgICAgIGlmICh2YWxpZGF0ZU9uTW91bnQpIHtcclxuICAgICAgICAgIHZhbGlkYXRlRm9ybVdpdGhIaWdoUHJpb3JpdHkoaW5pdGlhbFZhbHVlcy5jdXJyZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCBbZW5hYmxlUmVpbml0aWFsaXplLCBwcm9wcy5pbml0aWFsVmFsdWVzLCByZXNldEZvcm0sIHZhbGlkYXRlT25Nb3VudCwgdmFsaWRhdGVGb3JtV2l0aEhpZ2hQcmlvcml0eV0pO1xyXG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoZW5hYmxlUmVpbml0aWFsaXplICYmIGlzTW91bnRlZC5jdXJyZW50ID09PSB0cnVlICYmICFpc0VxdWFsKGluaXRpYWxFcnJvcnMuY3VycmVudCwgcHJvcHMuaW5pdGlhbEVycm9ycykpIHtcclxuICAgICAgaW5pdGlhbEVycm9ycy5jdXJyZW50ID0gcHJvcHMuaW5pdGlhbEVycm9ycyB8fCBlbXB0eUVycm9ycztcclxuICAgICAgZGlzcGF0Y2goe1xyXG4gICAgICAgIHR5cGU6ICdTRVRfRVJST1JTJyxcclxuICAgICAgICBwYXlsb2FkOiBwcm9wcy5pbml0aWFsRXJyb3JzIHx8IGVtcHR5RXJyb3JzXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0sIFtlbmFibGVSZWluaXRpYWxpemUsIHByb3BzLmluaXRpYWxFcnJvcnNdKTtcclxuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKGVuYWJsZVJlaW5pdGlhbGl6ZSAmJiBpc01vdW50ZWQuY3VycmVudCA9PT0gdHJ1ZSAmJiAhaXNFcXVhbChpbml0aWFsVG91Y2hlZC5jdXJyZW50LCBwcm9wcy5pbml0aWFsVG91Y2hlZCkpIHtcclxuICAgICAgaW5pdGlhbFRvdWNoZWQuY3VycmVudCA9IHByb3BzLmluaXRpYWxUb3VjaGVkIHx8IGVtcHR5VG91Y2hlZDtcclxuICAgICAgZGlzcGF0Y2goe1xyXG4gICAgICAgIHR5cGU6ICdTRVRfVE9VQ0hFRCcsXHJcbiAgICAgICAgcGF5bG9hZDogcHJvcHMuaW5pdGlhbFRvdWNoZWQgfHwgZW1wdHlUb3VjaGVkXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0sIFtlbmFibGVSZWluaXRpYWxpemUsIHByb3BzLmluaXRpYWxUb3VjaGVkXSk7XHJcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgIGlmIChlbmFibGVSZWluaXRpYWxpemUgJiYgaXNNb3VudGVkLmN1cnJlbnQgPT09IHRydWUgJiYgIWlzRXF1YWwoaW5pdGlhbFN0YXR1cy5jdXJyZW50LCBwcm9wcy5pbml0aWFsU3RhdHVzKSkge1xyXG4gICAgICBpbml0aWFsU3RhdHVzLmN1cnJlbnQgPSBwcm9wcy5pbml0aWFsU3RhdHVzO1xyXG4gICAgICBkaXNwYXRjaCh7XHJcbiAgICAgICAgdHlwZTogJ1NFVF9TVEFUVVMnLFxyXG4gICAgICAgIHBheWxvYWQ6IHByb3BzLmluaXRpYWxTdGF0dXNcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSwgW2VuYWJsZVJlaW5pdGlhbGl6ZSwgcHJvcHMuaW5pdGlhbFN0YXR1cywgcHJvcHMuaW5pdGlhbFRvdWNoZWRdKTtcclxuICB2YXIgdmFsaWRhdGVGaWVsZCA9IHVzZUV2ZW50Q2FsbGJhY2soZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgIC8vIFRoaXMgd2lsbCBlZmZpY2llbnRseSB2YWxpZGF0ZSBhIHNpbmdsZSBmaWVsZCBieSBhdm9pZGluZyBzdGF0ZVxyXG4gICAgLy8gY2hhbmdlcyBpZiB0aGUgdmFsaWRhdGlvbiBmdW5jdGlvbiBpcyBzeW5jaHJvbm91cy4gSXQncyBkaWZmZXJlbnQgZnJvbVxyXG4gICAgLy8gd2hhdCBpcyBjYWxsZWQgd2hlbiB1c2luZyB2YWxpZGF0ZUZvcm0uXHJcbiAgICBpZiAoZmllbGRSZWdpc3RyeS5jdXJyZW50W25hbWVdICYmIGlzRnVuY3Rpb24oZmllbGRSZWdpc3RyeS5jdXJyZW50W25hbWVdLnZhbGlkYXRlKSkge1xyXG4gICAgICB2YXIgdmFsdWUgPSBnZXRJbihzdGF0ZS52YWx1ZXMsIG5hbWUpO1xyXG4gICAgICB2YXIgbWF5YmVQcm9taXNlID0gZmllbGRSZWdpc3RyeS5jdXJyZW50W25hbWVdLnZhbGlkYXRlKHZhbHVlKTtcclxuXHJcbiAgICAgIGlmIChpc1Byb21pc2UobWF5YmVQcm9taXNlKSkge1xyXG4gICAgICAgIC8vIE9ubHkgZmxpcCBpc1ZhbGlkYXRpbmcgaWYgdGhlIGZ1bmN0aW9uIGlzIGFzeW5jLlxyXG4gICAgICAgIGRpc3BhdGNoKHtcclxuICAgICAgICAgIHR5cGU6ICdTRVRfSVNWQUxJREFUSU5HJyxcclxuICAgICAgICAgIHBheWxvYWQ6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbWF5YmVQcm9taXNlLnRoZW4oZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICBkaXNwYXRjaCh7XHJcbiAgICAgICAgICAgIHR5cGU6ICdTRVRfRklFTERfRVJST1InLFxyXG4gICAgICAgICAgICBwYXlsb2FkOiB7XHJcbiAgICAgICAgICAgICAgZmllbGQ6IG5hbWUsXHJcbiAgICAgICAgICAgICAgdmFsdWU6IGVycm9yXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICB0eXBlOiAnU0VUX0lTVkFMSURBVElORycsXHJcbiAgICAgICAgICAgIHBheWxvYWQ6IGZhbHNlXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkaXNwYXRjaCh7XHJcbiAgICAgICAgICB0eXBlOiAnU0VUX0ZJRUxEX0VSUk9SJyxcclxuICAgICAgICAgIHBheWxvYWQ6IHtcclxuICAgICAgICAgICAgZmllbGQ6IG5hbWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBtYXliZVByb21pc2VcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1heWJlUHJvbWlzZSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAocHJvcHMudmFsaWRhdGlvblNjaGVtYSkge1xyXG4gICAgICBkaXNwYXRjaCh7XHJcbiAgICAgICAgdHlwZTogJ1NFVF9JU1ZBTElEQVRJTkcnLFxyXG4gICAgICAgIHBheWxvYWQ6IHRydWVcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBydW5WYWxpZGF0aW9uU2NoZW1hKHN0YXRlLnZhbHVlcywgbmFtZSkudGhlbihmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgIGRpc3BhdGNoKHtcclxuICAgICAgICAgIHR5cGU6ICdTRVRfRklFTERfRVJST1InLFxyXG4gICAgICAgICAgcGF5bG9hZDoge1xyXG4gICAgICAgICAgICBmaWVsZDogbmFtZSxcclxuICAgICAgICAgICAgdmFsdWU6IGdldEluKGVycm9yLCBuYW1lKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGRpc3BhdGNoKHtcclxuICAgICAgICAgIHR5cGU6ICdTRVRfSVNWQUxJREFUSU5HJyxcclxuICAgICAgICAgIHBheWxvYWQ6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICB9KTtcclxuICB2YXIgcmVnaXN0ZXJGaWVsZCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChuYW1lLCBfcmVmMykge1xyXG4gICAgdmFyIHZhbGlkYXRlID0gX3JlZjMudmFsaWRhdGU7XHJcbiAgICBmaWVsZFJlZ2lzdHJ5LmN1cnJlbnRbbmFtZV0gPSB7XHJcbiAgICAgIHZhbGlkYXRlOiB2YWxpZGF0ZVxyXG4gICAgfTtcclxuICB9LCBbXSk7XHJcbiAgdmFyIHVucmVnaXN0ZXJGaWVsZCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICBkZWxldGUgZmllbGRSZWdpc3RyeS5jdXJyZW50W25hbWVdO1xyXG4gIH0sIFtdKTtcclxuICB2YXIgc2V0VG91Y2hlZCA9IHVzZUV2ZW50Q2FsbGJhY2soZnVuY3Rpb24gKHRvdWNoZWQsIHNob3VsZFZhbGlkYXRlKSB7XHJcbiAgICBkaXNwYXRjaCh7XHJcbiAgICAgIHR5cGU6ICdTRVRfVE9VQ0hFRCcsXHJcbiAgICAgIHBheWxvYWQ6IHRvdWNoZWRcclxuICAgIH0pO1xyXG4gICAgdmFyIHdpbGxWYWxpZGF0ZSA9IHNob3VsZFZhbGlkYXRlID09PSB1bmRlZmluZWQgPyB2YWxpZGF0ZU9uQmx1ciA6IHNob3VsZFZhbGlkYXRlO1xyXG4gICAgcmV0dXJuIHdpbGxWYWxpZGF0ZSA/IHZhbGlkYXRlRm9ybVdpdGhIaWdoUHJpb3JpdHkoc3RhdGUudmFsdWVzKSA6IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gIH0pO1xyXG4gIHZhciBzZXRFcnJvcnMgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoZXJyb3JzKSB7XHJcbiAgICBkaXNwYXRjaCh7XHJcbiAgICAgIHR5cGU6ICdTRVRfRVJST1JTJyxcclxuICAgICAgcGF5bG9hZDogZXJyb3JzXHJcbiAgICB9KTtcclxuICB9LCBbXSk7XHJcbiAgdmFyIHNldFZhbHVlcyA9IHVzZUV2ZW50Q2FsbGJhY2soZnVuY3Rpb24gKHZhbHVlcywgc2hvdWxkVmFsaWRhdGUpIHtcclxuICAgIHZhciByZXNvbHZlZFZhbHVlcyA9IGlzRnVuY3Rpb24odmFsdWVzKSA/IHZhbHVlcyhzdGF0ZS52YWx1ZXMpIDogdmFsdWVzO1xyXG4gICAgZGlzcGF0Y2goe1xyXG4gICAgICB0eXBlOiAnU0VUX1ZBTFVFUycsXHJcbiAgICAgIHBheWxvYWQ6IHJlc29sdmVkVmFsdWVzXHJcbiAgICB9KTtcclxuICAgIHZhciB3aWxsVmFsaWRhdGUgPSBzaG91bGRWYWxpZGF0ZSA9PT0gdW5kZWZpbmVkID8gdmFsaWRhdGVPbkNoYW5nZSA6IHNob3VsZFZhbGlkYXRlO1xyXG4gICAgcmV0dXJuIHdpbGxWYWxpZGF0ZSA/IHZhbGlkYXRlRm9ybVdpdGhIaWdoUHJpb3JpdHkocmVzb2x2ZWRWYWx1ZXMpIDogUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgfSk7XHJcbiAgdmFyIHNldEZpZWxkRXJyb3IgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoZmllbGQsIHZhbHVlKSB7XHJcbiAgICBkaXNwYXRjaCh7XHJcbiAgICAgIHR5cGU6ICdTRVRfRklFTERfRVJST1InLFxyXG4gICAgICBwYXlsb2FkOiB7XHJcbiAgICAgICAgZmllbGQ6IGZpZWxkLFxyXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9LCBbXSk7XHJcbiAgdmFyIHNldEZpZWxkVmFsdWUgPSB1c2VFdmVudENhbGxiYWNrKGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUsIHNob3VsZFZhbGlkYXRlKSB7XHJcbiAgICBkaXNwYXRjaCh7XHJcbiAgICAgIHR5cGU6ICdTRVRfRklFTERfVkFMVUUnLFxyXG4gICAgICBwYXlsb2FkOiB7XHJcbiAgICAgICAgZmllbGQ6IGZpZWxkLFxyXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHZhciB3aWxsVmFsaWRhdGUgPSBzaG91bGRWYWxpZGF0ZSA9PT0gdW5kZWZpbmVkID8gdmFsaWRhdGVPbkNoYW5nZSA6IHNob3VsZFZhbGlkYXRlO1xyXG4gICAgcmV0dXJuIHdpbGxWYWxpZGF0ZSA/IHZhbGlkYXRlRm9ybVdpdGhIaWdoUHJpb3JpdHkoc2V0SW4oc3RhdGUudmFsdWVzLCBmaWVsZCwgdmFsdWUpKSA6IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gIH0pO1xyXG4gIHZhciBleGVjdXRlQ2hhbmdlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGV2ZW50T3JUZXh0VmFsdWUsIG1heWJlUGF0aCkge1xyXG4gICAgLy8gQnkgZGVmYXVsdCwgYXNzdW1lIHRoYXQgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nLiBUaGlzIGFsbG93cyB1cyB0byB1c2VcclxuICAgIC8vIGhhbmRsZUNoYW5nZSB3aXRoIFJlYWN0IE5hdGl2ZSBhbmQgUmVhY3QgTmF0aXZlIFdlYidzIG9uQ2hhbmdlVGV4dCBwcm9wIHdoaWNoXHJcbiAgICAvLyBwcm92aWRlcyBqdXN0IHRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQuXHJcbiAgICB2YXIgZmllbGQgPSBtYXliZVBhdGg7XHJcbiAgICB2YXIgdmFsID0gZXZlbnRPclRleHRWYWx1ZTtcclxuICAgIHZhciBwYXJzZWQ7IC8vIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBub3QgYSBzdHJpbmcgdGhvdWdoLCBpdCBoYXMgdG8gYmUgYSBzeW50aGV0aWMgUmVhY3QgRXZlbnQgKG9yIGEgZmFrZSBvbmUpLFxyXG4gICAgLy8gc28gd2UgaGFuZGxlIGxpa2Ugd2Ugd291bGQgYSBub3JtYWwgSFRNTCBjaGFuZ2UgZXZlbnQuXHJcblxyXG4gICAgaWYgKCFpc1N0cmluZyhldmVudE9yVGV4dFZhbHVlKSkge1xyXG4gICAgICAvLyBJZiB3ZSBjYW4sIHBlcnNpc3QgdGhlIGV2ZW50XHJcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2V2ZW50cy5odG1sI2V2ZW50LXBvb2xpbmdcclxuICAgICAgaWYgKGV2ZW50T3JUZXh0VmFsdWUucGVyc2lzdCkge1xyXG4gICAgICAgIGV2ZW50T3JUZXh0VmFsdWUucGVyc2lzdCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgdGFyZ2V0ID0gZXZlbnRPclRleHRWYWx1ZS50YXJnZXQgPyBldmVudE9yVGV4dFZhbHVlLnRhcmdldCA6IGV2ZW50T3JUZXh0VmFsdWUuY3VycmVudFRhcmdldDtcclxuICAgICAgdmFyIHR5cGUgPSB0YXJnZXQudHlwZSxcclxuICAgICAgICAgIG5hbWUgPSB0YXJnZXQubmFtZSxcclxuICAgICAgICAgIGlkID0gdGFyZ2V0LmlkLFxyXG4gICAgICAgICAgdmFsdWUgPSB0YXJnZXQudmFsdWUsXHJcbiAgICAgICAgICBjaGVja2VkID0gdGFyZ2V0LmNoZWNrZWQsXHJcbiAgICAgICAgICBvdXRlckhUTUwgPSB0YXJnZXQub3V0ZXJIVE1MLFxyXG4gICAgICAgICAgb3B0aW9ucyA9IHRhcmdldC5vcHRpb25zLFxyXG4gICAgICAgICAgbXVsdGlwbGUgPSB0YXJnZXQubXVsdGlwbGU7XHJcbiAgICAgIGZpZWxkID0gbWF5YmVQYXRoID8gbWF5YmVQYXRoIDogbmFtZSA/IG5hbWUgOiBpZDtcclxuXHJcbiAgICAgIGlmICghZmllbGQgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgd2FybkFib3V0TWlzc2luZ0lkZW50aWZpZXIoe1xyXG4gICAgICAgICAgaHRtbENvbnRlbnQ6IG91dGVySFRNTCxcclxuICAgICAgICAgIGRvY3VtZW50YXRpb25BbmNob3JMaW5rOiAnaGFuZGxlY2hhbmdlLWUtcmVhY3RjaGFuZ2VldmVudGFueS0tdm9pZCcsXHJcbiAgICAgICAgICBoYW5kbGVyTmFtZTogJ2hhbmRsZUNoYW5nZSdcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFsID0gL251bWJlcnxyYW5nZS8udGVzdCh0eXBlKSA/IChwYXJzZWQgPSBwYXJzZUZsb2F0KHZhbHVlKSwgaXNOYU4ocGFyc2VkKSA/ICcnIDogcGFyc2VkKSA6IC9jaGVja2JveC8udGVzdCh0eXBlKSAvLyBjaGVja2JveGVzXHJcbiAgICAgID8gZ2V0VmFsdWVGb3JDaGVja2JveChnZXRJbihzdGF0ZS52YWx1ZXMsIGZpZWxkKSwgY2hlY2tlZCwgdmFsdWUpIDogb3B0aW9ucyAmJiBtdWx0aXBsZSAvLyA8c2VsZWN0IG11bHRpcGxlPlxyXG4gICAgICA/IGdldFNlbGVjdGVkVmFsdWVzKG9wdGlvbnMpIDogdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGZpZWxkKSB7XHJcbiAgICAgIC8vIFNldCBmb3JtIGZpZWxkcyBieSBuYW1lXHJcbiAgICAgIHNldEZpZWxkVmFsdWUoZmllbGQsIHZhbCk7XHJcbiAgICB9XHJcbiAgfSwgW3NldEZpZWxkVmFsdWUsIHN0YXRlLnZhbHVlc10pO1xyXG4gIHZhciBoYW5kbGVDaGFuZ2UgPSB1c2VFdmVudENhbGxiYWNrKGZ1bmN0aW9uIChldmVudE9yUGF0aCkge1xyXG4gICAgaWYgKGlzU3RyaW5nKGV2ZW50T3JQYXRoKSkge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGVDaGFuZ2UoZXZlbnQsIGV2ZW50T3JQYXRoKTtcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGV4ZWN1dGVDaGFuZ2UoZXZlbnRPclBhdGgpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHZhciBzZXRGaWVsZFRvdWNoZWQgPSB1c2VFdmVudENhbGxiYWNrKGZ1bmN0aW9uIChmaWVsZCwgdG91Y2hlZCwgc2hvdWxkVmFsaWRhdGUpIHtcclxuICAgIGlmICh0b3VjaGVkID09PSB2b2lkIDApIHtcclxuICAgICAgdG91Y2hlZCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgZGlzcGF0Y2goe1xyXG4gICAgICB0eXBlOiAnU0VUX0ZJRUxEX1RPVUNIRUQnLFxyXG4gICAgICBwYXlsb2FkOiB7XHJcbiAgICAgICAgZmllbGQ6IGZpZWxkLFxyXG4gICAgICAgIHZhbHVlOiB0b3VjaGVkXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdmFyIHdpbGxWYWxpZGF0ZSA9IHNob3VsZFZhbGlkYXRlID09PSB1bmRlZmluZWQgPyB2YWxpZGF0ZU9uQmx1ciA6IHNob3VsZFZhbGlkYXRlO1xyXG4gICAgcmV0dXJuIHdpbGxWYWxpZGF0ZSA/IHZhbGlkYXRlRm9ybVdpdGhIaWdoUHJpb3JpdHkoc3RhdGUudmFsdWVzKSA6IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gIH0pO1xyXG4gIHZhciBleGVjdXRlQmx1ciA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlLCBwYXRoKSB7XHJcbiAgICBpZiAoZS5wZXJzaXN0KSB7XHJcbiAgICAgIGUucGVyc2lzdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBfZSR0YXJnZXQgPSBlLnRhcmdldCxcclxuICAgICAgICBuYW1lID0gX2UkdGFyZ2V0Lm5hbWUsXHJcbiAgICAgICAgaWQgPSBfZSR0YXJnZXQuaWQsXHJcbiAgICAgICAgb3V0ZXJIVE1MID0gX2UkdGFyZ2V0Lm91dGVySFRNTDtcclxuICAgIHZhciBmaWVsZCA9IHBhdGggPyBwYXRoIDogbmFtZSA/IG5hbWUgOiBpZDtcclxuXHJcbiAgICBpZiAoIWZpZWxkICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICB3YXJuQWJvdXRNaXNzaW5nSWRlbnRpZmllcih7XHJcbiAgICAgICAgaHRtbENvbnRlbnQ6IG91dGVySFRNTCxcclxuICAgICAgICBkb2N1bWVudGF0aW9uQW5jaG9yTGluazogJ2hhbmRsZWJsdXItZS1hbnktLXZvaWQnLFxyXG4gICAgICAgIGhhbmRsZXJOYW1lOiAnaGFuZGxlQmx1cidcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0RmllbGRUb3VjaGVkKGZpZWxkLCB0cnVlKTtcclxuICB9LCBbc2V0RmllbGRUb3VjaGVkXSk7XHJcbiAgdmFyIGhhbmRsZUJsdXIgPSB1c2VFdmVudENhbGxiYWNrKGZ1bmN0aW9uIChldmVudE9yU3RyaW5nKSB7XHJcbiAgICBpZiAoaXNTdHJpbmcoZXZlbnRPclN0cmluZykpIHtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIHJldHVybiBleGVjdXRlQmx1cihldmVudCwgZXZlbnRPclN0cmluZyk7XHJcbiAgICAgIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBleGVjdXRlQmx1cihldmVudE9yU3RyaW5nKTtcclxuICAgIH1cclxuICB9KTtcclxuICB2YXIgc2V0Rm9ybWlrU3RhdGUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoc3RhdGVPckNiKSB7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihzdGF0ZU9yQ2IpKSB7XHJcbiAgICAgIGRpc3BhdGNoKHtcclxuICAgICAgICB0eXBlOiAnU0VUX0ZPUk1JS19TVEFURScsXHJcbiAgICAgICAgcGF5bG9hZDogc3RhdGVPckNiXHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZGlzcGF0Y2goe1xyXG4gICAgICAgIHR5cGU6ICdTRVRfRk9STUlLX1NUQVRFJyxcclxuICAgICAgICBwYXlsb2FkOiBmdW5jdGlvbiBwYXlsb2FkKCkge1xyXG4gICAgICAgICAgcmV0dXJuIHN0YXRlT3JDYjtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0sIFtdKTtcclxuICB2YXIgc2V0U3RhdHVzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKHN0YXR1cykge1xyXG4gICAgZGlzcGF0Y2goe1xyXG4gICAgICB0eXBlOiAnU0VUX1NUQVRVUycsXHJcbiAgICAgIHBheWxvYWQ6IHN0YXR1c1xyXG4gICAgfSk7XHJcbiAgfSwgW10pO1xyXG4gIHZhciBzZXRTdWJtaXR0aW5nID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGlzU3VibWl0dGluZykge1xyXG4gICAgZGlzcGF0Y2goe1xyXG4gICAgICB0eXBlOiAnU0VUX0lTU1VCTUlUVElORycsXHJcbiAgICAgIHBheWxvYWQ6IGlzU3VibWl0dGluZ1xyXG4gICAgfSk7XHJcbiAgfSwgW10pO1xyXG4gIHZhciBzdWJtaXRGb3JtID0gdXNlRXZlbnRDYWxsYmFjayhmdW5jdGlvbiAoKSB7XHJcbiAgICBkaXNwYXRjaCh7XHJcbiAgICAgIHR5cGU6ICdTVUJNSVRfQVRURU1QVCdcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHZhbGlkYXRlRm9ybVdpdGhIaWdoUHJpb3JpdHkoKS50aGVuKGZ1bmN0aW9uIChjb21iaW5lZEVycm9ycykge1xyXG4gICAgICAvLyBJbiBjYXNlIGFuIGVycm9yIHdhcyB0aHJvd24gYW5kIHBhc3NlZCB0byB0aGUgcmVzb2x2ZWQgUHJvbWlzZSxcclxuICAgICAgLy8gYGNvbWJpbmVkRXJyb3JzYCBjYW4gYmUgYW4gaW5zdGFuY2Ugb2YgYW4gRXJyb3IuIFdlIG5lZWQgdG8gY2hlY2tcclxuICAgICAgLy8gdGhhdCBhbmQgYWJvcnQgdGhlIHN1Ym1pdC5cclxuICAgICAgLy8gSWYgd2UgZG9uJ3QgZG8gdGhhdCwgY2FsbGluZyBgT2JqZWN0LmtleXMobmV3IEVycm9yKCkpYCB5aWVsZHMgYW5cclxuICAgICAgLy8gZW1wdHkgYXJyYXksIHdoaWNoIGNhdXNlcyB0aGUgdmFsaWRhdGlvbiB0byBwYXNzIGFuZCB0aGUgZm9ybVxyXG4gICAgICAvLyB0byBiZSBzdWJtaXR0ZWQuXHJcbiAgICAgIHZhciBpc0luc3RhbmNlT2ZFcnJvciA9IGNvbWJpbmVkRXJyb3JzIGluc3RhbmNlb2YgRXJyb3I7XHJcbiAgICAgIHZhciBpc0FjdHVhbGx5VmFsaWQgPSAhaXNJbnN0YW5jZU9mRXJyb3IgJiYgT2JqZWN0LmtleXMoY29tYmluZWRFcnJvcnMpLmxlbmd0aCA9PT0gMDtcclxuXHJcbiAgICAgIGlmIChpc0FjdHVhbGx5VmFsaWQpIHtcclxuICAgICAgICAvLyBQcm9jZWVkIHdpdGggc3VibWl0Li4uXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBUbyByZXNwZWN0IHN5bmMgc3VibWl0IGZucywgd2UgY2FuJ3Qgc2ltcGx5IHdyYXAgZXhlY3V0ZVN1Ym1pdCBpbiBhIHByb21pc2UgYW5kXHJcbiAgICAgICAgLy8gX2Fsd2F5c18gZGlzcGF0Y2ggU1VCTUlUX1NVQ0NFU1MgYmVjYXVzZSBpc1N1Ym1pdHRpbmcgd291bGQgdGhlbiBhbHdheXMgYmUgZmFsc2UuXHJcbiAgICAgICAgLy8gVGhpcyB3b3VsZCBiZSBmaW5lIGluIHNpbXBsZSBjYXNlcywgYnV0IG1ha2UgaXQgaW1wb3NzaWJsZSB0byBkaXNhYmxlIHN1Ym1pdFxyXG4gICAgICAgIC8vIGJ1dHRvbnMgd2hlcmUgcGVvcGxlIHVzZSBjYWxsYmFja3Mgb3IgcHJvbWlzZXMgYXMgc2lkZSBlZmZlY3RzICh3aGljaCBpcyBiYXNpY2FsbHlcclxuICAgICAgICAvLyBhbGwgb2YgdjEgRm9ybWlrIGNvZGUpLiBJbnN0ZWFkLCByZWNhbGwgdGhhdCB3ZSBhcmUgaW5zaWRlIG9mIGEgcHJvbWlzZSBjaGFpbiBhbHJlYWR5LFxyXG4gICAgICAgIC8vICBzbyB3ZSBjYW4gdHJ5L2NhdGNoIGV4ZWN1dGVTdWJtaXQoKSwgaWYgaXQgcmV0dXJucyB1bmRlZmluZWQsIHRoZW4ganVzdCBiYWlsLlxyXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBlcnJvcnMsIHRocm93IGVtLiBPdGhlcndpc2UsIHdyYXAgZXhlY3V0ZVN1Ym1pdCBpbiBhIHByb21pc2UgYW5kIGhhbmRsZVxyXG4gICAgICAgIC8vIGNsZWFudXAgb2YgaXNTdWJtaXR0aW5nIG9uIGJlaGFsZiBvZiB0aGUgY29uc3VtZXIuXHJcbiAgICAgICAgdmFyIHByb21pc2VPclVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHByb21pc2VPclVuZGVmaW5lZCA9IGV4ZWN1dGVTdWJtaXQoKTsgLy8gQmFpbCBpZiBpdCdzIHN5bmMsIGNvbnN1bWVyIGlzIHJlc3BvbnNpYmxlIGZvciBjbGVhbmluZyB1cFxyXG4gICAgICAgICAgLy8gdmlhIHNldFN1Ym1pdHRpbmcoZmFsc2UpXHJcblxyXG4gICAgICAgICAgaWYgKHByb21pc2VPclVuZGVmaW5lZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHByb21pc2VPclVuZGVmaW5lZCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICBpZiAoISFpc01vdW50ZWQuY3VycmVudCkge1xyXG4gICAgICAgICAgICBkaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgdHlwZTogJ1NVQk1JVF9TVUNDRVNTJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKF9lcnJvcnMpIHtcclxuICAgICAgICAgIGlmICghIWlzTW91bnRlZC5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICB0eXBlOiAnU1VCTUlUX0ZBSUxVUkUnXHJcbiAgICAgICAgICAgIH0pOyAvLyBUaGlzIGlzIGEgbGVnaXQgZXJyb3IgcmVqZWN0ZWQgYnkgdGhlIG9uU3VibWl0IGZuXHJcbiAgICAgICAgICAgIC8vIHNvIHdlIGRvbid0IHdhbnQgdG8gYnJlYWsgdGhlIHByb21pc2UgY2hhaW5cclxuXHJcbiAgICAgICAgICAgIHRocm93IF9lcnJvcnM7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoISFpc01vdW50ZWQuY3VycmVudCkge1xyXG4gICAgICAgIC8vIF5eXiBNYWtlIHN1cmUgRm9ybWlrIGlzIHN0aWxsIG1vdW50ZWQgYmVmb3JlIHVwZGF0aW5nIHN0YXRlXHJcbiAgICAgICAgZGlzcGF0Y2goe1xyXG4gICAgICAgICAgdHlwZTogJ1NVQk1JVF9GQUlMVVJFJ1xyXG4gICAgICAgIH0pOyAvLyB0aHJvdyBjb21iaW5lZEVycm9ycztcclxuXHJcbiAgICAgICAgaWYgKGlzSW5zdGFuY2VPZkVycm9yKSB7XHJcbiAgICAgICAgICB0aHJvdyBjb21iaW5lZEVycm9ycztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG4gIHZhciBoYW5kbGVTdWJtaXQgPSB1c2VFdmVudENhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XHJcbiAgICBpZiAoZSAmJiBlLnByZXZlbnREZWZhdWx0ICYmIGlzRnVuY3Rpb24oZS5wcmV2ZW50RGVmYXVsdCkpIHtcclxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChlICYmIGUuc3RvcFByb3BhZ2F0aW9uICYmIGlzRnVuY3Rpb24oZS5zdG9wUHJvcGFnYXRpb24pKSB7XHJcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICB9IC8vIFdhcm4gaWYgZm9ybSBzdWJtaXNzaW9uIGlzIHRyaWdnZXJlZCBieSBhIDxidXR0b24+IHdpdGhvdXQgYVxyXG4gICAgLy8gc3BlY2lmaWVkIGB0eXBlYCBhdHRyaWJ1dGUgZHVyaW5nIGRldmVsb3BtZW50LiBUaGlzIG1pdGlnYXRlc1xyXG4gICAgLy8gYSBjb21tb24gZ290Y2hhIGluIGZvcm1zIHdpdGggYm90aCByZXNldCBhbmQgc3VibWl0IGJ1dHRvbnMsXHJcbiAgICAvLyB3aGVyZSB0aGUgZGV2IGZvcmdldHMgdG8gYWRkIHR5cGU9XCJidXR0b25cIiB0byB0aGUgcmVzZXQgYnV0dG9uLlxyXG5cclxuXHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgLy8gU2FmZWx5IGdldCB0aGUgYWN0aXZlIGVsZW1lbnQgKHdvcmtzIHdpdGggSUUpXHJcbiAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xyXG5cclxuICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQgIT09IG51bGwgJiYgYWN0aXZlRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxCdXR0b25FbGVtZW50KSB7XHJcbiAgICAgICAgIShhY3RpdmVFbGVtZW50LmF0dHJpYnV0ZXMgJiYgYWN0aXZlRWxlbWVudC5hdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgndHlwZScpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1lvdSBzdWJtaXR0ZWQgYSBGb3JtaWsgZm9ybSB1c2luZyBhIGJ1dHRvbiB3aXRoIGFuIHVuc3BlY2lmaWVkIGB0eXBlYCBhdHRyaWJ1dGUuICBNb3N0IGJyb3dzZXJzIGRlZmF1bHQgYnV0dG9uIGVsZW1lbnRzIHRvIGB0eXBlPVwic3VibWl0XCJgLiBJZiB0aGlzIGlzIG5vdCBhIHN1Ym1pdCBidXR0b24sIHBsZWFzZSBhZGQgYHR5cGU9XCJidXR0b25cImAuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3VibWl0Rm9ybSgpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKHJlYXNvbikge1xyXG4gICAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiBBbiB1bmhhbmRsZWQgZXJyb3Igd2FzIGNhdWdodCBmcm9tIHN1Ym1pdEZvcm0oKVwiLCByZWFzb24pO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbiAgdmFyIGltcGVyYXRpdmVNZXRob2RzID0ge1xyXG4gICAgcmVzZXRGb3JtOiByZXNldEZvcm0sXHJcbiAgICB2YWxpZGF0ZUZvcm06IHZhbGlkYXRlRm9ybVdpdGhIaWdoUHJpb3JpdHksXHJcbiAgICB2YWxpZGF0ZUZpZWxkOiB2YWxpZGF0ZUZpZWxkLFxyXG4gICAgc2V0RXJyb3JzOiBzZXRFcnJvcnMsXHJcbiAgICBzZXRGaWVsZEVycm9yOiBzZXRGaWVsZEVycm9yLFxyXG4gICAgc2V0RmllbGRUb3VjaGVkOiBzZXRGaWVsZFRvdWNoZWQsXHJcbiAgICBzZXRGaWVsZFZhbHVlOiBzZXRGaWVsZFZhbHVlLFxyXG4gICAgc2V0U3RhdHVzOiBzZXRTdGF0dXMsXHJcbiAgICBzZXRTdWJtaXR0aW5nOiBzZXRTdWJtaXR0aW5nLFxyXG4gICAgc2V0VG91Y2hlZDogc2V0VG91Y2hlZCxcclxuICAgIHNldFZhbHVlczogc2V0VmFsdWVzLFxyXG4gICAgc2V0Rm9ybWlrU3RhdGU6IHNldEZvcm1pa1N0YXRlLFxyXG4gICAgc3VibWl0Rm9ybTogc3VibWl0Rm9ybVxyXG4gIH07XHJcbiAgdmFyIGV4ZWN1dGVTdWJtaXQgPSB1c2VFdmVudENhbGxiYWNrKGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBvblN1Ym1pdChzdGF0ZS52YWx1ZXMsIGltcGVyYXRpdmVNZXRob2RzKTtcclxuICB9KTtcclxuICB2YXIgaGFuZGxlUmVzZXQgPSB1c2VFdmVudENhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XHJcbiAgICBpZiAoZSAmJiBlLnByZXZlbnREZWZhdWx0ICYmIGlzRnVuY3Rpb24oZS5wcmV2ZW50RGVmYXVsdCkpIHtcclxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChlICYmIGUuc3RvcFByb3BhZ2F0aW9uICYmIGlzRnVuY3Rpb24oZS5zdG9wUHJvcGFnYXRpb24pKSB7XHJcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVzZXRGb3JtKCk7XHJcbiAgfSk7XHJcbiAgdmFyIGdldEZpZWxkTWV0YSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB2YWx1ZTogZ2V0SW4oc3RhdGUudmFsdWVzLCBuYW1lKSxcclxuICAgICAgZXJyb3I6IGdldEluKHN0YXRlLmVycm9ycywgbmFtZSksXHJcbiAgICAgIHRvdWNoZWQ6ICEhZ2V0SW4oc3RhdGUudG91Y2hlZCwgbmFtZSksXHJcbiAgICAgIGluaXRpYWxWYWx1ZTogZ2V0SW4oaW5pdGlhbFZhbHVlcy5jdXJyZW50LCBuYW1lKSxcclxuICAgICAgaW5pdGlhbFRvdWNoZWQ6ICEhZ2V0SW4oaW5pdGlhbFRvdWNoZWQuY3VycmVudCwgbmFtZSksXHJcbiAgICAgIGluaXRpYWxFcnJvcjogZ2V0SW4oaW5pdGlhbEVycm9ycy5jdXJyZW50LCBuYW1lKVxyXG4gICAgfTtcclxuICB9LCBbc3RhdGUuZXJyb3JzLCBzdGF0ZS50b3VjaGVkLCBzdGF0ZS52YWx1ZXNdKTtcclxuICB2YXIgZ2V0RmllbGRIZWxwZXJzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHNldFZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSh2YWx1ZSwgc2hvdWxkVmFsaWRhdGUpIHtcclxuICAgICAgICByZXR1cm4gc2V0RmllbGRWYWx1ZShuYW1lLCB2YWx1ZSwgc2hvdWxkVmFsaWRhdGUpO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXRUb3VjaGVkOiBmdW5jdGlvbiBzZXRUb3VjaGVkKHZhbHVlLCBzaG91bGRWYWxpZGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBzZXRGaWVsZFRvdWNoZWQobmFtZSwgdmFsdWUsIHNob3VsZFZhbGlkYXRlKTtcclxuICAgICAgfSxcclxuICAgICAgc2V0RXJyb3I6IGZ1bmN0aW9uIHNldEVycm9yKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHNldEZpZWxkRXJyb3IobmFtZSwgdmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0sIFtzZXRGaWVsZFZhbHVlLCBzZXRGaWVsZFRvdWNoZWQsIHNldEZpZWxkRXJyb3JdKTtcclxuICB2YXIgZ2V0RmllbGRQcm9wcyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChuYW1lT3JPcHRpb25zKSB7XHJcbiAgICB2YXIgaXNBbk9iamVjdCA9IGlzT2JqZWN0KG5hbWVPck9wdGlvbnMpO1xyXG4gICAgdmFyIG5hbWUgPSBpc0FuT2JqZWN0ID8gbmFtZU9yT3B0aW9ucy5uYW1lIDogbmFtZU9yT3B0aW9ucztcclxuICAgIHZhciB2YWx1ZVN0YXRlID0gZ2V0SW4oc3RhdGUudmFsdWVzLCBuYW1lKTtcclxuICAgIHZhciBmaWVsZCA9IHtcclxuICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgdmFsdWU6IHZhbHVlU3RhdGUsXHJcbiAgICAgIG9uQ2hhbmdlOiBoYW5kbGVDaGFuZ2UsXHJcbiAgICAgIG9uQmx1cjogaGFuZGxlQmx1clxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoaXNBbk9iamVjdCkge1xyXG4gICAgICB2YXIgdHlwZSA9IG5hbWVPck9wdGlvbnMudHlwZSxcclxuICAgICAgICAgIHZhbHVlUHJvcCA9IG5hbWVPck9wdGlvbnMudmFsdWUsXHJcbiAgICAgICAgICBpcyA9IG5hbWVPck9wdGlvbnMuYXMsXHJcbiAgICAgICAgICBtdWx0aXBsZSA9IG5hbWVPck9wdGlvbnMubXVsdGlwbGU7XHJcblxyXG4gICAgICBpZiAodHlwZSA9PT0gJ2NoZWNrYm94Jykge1xyXG4gICAgICAgIGlmICh2YWx1ZVByb3AgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgZmllbGQuY2hlY2tlZCA9ICEhdmFsdWVTdGF0ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZmllbGQuY2hlY2tlZCA9ICEhKEFycmF5LmlzQXJyYXkodmFsdWVTdGF0ZSkgJiYgfnZhbHVlU3RhdGUuaW5kZXhPZih2YWx1ZVByb3ApKTtcclxuICAgICAgICAgIGZpZWxkLnZhbHVlID0gdmFsdWVQcm9wO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAncmFkaW8nKSB7XHJcbiAgICAgICAgZmllbGQuY2hlY2tlZCA9IHZhbHVlU3RhdGUgPT09IHZhbHVlUHJvcDtcclxuICAgICAgICBmaWVsZC52YWx1ZSA9IHZhbHVlUHJvcDtcclxuICAgICAgfSBlbHNlIGlmIChpcyA9PT0gJ3NlbGVjdCcgJiYgbXVsdGlwbGUpIHtcclxuICAgICAgICBmaWVsZC52YWx1ZSA9IGZpZWxkLnZhbHVlIHx8IFtdO1xyXG4gICAgICAgIGZpZWxkLm11bHRpcGxlID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmaWVsZDtcclxuICB9LCBbaGFuZGxlQmx1ciwgaGFuZGxlQ2hhbmdlLCBzdGF0ZS52YWx1ZXNdKTtcclxuICB2YXIgZGlydHkgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAhaXNFcXVhbChpbml0aWFsVmFsdWVzLmN1cnJlbnQsIHN0YXRlLnZhbHVlcyk7XHJcbiAgfSwgW2luaXRpYWxWYWx1ZXMuY3VycmVudCwgc3RhdGUudmFsdWVzXSk7XHJcbiAgdmFyIGlzVmFsaWQgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0eXBlb2YgaXNJbml0aWFsVmFsaWQgIT09ICd1bmRlZmluZWQnID8gZGlydHkgPyBzdGF0ZS5lcnJvcnMgJiYgT2JqZWN0LmtleXMoc3RhdGUuZXJyb3JzKS5sZW5ndGggPT09IDAgOiBpc0luaXRpYWxWYWxpZCAhPT0gZmFsc2UgJiYgaXNGdW5jdGlvbihpc0luaXRpYWxWYWxpZCkgPyBpc0luaXRpYWxWYWxpZChwcm9wcykgOiBpc0luaXRpYWxWYWxpZCA6IHN0YXRlLmVycm9ycyAmJiBPYmplY3Qua2V5cyhzdGF0ZS5lcnJvcnMpLmxlbmd0aCA9PT0gMDtcclxuICB9LCBbaXNJbml0aWFsVmFsaWQsIGRpcnR5LCBzdGF0ZS5lcnJvcnMsIHByb3BzXSk7XHJcblxyXG4gIHZhciBjdHggPSBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcclxuICAgIGluaXRpYWxWYWx1ZXM6IGluaXRpYWxWYWx1ZXMuY3VycmVudCxcclxuICAgIGluaXRpYWxFcnJvcnM6IGluaXRpYWxFcnJvcnMuY3VycmVudCxcclxuICAgIGluaXRpYWxUb3VjaGVkOiBpbml0aWFsVG91Y2hlZC5jdXJyZW50LFxyXG4gICAgaW5pdGlhbFN0YXR1czogaW5pdGlhbFN0YXR1cy5jdXJyZW50LFxyXG4gICAgaGFuZGxlQmx1cjogaGFuZGxlQmx1cixcclxuICAgIGhhbmRsZUNoYW5nZTogaGFuZGxlQ2hhbmdlLFxyXG4gICAgaGFuZGxlUmVzZXQ6IGhhbmRsZVJlc2V0LFxyXG4gICAgaGFuZGxlU3VibWl0OiBoYW5kbGVTdWJtaXQsXHJcbiAgICByZXNldEZvcm06IHJlc2V0Rm9ybSxcclxuICAgIHNldEVycm9yczogc2V0RXJyb3JzLFxyXG4gICAgc2V0Rm9ybWlrU3RhdGU6IHNldEZvcm1pa1N0YXRlLFxyXG4gICAgc2V0RmllbGRUb3VjaGVkOiBzZXRGaWVsZFRvdWNoZWQsXHJcbiAgICBzZXRGaWVsZFZhbHVlOiBzZXRGaWVsZFZhbHVlLFxyXG4gICAgc2V0RmllbGRFcnJvcjogc2V0RmllbGRFcnJvcixcclxuICAgIHNldFN0YXR1czogc2V0U3RhdHVzLFxyXG4gICAgc2V0U3VibWl0dGluZzogc2V0U3VibWl0dGluZyxcclxuICAgIHNldFRvdWNoZWQ6IHNldFRvdWNoZWQsXHJcbiAgICBzZXRWYWx1ZXM6IHNldFZhbHVlcyxcclxuICAgIHN1Ym1pdEZvcm06IHN1Ym1pdEZvcm0sXHJcbiAgICB2YWxpZGF0ZUZvcm06IHZhbGlkYXRlRm9ybVdpdGhIaWdoUHJpb3JpdHksXHJcbiAgICB2YWxpZGF0ZUZpZWxkOiB2YWxpZGF0ZUZpZWxkLFxyXG4gICAgaXNWYWxpZDogaXNWYWxpZCxcclxuICAgIGRpcnR5OiBkaXJ0eSxcclxuICAgIHVucmVnaXN0ZXJGaWVsZDogdW5yZWdpc3RlckZpZWxkLFxyXG4gICAgcmVnaXN0ZXJGaWVsZDogcmVnaXN0ZXJGaWVsZCxcclxuICAgIGdldEZpZWxkUHJvcHM6IGdldEZpZWxkUHJvcHMsXHJcbiAgICBnZXRGaWVsZE1ldGE6IGdldEZpZWxkTWV0YSxcclxuICAgIGdldEZpZWxkSGVscGVyczogZ2V0RmllbGRIZWxwZXJzLFxyXG4gICAgdmFsaWRhdGVPbkJsdXI6IHZhbGlkYXRlT25CbHVyLFxyXG4gICAgdmFsaWRhdGVPbkNoYW5nZTogdmFsaWRhdGVPbkNoYW5nZSxcclxuICAgIHZhbGlkYXRlT25Nb3VudDogdmFsaWRhdGVPbk1vdW50XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBjdHg7XHJcbn1cclxuZnVuY3Rpb24gRm9ybWlrKHByb3BzKSB7XHJcbiAgdmFyIGZvcm1pa2JhZyA9IHVzZUZvcm1payhwcm9wcyk7XHJcbiAgdmFyIGNvbXBvbmVudCA9IHByb3BzLmNvbXBvbmVudCxcclxuICAgICAgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcclxuICAgICAgcmVuZGVyID0gcHJvcHMucmVuZGVyLFxyXG4gICAgICBpbm5lclJlZiA9IHByb3BzLmlubmVyUmVmOyAvLyBUaGlzIGFsbG93cyBmb2xrcyB0byBwYXNzIGEgcmVmIHRvIDxGb3JtaWsgLz5cclxuXHJcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZShpbm5lclJlZiwgZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGZvcm1pa2JhZztcclxuICB9KTtcclxuXHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXHJcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAhIXByb3BzLnJlbmRlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCI8Rm9ybWlrIHJlbmRlcj4gaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBGb3JtaWsuIFBsZWFzZSB1c2UgYSBjaGlsZCBjYWxsYmFjayBmdW5jdGlvbiBpbnN0ZWFkLiBUbyBnZXQgcmlkIG9mIHRoaXMgd2FybmluZywgcmVwbGFjZSA8Rm9ybWlrIHJlbmRlcj17KHByb3BzKSA9PiAuLi59IC8+IHdpdGggPEZvcm1paz57KHByb3BzKSA9PiAuLi59PC9Gb3JtaWs+XCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbiAgICB9LCBbXSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gY3JlYXRlRWxlbWVudChGb3JtaWtQcm92aWRlciwge1xyXG4gICAgdmFsdWU6IGZvcm1pa2JhZ1xyXG4gIH0sIGNvbXBvbmVudCA/IGNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBmb3JtaWtiYWcpIDogcmVuZGVyID8gcmVuZGVyKGZvcm1pa2JhZykgOiBjaGlsZHJlbiAvLyBjaGlsZHJlbiBjb21lIGxhc3QsIGFsd2F5cyBjYWxsZWRcclxuICA/IGlzRnVuY3Rpb24oY2hpbGRyZW4pID8gY2hpbGRyZW4oZm9ybWlrYmFnKSA6ICFpc0VtcHR5Q2hpbGRyZW4oY2hpbGRyZW4pID8gQ2hpbGRyZW4ub25seShjaGlsZHJlbikgOiBudWxsIDogbnVsbCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdhcm5BYm91dE1pc3NpbmdJZGVudGlmaWVyKF9yZWY0KSB7XHJcbiAgdmFyIGh0bWxDb250ZW50ID0gX3JlZjQuaHRtbENvbnRlbnQsXHJcbiAgICAgIGRvY3VtZW50YXRpb25BbmNob3JMaW5rID0gX3JlZjQuZG9jdW1lbnRhdGlvbkFuY2hvckxpbmssXHJcbiAgICAgIGhhbmRsZXJOYW1lID0gX3JlZjQuaGFuZGxlck5hbWU7XHJcbiAgY29uc29sZS53YXJuKFwiV2FybmluZzogRm9ybWlrIGNhbGxlZCBgXCIgKyBoYW5kbGVyTmFtZSArIFwiYCwgYnV0IHlvdSBmb3Jnb3QgdG8gcGFzcyBhbiBgaWRgIG9yIGBuYW1lYCBhdHRyaWJ1dGUgdG8geW91ciBpbnB1dDpcXG4gICAgXCIgKyBodG1sQ29udGVudCArIFwiXFxuICAgIEZvcm1payBjYW5ub3QgZGV0ZXJtaW5lIHdoaWNoIHZhbHVlIHRvIHVwZGF0ZS4gRm9yIG1vcmUgaW5mbyBzZWUgaHR0cHM6Ly9mb3JtaWsub3JnL2RvY3MvYXBpL2Zvcm1payNcIiArIGRvY3VtZW50YXRpb25BbmNob3JMaW5rICsgXCJcXG4gIFwiKTtcclxufVxyXG4vKipcclxuICogVHJhbnNmb3JtIFl1cCBWYWxpZGF0aW9uRXJyb3IgdG8gYSBtb3JlIHVzYWJsZSBvYmplY3RcclxuICovXHJcblxyXG5cclxuZnVuY3Rpb24geXVwVG9Gb3JtRXJyb3JzKHl1cEVycm9yKSB7XHJcbiAgdmFyIGVycm9ycyA9IHt9O1xyXG5cclxuICBpZiAoeXVwRXJyb3IuaW5uZXIpIHtcclxuICAgIGlmICh5dXBFcnJvci5pbm5lci5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuIHNldEluKGVycm9ycywgeXVwRXJyb3IucGF0aCwgeXVwRXJyb3IubWVzc2FnZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0geXVwRXJyb3IuaW5uZXIsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XHJcbiAgICAgIHZhciBfcmVmNTtcclxuXHJcbiAgICAgIGlmIChfaXNBcnJheSkge1xyXG4gICAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcclxuICAgICAgICBfcmVmNSA9IF9pdGVyYXRvcltfaSsrXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBfaSA9IF9pdGVyYXRvci5uZXh0KCk7XHJcbiAgICAgICAgaWYgKF9pLmRvbmUpIGJyZWFrO1xyXG4gICAgICAgIF9yZWY1ID0gX2kudmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBlcnIgPSBfcmVmNTtcclxuXHJcbiAgICAgIGlmICghZ2V0SW4oZXJyb3JzLCBlcnIucGF0aCkpIHtcclxuICAgICAgICBlcnJvcnMgPSBzZXRJbihlcnJvcnMsIGVyci5wYXRoLCBlcnIubWVzc2FnZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBlcnJvcnM7XHJcbn1cclxuLyoqXHJcbiAqIFZhbGlkYXRlIGEgeXVwIHNjaGVtYS5cclxuICovXHJcblxyXG5mdW5jdGlvbiB2YWxpZGF0ZVl1cFNjaGVtYSh2YWx1ZXMsIHNjaGVtYSwgc3luYywgY29udGV4dCkge1xyXG4gIGlmIChzeW5jID09PSB2b2lkIDApIHtcclxuICAgIHN5bmMgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIHZhciBub3JtYWxpemVkVmFsdWVzID0gcHJlcGFyZURhdGFGb3JWYWxpZGF0aW9uKHZhbHVlcyk7XHJcbiAgcmV0dXJuIHNjaGVtYVtzeW5jID8gJ3ZhbGlkYXRlU3luYycgOiAndmFsaWRhdGUnXShub3JtYWxpemVkVmFsdWVzLCB7XHJcbiAgICBhYm9ydEVhcmx5OiBmYWxzZSxcclxuICAgIGNvbnRleHQ6IGNvbnRleHQgfHwgbm9ybWFsaXplZFZhbHVlc1xyXG4gIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBSZWN1cnNpdmVseSBwcmVwYXJlIHZhbHVlcy5cclxuICovXHJcblxyXG5mdW5jdGlvbiBwcmVwYXJlRGF0YUZvclZhbGlkYXRpb24odmFsdWVzKSB7XHJcbiAgdmFyIGRhdGEgPSBBcnJheS5pc0FycmF5KHZhbHVlcykgPyBbXSA6IHt9O1xyXG5cclxuICBmb3IgKHZhciBrIGluIHZhbHVlcykge1xyXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZXMsIGspKSB7XHJcbiAgICAgIHZhciBrZXkgPSBTdHJpbmcoayk7XHJcblxyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXNba2V5XSkgPT09IHRydWUpIHtcclxuICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZXNba2V5XS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPT09IHRydWUgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByZXBhcmVEYXRhRm9yVmFsaWRhdGlvbih2YWx1ZSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09ICcnID8gdmFsdWUgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZXNba2V5XSkpIHtcclxuICAgICAgICBkYXRhW2tleV0gPSBwcmVwYXJlRGF0YUZvclZhbGlkYXRpb24odmFsdWVzW2tleV0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRhdGFba2V5XSA9IHZhbHVlc1trZXldICE9PSAnJyA/IHZhbHVlc1trZXldIDogdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZGF0YTtcclxufVxyXG4vKipcclxuICogZGVlcG1lcmdlIGFycmF5IG1lcmdpbmcgYWxnb3JpdGhtXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9LeWxlQU1hdGhld3MvZGVlcG1lcmdlI2NvbWJpbmUtYXJyYXlcclxuICovXHJcblxyXG5mdW5jdGlvbiBhcnJheU1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XHJcbiAgdmFyIGRlc3RpbmF0aW9uID0gdGFyZ2V0LnNsaWNlKCk7XHJcbiAgc291cmNlLmZvckVhY2goZnVuY3Rpb24gbWVyZ2UoZSwgaSkge1xyXG4gICAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbltpXSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgdmFyIGNsb25lUmVxdWVzdGVkID0gb3B0aW9ucy5jbG9uZSAhPT0gZmFsc2U7XHJcbiAgICAgIHZhciBzaG91bGRDbG9uZSA9IGNsb25lUmVxdWVzdGVkICYmIG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QoZSk7XHJcbiAgICAgIGRlc3RpbmF0aW9uW2ldID0gc2hvdWxkQ2xvbmUgPyBkZWVwbWVyZ2UoQXJyYXkuaXNBcnJheShlKSA/IFtdIDoge30sIGUsIG9wdGlvbnMpIDogZTtcclxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdChlKSkge1xyXG4gICAgICBkZXN0aW5hdGlvbltpXSA9IGRlZXBtZXJnZSh0YXJnZXRbaV0sIGUsIG9wdGlvbnMpO1xyXG4gICAgfSBlbHNlIGlmICh0YXJnZXQuaW5kZXhPZihlKSA9PT0gLTEpIHtcclxuICAgICAgZGVzdGluYXRpb24ucHVzaChlKTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gZGVzdGluYXRpb247XHJcbn1cclxuLyoqIFJldHVybiBtdWx0aSBzZWxlY3QgdmFsdWVzIGJhc2VkIG9uIGFuIGFycmF5IG9mIG9wdGlvbnMgKi9cclxuXHJcblxyXG5mdW5jdGlvbiBnZXRTZWxlY3RlZFZhbHVlcyhvcHRpb25zKSB7XHJcbiAgcmV0dXJuIEFycmF5LmZyb20ob3B0aW9ucykuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xyXG4gICAgcmV0dXJuIGVsLnNlbGVjdGVkO1xyXG4gIH0pLm1hcChmdW5jdGlvbiAoZWwpIHtcclxuICAgIHJldHVybiBlbC52YWx1ZTtcclxuICB9KTtcclxufVxyXG4vKiogUmV0dXJuIHRoZSBuZXh0IHZhbHVlIGZvciBhIGNoZWNrYm94ICovXHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0VmFsdWVGb3JDaGVja2JveChjdXJyZW50VmFsdWUsIGNoZWNrZWQsIHZhbHVlUHJvcCkge1xyXG4gIC8vIElmIHRoZSBjdXJyZW50IHZhbHVlIHdhcyBhIGJvb2xlYW4sIHJldHVybiBhIGJvb2xlYW5cclxuICBpZiAodHlwZW9mIGN1cnJlbnRWYWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICByZXR1cm4gQm9vbGVhbihjaGVja2VkKTtcclxuICB9IC8vIElmIHRoZSBjdXJyZW50VmFsdWUgd2FzIG5vdCBhIGJvb2xlYW4gd2Ugd2FudCB0byByZXR1cm4gYW4gYXJyYXlcclxuXHJcblxyXG4gIHZhciBjdXJyZW50QXJyYXlPZlZhbHVlcyA9IFtdO1xyXG4gIHZhciBpc1ZhbHVlSW5BcnJheSA9IGZhbHNlO1xyXG4gIHZhciBpbmRleCA9IC0xO1xyXG5cclxuICBpZiAoIUFycmF5LmlzQXJyYXkoY3VycmVudFZhbHVlKSkge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxyXG4gICAgaWYgKCF2YWx1ZVByb3AgfHwgdmFsdWVQcm9wID09ICd0cnVlJyB8fCB2YWx1ZVByb3AgPT0gJ2ZhbHNlJykge1xyXG4gICAgICByZXR1cm4gQm9vbGVhbihjaGVja2VkKTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgLy8gSWYgdGhlIGN1cnJlbnQgdmFsdWUgaXMgYWxyZWFkeSBhbiBhcnJheSwgdXNlIGl0XHJcbiAgICBjdXJyZW50QXJyYXlPZlZhbHVlcyA9IGN1cnJlbnRWYWx1ZTtcclxuICAgIGluZGV4ID0gY3VycmVudFZhbHVlLmluZGV4T2YodmFsdWVQcm9wKTtcclxuICAgIGlzVmFsdWVJbkFycmF5ID0gaW5kZXggPj0gMDtcclxuICB9IC8vIElmIHRoZSBjaGVja2JveCB3YXMgY2hlY2tlZCBhbmQgdGhlIHZhbHVlIGlzIG5vdCBhbHJlYWR5IHByZXNlbnQgaW4gdGhlIGFyYXkgd2Ugd2FudCB0byBhZGQgdGhlIG5ldyB2YWx1ZSB0byB0aGUgYXJyYXkgb2YgdmFsdWVzXHJcblxyXG5cclxuICBpZiAoY2hlY2tlZCAmJiB2YWx1ZVByb3AgJiYgIWlzVmFsdWVJbkFycmF5KSB7XHJcbiAgICByZXR1cm4gY3VycmVudEFycmF5T2ZWYWx1ZXMuY29uY2F0KHZhbHVlUHJvcCk7XHJcbiAgfSAvLyBJZiB0aGUgY2hlY2tib3ggd2FzIHVuY2hlY2tlZCBhbmQgdGhlIHZhbHVlIGlzIG5vdCBpbiB0aGUgYXJyYXksIHNpbXBseSByZXR1cm4gdGhlIGFscmVhZHkgZXhpc3RpbmcgYXJyYXkgb2YgdmFsdWVzXHJcblxyXG5cclxuICBpZiAoIWlzVmFsdWVJbkFycmF5KSB7XHJcbiAgICByZXR1cm4gY3VycmVudEFycmF5T2ZWYWx1ZXM7XHJcbiAgfSAvLyBJZiB0aGUgY2hlY2tib3ggd2FzIHVuY2hlY2tlZCBhbmQgdGhlIHZhbHVlIGlzIGluIHRoZSBhcnJheSwgcmVtb3ZlIHRoZSB2YWx1ZSBhbmQgcmV0dXJuIHRoZSBhcnJheVxyXG5cclxuXHJcbiAgcmV0dXJuIGN1cnJlbnRBcnJheU9mVmFsdWVzLnNsaWNlKDAsIGluZGV4KS5jb25jYXQoY3VycmVudEFycmF5T2ZWYWx1ZXMuc2xpY2UoaW5kZXggKyAxKSk7XHJcbn0gLy8gUmVhY3QgY3VycmVudGx5IHRocm93cyBhIHdhcm5pbmcgd2hlbiB1c2luZyB1c2VMYXlvdXRFZmZlY3Qgb24gdGhlIHNlcnZlci5cclxuLy8gVG8gZ2V0IGFyb3VuZCBpdCwgd2UgY2FuIGNvbmRpdGlvbmFsbHkgdXNlRWZmZWN0IG9uIHRoZSBzZXJ2ZXIgKG5vLW9wKSBhbmRcclxuLy8gdXNlTGF5b3V0RWZmZWN0IGluIHRoZSBicm93c2VyLlxyXG4vLyBAc2VlIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2dhZWFyb24vZTdkOTdjZGYzOGEyOTA3OTI0ZWExMmU0ZWJkZjNjODVcclxuXHJcblxyXG52YXIgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XHJcblxyXG5mdW5jdGlvbiB1c2VFdmVudENhbGxiYWNrKGZuKSB7XHJcbiAgdmFyIHJlZiA9IHVzZVJlZihmbik7IC8vIHdlIGNvcHkgYSByZWYgdG8gdGhlIGNhbGxiYWNrIHNjb3BlZCB0byB0aGUgY3VycmVudCBzdGF0ZS9wcm9wcyBvbiBlYWNoIHJlbmRlclxyXG5cclxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgIHJlZi5jdXJyZW50ID0gZm47XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcclxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xyXG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZWYuY3VycmVudC5hcHBseSh2b2lkIDAsIGFyZ3MpO1xyXG4gIH0sIFtdKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdXNlRmllbGQocHJvcHNPckZpZWxkTmFtZSkge1xyXG4gIHZhciBmb3JtaWsgPSB1c2VGb3JtaWtDb250ZXh0KCk7XHJcbiAgdmFyIGdldEZpZWxkUHJvcHMgPSBmb3JtaWsuZ2V0RmllbGRQcm9wcyxcclxuICAgICAgZ2V0RmllbGRNZXRhID0gZm9ybWlrLmdldEZpZWxkTWV0YSxcclxuICAgICAgZ2V0RmllbGRIZWxwZXJzID0gZm9ybWlrLmdldEZpZWxkSGVscGVycyxcclxuICAgICAgcmVnaXN0ZXJGaWVsZCA9IGZvcm1pay5yZWdpc3RlckZpZWxkLFxyXG4gICAgICB1bnJlZ2lzdGVyRmllbGQgPSBmb3JtaWsudW5yZWdpc3RlckZpZWxkO1xyXG4gIHZhciBpc0FuT2JqZWN0ID0gaXNPYmplY3QocHJvcHNPckZpZWxkTmFtZSk7IC8vIE5vcm1hbGl6ZSBwcm9wc09yRmllbGROYW1lIHRvIEZpZWxkSG9va0NvbmZpZzxWYWw+XHJcblxyXG4gIHZhciBwcm9wcyA9IGlzQW5PYmplY3QgPyBwcm9wc09yRmllbGROYW1lIDoge1xyXG4gICAgbmFtZTogcHJvcHNPckZpZWxkTmFtZVxyXG4gIH07XHJcbiAgdmFyIGZpZWxkTmFtZSA9IHByb3BzLm5hbWUsXHJcbiAgICAgIHZhbGlkYXRlRm4gPSBwcm9wcy52YWxpZGF0ZTtcclxuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKGZpZWxkTmFtZSkge1xyXG4gICAgICByZWdpc3RlckZpZWxkKGZpZWxkTmFtZSwge1xyXG4gICAgICAgIHZhbGlkYXRlOiB2YWxpZGF0ZUZuXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmIChmaWVsZE5hbWUpIHtcclxuICAgICAgICB1bnJlZ2lzdGVyRmllbGQoZmllbGROYW1lKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9LCBbcmVnaXN0ZXJGaWVsZCwgdW5yZWdpc3RlckZpZWxkLCBmaWVsZE5hbWUsIHZhbGlkYXRlRm5dKTtcclxuXHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgIWZvcm1payA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ3VzZUZpZWxkKCkgLyA8RmllbGQgLz4gbXVzdCBiZSB1c2VkIHVuZGVybmVhdGggYSA8Rm9ybWlrPiBjb21wb25lbnQgb3Igd2l0aEZvcm1paygpIGhpZ2hlciBvcmRlciBjb21wb25lbnQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XHJcbiAgfVxyXG5cclxuICAhZmllbGROYW1lID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCBmaWVsZCBuYW1lLiBFaXRoZXIgcGFzcyBgdXNlRmllbGRgIGEgc3RyaW5nIG9yIGFuIG9iamVjdCBjb250YWluaW5nIGEgYG5hbWVgIGtleS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XHJcbiAgdmFyIGZpZWxkSGVscGVycyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGdldEZpZWxkSGVscGVycyhmaWVsZE5hbWUpO1xyXG4gIH0sIFtnZXRGaWVsZEhlbHBlcnMsIGZpZWxkTmFtZV0pO1xyXG4gIHJldHVybiBbZ2V0RmllbGRQcm9wcyhwcm9wcyksIGdldEZpZWxkTWV0YShmaWVsZE5hbWUpLCBmaWVsZEhlbHBlcnNdO1xyXG59XHJcbmZ1bmN0aW9uIEZpZWxkKF9yZWYpIHtcclxuICB2YXIgdmFsaWRhdGUgPSBfcmVmLnZhbGlkYXRlLFxyXG4gICAgICBuYW1lID0gX3JlZi5uYW1lLFxyXG4gICAgICByZW5kZXIgPSBfcmVmLnJlbmRlcixcclxuICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxyXG4gICAgICBpcyA9IF9yZWYuYXMsXHJcbiAgICAgIGNvbXBvbmVudCA9IF9yZWYuY29tcG9uZW50LFxyXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcclxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBbXCJ2YWxpZGF0ZVwiLCBcIm5hbWVcIiwgXCJyZW5kZXJcIiwgXCJjaGlsZHJlblwiLCBcImFzXCIsIFwiY29tcG9uZW50XCIsIFwiY2xhc3NOYW1lXCJdKTtcclxuXHJcbiAgdmFyIF91c2VGb3JtaWtDb250ZXh0ID0gdXNlRm9ybWlrQ29udGV4dCgpLFxyXG4gICAgICBmb3JtaWsgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdXNlRm9ybWlrQ29udGV4dCwgW1widmFsaWRhdGVcIiwgXCJ2YWxpZGF0aW9uU2NoZW1hXCJdKTtcclxuXHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXHJcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAhIXJlbmRlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCI8RmllbGQgcmVuZGVyPiBoYXMgYmVlbiBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHZlcnNpb25zIG9mIEZvcm1pay4gUGxlYXNlIHVzZSBhIGNoaWxkIGNhbGxiYWNrIGZ1bmN0aW9uIGluc3RlYWQuIFRvIGdldCByaWQgb2YgdGhpcyB3YXJuaW5nLCByZXBsYWNlIDxGaWVsZCBuYW1lPVxcXCJcIiArIG5hbWUgKyBcIlxcXCIgcmVuZGVyPXsoe2ZpZWxkLCBmb3JtfSkgPT4gLi4ufSAvPiB3aXRoIDxGaWVsZCBuYW1lPVxcXCJcIiArIG5hbWUgKyBcIlxcXCI+eyh7ZmllbGQsIGZvcm0sIG1ldGF9KSA9PiAuLi59PC9GaWVsZD5cIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xyXG4gICAgICAhIShpcyAmJiBjaGlsZHJlbiAmJiBpc0Z1bmN0aW9uKGNoaWxkcmVuKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdZb3Ugc2hvdWxkIG5vdCB1c2UgPEZpZWxkIGFzPiBhbmQgPEZpZWxkIGNoaWxkcmVuPiBhcyBhIGZ1bmN0aW9uIGluIHRoZSBzYW1lIDxGaWVsZD4gY29tcG9uZW50OyA8RmllbGQgYXM+IHdpbGwgYmUgaWdub3JlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XHJcbiAgICAgICEhKGNvbXBvbmVudCAmJiBjaGlsZHJlbiAmJiBpc0Z1bmN0aW9uKGNoaWxkcmVuKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdZb3Ugc2hvdWxkIG5vdCB1c2UgPEZpZWxkIGNvbXBvbmVudD4gYW5kIDxGaWVsZCBjaGlsZHJlbj4gYXMgYSBmdW5jdGlvbiBpbiB0aGUgc2FtZSA8RmllbGQ+IGNvbXBvbmVudDsgPEZpZWxkIGNvbXBvbmVudD4gd2lsbCBiZSBpZ25vcmVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcclxuICAgICAgISEocmVuZGVyICYmIGNoaWxkcmVuICYmICFpc0VtcHR5Q2hpbGRyZW4oY2hpbGRyZW4pKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1lvdSBzaG91bGQgbm90IHVzZSA8RmllbGQgcmVuZGVyPiBhbmQgPEZpZWxkIGNoaWxkcmVuPiBpbiB0aGUgc2FtZSA8RmllbGQ+IGNvbXBvbmVudDsgPEZpZWxkIGNoaWxkcmVuPiB3aWxsIGJlIGlnbm9yZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG4gICAgfSwgW10pO1xyXG4gIH0gLy8gUmVnaXN0ZXIgZmllbGQgYW5kIGZpZWxkLWxldmVsIHZhbGlkYXRpb24gd2l0aCBwYXJlbnQgPEZvcm1paz5cclxuXHJcblxyXG4gIHZhciByZWdpc3RlckZpZWxkID0gZm9ybWlrLnJlZ2lzdGVyRmllbGQsXHJcbiAgICAgIHVucmVnaXN0ZXJGaWVsZCA9IGZvcm1pay51bnJlZ2lzdGVyRmllbGQ7XHJcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgIHJlZ2lzdGVyRmllbGQobmFtZSwge1xyXG4gICAgICB2YWxpZGF0ZTogdmFsaWRhdGVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgdW5yZWdpc3RlckZpZWxkKG5hbWUpO1xyXG4gICAgfTtcclxuICB9LCBbcmVnaXN0ZXJGaWVsZCwgdW5yZWdpc3RlckZpZWxkLCBuYW1lLCB2YWxpZGF0ZV0pO1xyXG4gIHZhciBmaWVsZCA9IGZvcm1pay5nZXRGaWVsZFByb3BzKF9leHRlbmRzKHtcclxuICAgIG5hbWU6IG5hbWVcclxuICB9LCBwcm9wcykpO1xyXG4gIHZhciBtZXRhID0gZm9ybWlrLmdldEZpZWxkTWV0YShuYW1lKTtcclxuICB2YXIgbGVnYWN5QmFnID0ge1xyXG4gICAgZmllbGQ6IGZpZWxkLFxyXG4gICAgZm9ybTogZm9ybWlrXHJcbiAgfTtcclxuXHJcbiAgaWYgKHJlbmRlcikge1xyXG4gICAgcmV0dXJuIHJlbmRlcihfZXh0ZW5kcyh7fSwgbGVnYWN5QmFnLCB7XHJcbiAgICAgIG1ldGE6IG1ldGFcclxuICAgIH0pKTtcclxuICB9XHJcblxyXG4gIGlmIChpc0Z1bmN0aW9uKGNoaWxkcmVuKSkge1xyXG4gICAgcmV0dXJuIGNoaWxkcmVuKF9leHRlbmRzKHt9LCBsZWdhY3lCYWcsIHtcclxuICAgICAgbWV0YTogbWV0YVxyXG4gICAgfSkpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGNvbXBvbmVudCkge1xyXG4gICAgLy8gVGhpcyBiZWhhdmlvciBpcyBiYWNrd2FyZHMgY29tcGF0IHdpdGggZWFybGllciBGb3JtaWsgMC45IHRvIDEueFxyXG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHZhciBpbm5lclJlZiA9IHByb3BzLmlubmVyUmVmLFxyXG4gICAgICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBbXCJpbm5lclJlZlwiXSk7XHJcblxyXG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChjb21wb25lbnQsIF9leHRlbmRzKHtcclxuICAgICAgICByZWY6IGlubmVyUmVmXHJcbiAgICAgIH0sIGZpZWxkLCByZXN0LCB7XHJcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcclxuICAgICAgfSksIGNoaWxkcmVuKTtcclxuICAgIH0gLy8gV2UgZG9uJ3QgcGFzcyBgbWV0YWAgZm9yIGJhY2t3YXJkcyBjb21wYXRcclxuXHJcblxyXG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBfZXh0ZW5kcyh7XHJcbiAgICAgIGZpZWxkOiBmaWVsZCxcclxuICAgICAgZm9ybTogZm9ybWlrXHJcbiAgICB9LCBwcm9wcywge1xyXG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxyXG4gICAgfSksIGNoaWxkcmVuKTtcclxuICB9IC8vIGRlZmF1bHQgdG8gaW5wdXQgaGVyZSBzbyB3ZSBjYW4gY2hlY2sgZm9yIGJvdGggYGFzYCBhbmQgYGNoaWxkcmVuYCBhYm92ZVxyXG5cclxuXHJcbiAgdmFyIGFzRWxlbWVudCA9IGlzIHx8ICdpbnB1dCc7XHJcblxyXG4gIGlmICh0eXBlb2YgYXNFbGVtZW50ID09PSAnc3RyaW5nJykge1xyXG4gICAgdmFyIF9pbm5lclJlZiA9IHByb3BzLmlubmVyUmVmLFxyXG4gICAgICAgIF9yZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIFtcImlubmVyUmVmXCJdKTtcclxuXHJcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChhc0VsZW1lbnQsIF9leHRlbmRzKHtcclxuICAgICAgcmVmOiBfaW5uZXJSZWZcclxuICAgIH0sIGZpZWxkLCBfcmVzdCwge1xyXG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxyXG4gICAgfSksIGNoaWxkcmVuKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBjcmVhdGVFbGVtZW50KGFzRWxlbWVudCwgX2V4dGVuZHMoe30sIGZpZWxkLCBwcm9wcywge1xyXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcclxuICB9KSwgY2hpbGRyZW4pO1xyXG59XHJcblxyXG52YXIgRm9ybSA9IC8qI19fUFVSRV9fKi9mb3J3YXJkUmVmKGZ1bmN0aW9uIChwcm9wcywgcmVmKSB7XHJcbiAgLy8gaU9TIG5lZWRzIGFuIFwiYWN0aW9uXCIgYXR0cmlidXRlIGZvciBuaWNlIGlucHV0OiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk0ODUxNjIvNDA2NzI1XHJcbiAgLy8gV2UgZGVmYXVsdCB0aGUgYWN0aW9uIHRvIFwiI1wiIGluIGNhc2UgdGhlIHByZXZlbnREZWZhdWx0IGZhaWxzIChqdXN0IHVwZGF0ZXMgdGhlIFVSTCBoYXNoKVxyXG4gIHZhciBhY3Rpb24gPSBwcm9wcy5hY3Rpb24sXHJcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgW1wiYWN0aW9uXCJdKTtcclxuXHJcbiAgdmFyIF9hY3Rpb24gPSBhY3Rpb24gIT0gbnVsbCA/IGFjdGlvbiA6ICcjJztcclxuXHJcbiAgdmFyIF91c2VGb3JtaWtDb250ZXh0ID0gdXNlRm9ybWlrQ29udGV4dCgpLFxyXG4gICAgICBoYW5kbGVSZXNldCA9IF91c2VGb3JtaWtDb250ZXh0LmhhbmRsZVJlc2V0LFxyXG4gICAgICBoYW5kbGVTdWJtaXQgPSBfdXNlRm9ybWlrQ29udGV4dC5oYW5kbGVTdWJtaXQ7XHJcblxyXG4gIHJldHVybiBjcmVhdGVFbGVtZW50KFwiZm9ybVwiLCBfZXh0ZW5kcyh7XHJcbiAgICBvblN1Ym1pdDogaGFuZGxlU3VibWl0LFxyXG4gICAgcmVmOiByZWYsXHJcbiAgICBvblJlc2V0OiBoYW5kbGVSZXNldCxcclxuICAgIGFjdGlvbjogX2FjdGlvblxyXG4gIH0sIHJlc3QpKTtcclxufSk7XHJcbkZvcm0uZGlzcGxheU5hbWUgPSAnRm9ybSc7XHJcblxyXG4vKipcclxuICogQSBwdWJsaWMgaGlnaGVyLW9yZGVyIGNvbXBvbmVudCB0byBhY2Nlc3MgdGhlIGltcGVyYXRpdmUgQVBJXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gd2l0aEZvcm1payhfcmVmKSB7XHJcbiAgdmFyIF9yZWYkbWFwUHJvcHNUb1ZhbHVlcyA9IF9yZWYubWFwUHJvcHNUb1ZhbHVlcyxcclxuICAgICAgbWFwUHJvcHNUb1ZhbHVlcyA9IF9yZWYkbWFwUHJvcHNUb1ZhbHVlcyA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKHZhbmlsbGFQcm9wcykge1xyXG4gICAgdmFyIHZhbCA9IHt9O1xyXG5cclxuICAgIGZvciAodmFyIGsgaW4gdmFuaWxsYVByb3BzKSB7XHJcbiAgICAgIGlmICh2YW5pbGxhUHJvcHMuaGFzT3duUHJvcGVydHkoaykgJiYgdHlwZW9mIHZhbmlsbGFQcm9wc1trXSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIC8vIEB0b2RvIFR5cGVTY3JpcHQgZml4XHJcbiAgICAgICAgdmFsW2tdID0gdmFuaWxsYVByb3BzW2tdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhbDtcclxuICB9IDogX3JlZiRtYXBQcm9wc1RvVmFsdWVzLFxyXG4gICAgICBjb25maWcgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBbXCJtYXBQcm9wc1RvVmFsdWVzXCJdKTtcclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUZvcm1payhDb21wb25lbnQkMSkge1xyXG4gICAgdmFyIGNvbXBvbmVudERpc3BsYXlOYW1lID0gQ29tcG9uZW50JDEuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50JDEubmFtZSB8fCBDb21wb25lbnQkMS5jb25zdHJ1Y3RvciAmJiBDb21wb25lbnQkMS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdDb21wb25lbnQnO1xyXG4gICAgLyoqXHJcbiAgICAgKiBXZSBuZWVkIHRvIHVzZSBjbG9zdXJlcyBoZXJlIGZvciB0byBwcm92aWRlIHRoZSB3cmFwcGVkIGNvbXBvbmVudCdzIHByb3BzIHRvXHJcbiAgICAgKiB0aGUgcmVzcGVjdGl2ZSB3aXRoRm9ybWlrIGNvbmZpZyBtZXRob2RzLlxyXG4gICAgICovXHJcblxyXG4gICAgdmFyIEMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcclxuICAgICAgX2luaGVyaXRzTG9vc2UoQywgX1JlYWN0JENvbXBvbmVudCk7XHJcblxyXG4gICAgICBmdW5jdGlvbiBDKCkge1xyXG4gICAgICAgIHZhciBfdGhpcztcclxuXHJcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XHJcbiAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkgfHwgdGhpcztcclxuXHJcbiAgICAgICAgX3RoaXMudmFsaWRhdGUgPSBmdW5jdGlvbiAodmFsdWVzKSB7XHJcbiAgICAgICAgICByZXR1cm4gY29uZmlnLnZhbGlkYXRlKHZhbHVlcywgX3RoaXMucHJvcHMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIF90aGlzLnZhbGlkYXRpb25TY2hlbWEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihjb25maWcudmFsaWRhdGlvblNjaGVtYSkgPyBjb25maWcudmFsaWRhdGlvblNjaGVtYShfdGhpcy5wcm9wcykgOiBjb25maWcudmFsaWRhdGlvblNjaGVtYTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBfdGhpcy5oYW5kbGVTdWJtaXQgPSBmdW5jdGlvbiAodmFsdWVzLCBhY3Rpb25zKSB7XHJcbiAgICAgICAgICByZXR1cm4gY29uZmlnLmhhbmRsZVN1Ym1pdCh2YWx1ZXMsIF9leHRlbmRzKHt9LCBhY3Rpb25zLCB7XHJcbiAgICAgICAgICAgIHByb3BzOiBfdGhpcy5wcm9wc1xyXG4gICAgICAgICAgfSkpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIF90aGlzLnJlbmRlckZvcm1Db21wb25lbnQgPSBmdW5jdGlvbiAoZm9ybWlrUHJvcHMpIHtcclxuICAgICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KENvbXBvbmVudCQxLCBfZXh0ZW5kcyh7fSwgX3RoaXMucHJvcHMsIGZvcm1pa1Byb3BzKSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgX3Byb3RvID0gQy5wcm90b3R5cGU7XHJcblxyXG4gICAgICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMsIFtcImNoaWxkcmVuXCJdKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoRm9ybWlrLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIGNvbmZpZywge1xyXG4gICAgICAgICAgdmFsaWRhdGU6IGNvbmZpZy52YWxpZGF0ZSAmJiB0aGlzLnZhbGlkYXRlLFxyXG4gICAgICAgICAgdmFsaWRhdGlvblNjaGVtYTogY29uZmlnLnZhbGlkYXRpb25TY2hlbWEgJiYgdGhpcy52YWxpZGF0aW9uU2NoZW1hLFxyXG4gICAgICAgICAgaW5pdGlhbFZhbHVlczogbWFwUHJvcHNUb1ZhbHVlcyh0aGlzLnByb3BzKSxcclxuICAgICAgICAgIGluaXRpYWxTdGF0dXM6IGNvbmZpZy5tYXBQcm9wc1RvU3RhdHVzICYmIGNvbmZpZy5tYXBQcm9wc1RvU3RhdHVzKHRoaXMucHJvcHMpLFxyXG4gICAgICAgICAgaW5pdGlhbEVycm9yczogY29uZmlnLm1hcFByb3BzVG9FcnJvcnMgJiYgY29uZmlnLm1hcFByb3BzVG9FcnJvcnModGhpcy5wcm9wcyksXHJcbiAgICAgICAgICBpbml0aWFsVG91Y2hlZDogY29uZmlnLm1hcFByb3BzVG9Ub3VjaGVkICYmIGNvbmZpZy5tYXBQcm9wc1RvVG91Y2hlZCh0aGlzLnByb3BzKSxcclxuICAgICAgICAgIG9uU3VibWl0OiB0aGlzLmhhbmRsZVN1Ym1pdCxcclxuICAgICAgICAgIGNoaWxkcmVuOiB0aGlzLnJlbmRlckZvcm1Db21wb25lbnRcclxuICAgICAgICB9KSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICByZXR1cm4gQztcclxuICAgIH0oQ29tcG9uZW50KTtcclxuXHJcbiAgICBDLmRpc3BsYXlOYW1lID0gXCJXaXRoRm9ybWlrKFwiICsgY29tcG9uZW50RGlzcGxheU5hbWUgKyBcIilcIjtcclxuICAgIHJldHVybiBob2lzdE5vblJlYWN0U3RhdGljcyhDLCBDb21wb25lbnQkMSAvLyBjYXN0IHR5cGUgdG8gQ29tcG9uZW50Q2xhc3MgKGV2ZW4gaWYgU0ZDKVxyXG4gICAgKTtcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogQ29ubmVjdCBhbnkgY29tcG9uZW50IHRvIEZvcm1payBjb250ZXh0LCBhbmQgaW5qZWN0IGFzIGEgcHJvcCBjYWxsZWQgYGZvcm1pa2A7XHJcbiAqIEBwYXJhbSBDb21wIFJlYWN0IENvbXBvbmVudFxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGNvbm5lY3QoQ29tcCkge1xyXG4gIHZhciBDID0gZnVuY3Rpb24gQyhwcm9wcykge1xyXG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoRm9ybWlrQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChmb3JtaWspIHtcclxuICAgICAgISEhZm9ybWlrID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIkZvcm1payBjb250ZXh0IGlzIHVuZGVmaW5lZCwgcGxlYXNlIHZlcmlmeSB5b3UgYXJlIHJlbmRlcmluZyA8Rm9ybT4sIDxGaWVsZD4sIDxGYXN0RmllbGQ+LCA8RmllbGRBcnJheT4sIG9yIHlvdXIgY3VzdG9tIGNvbnRleHQtdXNpbmcgY29tcG9uZW50IGFzIGEgY2hpbGQgb2YgYSA8Rm9ybWlrPiBjb21wb25lbnQuIENvbXBvbmVudCBuYW1lOiBcIiArIENvbXAubmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xyXG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChDb21wLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcclxuICAgICAgICBmb3JtaWs6IGZvcm1pa1xyXG4gICAgICB9KSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICB2YXIgY29tcG9uZW50RGlzcGxheU5hbWUgPSBDb21wLmRpc3BsYXlOYW1lIHx8IENvbXAubmFtZSB8fCBDb21wLmNvbnN0cnVjdG9yICYmIENvbXAuY29uc3RydWN0b3IubmFtZSB8fCAnQ29tcG9uZW50JzsgLy8gQXNzaWduIENvbXAgdG8gQy5XcmFwcGVkQ29tcG9uZW50IHNvIHdlIGNhbiBhY2Nlc3MgdGhlIGlubmVyIGNvbXBvbmVudCBpbiB0ZXN0c1xyXG4gIC8vIEZvciBleGFtcGxlLCA8RmllbGQuV3JhcHBlZENvbXBvbmVudCAvPiBnZXRzIHVzIDxGaWVsZElubmVyLz5cclxuXHJcbiAgQy5XcmFwcGVkQ29tcG9uZW50ID0gQ29tcDtcclxuICBDLmRpc3BsYXlOYW1lID0gXCJGb3JtaWtDb25uZWN0KFwiICsgY29tcG9uZW50RGlzcGxheU5hbWUgKyBcIilcIjtcclxuICByZXR1cm4gaG9pc3ROb25SZWFjdFN0YXRpY3MoQywgQ29tcCAvLyBjYXN0IHR5cGUgdG8gQ29tcG9uZW50Q2xhc3MgKGV2ZW4gaWYgU0ZDKVxyXG4gICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTb21lIGFycmF5IGhlbHBlcnMhXHJcbiAqL1xyXG5cclxudmFyIG1vdmUgPSBmdW5jdGlvbiBtb3ZlKGFycmF5LCBmcm9tLCB0bykge1xyXG4gIHZhciBjb3B5ID0gY29weUFycmF5TGlrZShhcnJheSk7XHJcbiAgdmFyIHZhbHVlID0gY29weVtmcm9tXTtcclxuICBjb3B5LnNwbGljZShmcm9tLCAxKTtcclxuICBjb3B5LnNwbGljZSh0bywgMCwgdmFsdWUpO1xyXG4gIHJldHVybiBjb3B5O1xyXG59O1xyXG52YXIgc3dhcCA9IGZ1bmN0aW9uIHN3YXAoYXJyYXlMaWtlLCBpbmRleEEsIGluZGV4Qikge1xyXG4gIHZhciBjb3B5ID0gY29weUFycmF5TGlrZShhcnJheUxpa2UpO1xyXG4gIHZhciBhID0gY29weVtpbmRleEFdO1xyXG4gIGNvcHlbaW5kZXhBXSA9IGNvcHlbaW5kZXhCXTtcclxuICBjb3B5W2luZGV4Ql0gPSBhO1xyXG4gIHJldHVybiBjb3B5O1xyXG59O1xyXG52YXIgaW5zZXJ0ID0gZnVuY3Rpb24gaW5zZXJ0KGFycmF5TGlrZSwgaW5kZXgsIHZhbHVlKSB7XHJcbiAgdmFyIGNvcHkgPSBjb3B5QXJyYXlMaWtlKGFycmF5TGlrZSk7XHJcbiAgY29weS5zcGxpY2UoaW5kZXgsIDAsIHZhbHVlKTtcclxuICByZXR1cm4gY29weTtcclxufTtcclxudmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKGFycmF5TGlrZSwgaW5kZXgsIHZhbHVlKSB7XHJcbiAgdmFyIGNvcHkgPSBjb3B5QXJyYXlMaWtlKGFycmF5TGlrZSk7XHJcbiAgY29weVtpbmRleF0gPSB2YWx1ZTtcclxuICByZXR1cm4gY29weTtcclxufTtcclxuXHJcbnZhciBjb3B5QXJyYXlMaWtlID0gZnVuY3Rpb24gY29weUFycmF5TGlrZShhcnJheUxpa2UpIHtcclxuICBpZiAoIWFycmF5TGlrZSkge1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcnJheUxpa2UpKSB7XHJcbiAgICByZXR1cm4gW10uY29uY2F0KGFycmF5TGlrZSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciBtYXhJbmRleCA9IE9iamVjdC5rZXlzKGFycmF5TGlrZSkubWFwKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgcmV0dXJuIHBhcnNlSW50KGtleSk7XHJcbiAgICB9KS5yZWR1Y2UoZnVuY3Rpb24gKG1heCwgZWwpIHtcclxuICAgICAgcmV0dXJuIGVsID4gbWF4ID8gZWwgOiBtYXg7XHJcbiAgICB9LCAwKTtcclxuICAgIHJldHVybiBBcnJheS5mcm9tKF9leHRlbmRzKHt9LCBhcnJheUxpa2UsIHtcclxuICAgICAgbGVuZ3RoOiBtYXhJbmRleCArIDFcclxuICAgIH0pKTtcclxuICB9XHJcbn07XHJcblxyXG52YXIgY3JlYXRlQWx0ZXJhdGlvbkhhbmRsZXIgPSBmdW5jdGlvbiBjcmVhdGVBbHRlcmF0aW9uSGFuZGxlcihhbHRlcmF0aW9uLCBkZWZhdWx0RnVuY3Rpb24pIHtcclxuICB2YXIgZm4gPSB0eXBlb2YgYWx0ZXJhdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IGFsdGVyYXRpb24gOiBkZWZhdWx0RnVuY3Rpb247XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc09iamVjdChkYXRhKSkge1xyXG4gICAgICB2YXIgY2xvbmUgPSBjb3B5QXJyYXlMaWtlKGRhdGEpO1xyXG4gICAgICByZXR1cm4gZm4oY2xvbmUpO1xyXG4gICAgfSAvLyBUaGlzIGNhbiBiZSBhc3N1bWVkIHRvIGJlIGEgcHJpbWl0aXZlLCB3aGljaFxyXG4gICAgLy8gaXMgYSBjYXNlIGZvciB0b3AgbGV2ZWwgdmFsaWRhdGlvbiBlcnJvcnNcclxuXHJcblxyXG4gICAgcmV0dXJuIGRhdGE7XHJcbiAgfTtcclxufTtcclxuXHJcbnZhciBGaWVsZEFycmF5SW5uZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcclxuICBfaW5oZXJpdHNMb29zZShGaWVsZEFycmF5SW5uZXIsIF9SZWFjdCRDb21wb25lbnQpO1xyXG5cclxuICBmdW5jdGlvbiBGaWVsZEFycmF5SW5uZXIocHJvcHMpIHtcclxuICAgIHZhciBfdGhpcztcclxuXHJcbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpczsgLy8gV2UgbmVlZCBUeXBlU2NyaXB0IGdlbmVyaWNzIG9uIHRoZXNlLCBzbyB3ZSdsbCBiaW5kIHRoZW0gaW4gdGhlIGNvbnN0cnVjdG9yXHJcbiAgICAvLyBAdG9kbyBGaXggVFMgMy4yLjFcclxuXHJcbiAgICBfdGhpcy51cGRhdGVBcnJheUZpZWxkID0gZnVuY3Rpb24gKGZuLCBhbHRlclRvdWNoZWQsIGFsdGVyRXJyb3JzKSB7XHJcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxyXG4gICAgICAgICAgbmFtZSA9IF90aGlzJHByb3BzLm5hbWUsXHJcbiAgICAgICAgICBzZXRGb3JtaWtTdGF0ZSA9IF90aGlzJHByb3BzLmZvcm1pay5zZXRGb3JtaWtTdGF0ZTtcclxuICAgICAgc2V0Rm9ybWlrU3RhdGUoZnVuY3Rpb24gKHByZXZTdGF0ZSkge1xyXG4gICAgICAgIHZhciB1cGRhdGVFcnJvcnMgPSBjcmVhdGVBbHRlcmF0aW9uSGFuZGxlcihhbHRlckVycm9ycywgZm4pO1xyXG4gICAgICAgIHZhciB1cGRhdGVUb3VjaGVkID0gY3JlYXRlQWx0ZXJhdGlvbkhhbmRsZXIoYWx0ZXJUb3VjaGVkLCBmbik7IC8vIHZhbHVlcyBmbiBzaG91bGQgYmUgZXhlY3V0ZWQgYmVmb3JlIHVwZGF0ZUVycm9ycyBhbmQgdXBkYXRlVG91Y2hlZCxcclxuICAgICAgICAvLyBvdGhlcndpc2UgaXQgY2F1c2VzIGFuIGVycm9yIHdpdGggdW5zaGlmdC5cclxuXHJcbiAgICAgICAgdmFyIHZhbHVlcyA9IHNldEluKHByZXZTdGF0ZS52YWx1ZXMsIG5hbWUsIGZuKGdldEluKHByZXZTdGF0ZS52YWx1ZXMsIG5hbWUpKSk7XHJcbiAgICAgICAgdmFyIGZpZWxkRXJyb3IgPSBhbHRlckVycm9ycyA/IHVwZGF0ZUVycm9ycyhnZXRJbihwcmV2U3RhdGUuZXJyb3JzLCBuYW1lKSkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgdmFyIGZpZWxkVG91Y2hlZCA9IGFsdGVyVG91Y2hlZCA/IHVwZGF0ZVRvdWNoZWQoZ2V0SW4ocHJldlN0YXRlLnRvdWNoZWQsIG5hbWUpKSA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgaWYgKGlzRW1wdHlBcnJheShmaWVsZEVycm9yKSkge1xyXG4gICAgICAgICAgZmllbGRFcnJvciA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpc0VtcHR5QXJyYXkoZmllbGRUb3VjaGVkKSkge1xyXG4gICAgICAgICAgZmllbGRUb3VjaGVkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBwcmV2U3RhdGUsIHtcclxuICAgICAgICAgIHZhbHVlczogdmFsdWVzLFxyXG4gICAgICAgICAgZXJyb3JzOiBhbHRlckVycm9ycyA/IHNldEluKHByZXZTdGF0ZS5lcnJvcnMsIG5hbWUsIGZpZWxkRXJyb3IpIDogcHJldlN0YXRlLmVycm9ycyxcclxuICAgICAgICAgIHRvdWNoZWQ6IGFsdGVyVG91Y2hlZCA/IHNldEluKHByZXZTdGF0ZS50b3VjaGVkLCBuYW1lLCBmaWVsZFRvdWNoZWQpIDogcHJldlN0YXRlLnRvdWNoZWRcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF90aGlzLnB1c2ggPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgcmV0dXJuIF90aGlzLnVwZGF0ZUFycmF5RmllbGQoZnVuY3Rpb24gKGFycmF5TGlrZSkge1xyXG4gICAgICAgIHJldHVybiBbXS5jb25jYXQoY29weUFycmF5TGlrZShhcnJheUxpa2UpLCBbY2xvbmVEZWVwKHZhbHVlKV0pO1xyXG4gICAgICB9LCBmYWxzZSwgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfdGhpcy5oYW5kbGVQdXNoID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzLnB1c2godmFsdWUpO1xyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBfdGhpcy5zd2FwID0gZnVuY3Rpb24gKGluZGV4QSwgaW5kZXhCKSB7XHJcbiAgICAgIHJldHVybiBfdGhpcy51cGRhdGVBcnJheUZpZWxkKGZ1bmN0aW9uIChhcnJheSkge1xyXG4gICAgICAgIHJldHVybiBzd2FwKGFycmF5LCBpbmRleEEsIGluZGV4Qik7XHJcbiAgICAgIH0sIHRydWUsIHRydWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfdGhpcy5oYW5kbGVTd2FwID0gZnVuY3Rpb24gKGluZGV4QSwgaW5kZXhCKSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzLnN3YXAoaW5kZXhBLCBpbmRleEIpO1xyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBfdGhpcy5tb3ZlID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XHJcbiAgICAgIHJldHVybiBfdGhpcy51cGRhdGVBcnJheUZpZWxkKGZ1bmN0aW9uIChhcnJheSkge1xyXG4gICAgICAgIHJldHVybiBtb3ZlKGFycmF5LCBmcm9tLCB0byk7XHJcbiAgICAgIH0sIHRydWUsIHRydWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfdGhpcy5oYW5kbGVNb3ZlID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzLm1vdmUoZnJvbSwgdG8pO1xyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBfdGhpcy5pbnNlcnQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiBfdGhpcy51cGRhdGVBcnJheUZpZWxkKGZ1bmN0aW9uIChhcnJheSkge1xyXG4gICAgICAgIHJldHVybiBpbnNlcnQoYXJyYXksIGluZGV4LCB2YWx1ZSk7XHJcbiAgICAgIH0sIGZ1bmN0aW9uIChhcnJheSkge1xyXG4gICAgICAgIHJldHVybiBpbnNlcnQoYXJyYXksIGluZGV4LCBudWxsKTtcclxuICAgICAgfSwgZnVuY3Rpb24gKGFycmF5KSB7XHJcbiAgICAgICAgcmV0dXJuIGluc2VydChhcnJheSwgaW5kZXgsIG51bGwpO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgX3RoaXMuaGFuZGxlSW5zZXJ0ID0gZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfdGhpcy5pbnNlcnQoaW5kZXgsIHZhbHVlKTtcclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgX3RoaXMucmVwbGFjZSA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcclxuICAgICAgcmV0dXJuIF90aGlzLnVwZGF0ZUFycmF5RmllbGQoZnVuY3Rpb24gKGFycmF5KSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcGxhY2UoYXJyYXksIGluZGV4LCB2YWx1ZSk7XHJcbiAgICAgIH0sIGZhbHNlLCBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF90aGlzLmhhbmRsZVJlcGxhY2UgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzLnJlcGxhY2UoaW5kZXgsIHZhbHVlKTtcclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgX3RoaXMudW5zaGlmdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICB2YXIgbGVuZ3RoID0gLTE7XHJcblxyXG4gICAgICBfdGhpcy51cGRhdGVBcnJheUZpZWxkKGZ1bmN0aW9uIChhcnJheSkge1xyXG4gICAgICAgIHZhciBhcnIgPSBhcnJheSA/IFt2YWx1ZV0uY29uY2F0KGFycmF5KSA6IFt2YWx1ZV07XHJcbiAgICAgICAgbGVuZ3RoID0gYXJyLmxlbmd0aDtcclxuICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgICB9LCBmdW5jdGlvbiAoYXJyYXkpIHtcclxuICAgICAgICByZXR1cm4gYXJyYXkgPyBbbnVsbF0uY29uY2F0KGFycmF5KSA6IFtudWxsXTtcclxuICAgICAgfSwgZnVuY3Rpb24gKGFycmF5KSB7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5ID8gW251bGxdLmNvbmNhdChhcnJheSkgOiBbbnVsbF07XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIGxlbmd0aDtcclxuICAgIH07XHJcblxyXG4gICAgX3RoaXMuaGFuZGxlVW5zaGlmdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfdGhpcy51bnNoaWZ0KHZhbHVlKTtcclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgX3RoaXMuaGFuZGxlUmVtb3ZlID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzLnJlbW92ZShpbmRleCk7XHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIF90aGlzLmhhbmRsZVBvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3RoaXMucG9wKCk7XHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIF90aGlzLnJlbW92ZSA9IF90aGlzLnJlbW92ZS5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcclxuICAgIF90aGlzLnBvcCA9IF90aGlzLnBvcC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcclxuICAgIHJldHVybiBfdGhpcztcclxuICB9XHJcblxyXG4gIHZhciBfcHJvdG8gPSBGaWVsZEFycmF5SW5uZXIucHJvdG90eXBlO1xyXG5cclxuICBfcHJvdG8uY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xyXG4gICAgaWYgKHRoaXMucHJvcHMudmFsaWRhdGVPbkNoYW5nZSAmJiB0aGlzLnByb3BzLmZvcm1pay52YWxpZGF0ZU9uQ2hhbmdlICYmICFpc0VxdWFsKGdldEluKHByZXZQcm9wcy5mb3JtaWsudmFsdWVzLCBwcmV2UHJvcHMubmFtZSksIGdldEluKHRoaXMucHJvcHMuZm9ybWlrLnZhbHVlcywgdGhpcy5wcm9wcy5uYW1lKSkpIHtcclxuICAgICAgdGhpcy5wcm9wcy5mb3JtaWsudmFsaWRhdGVGb3JtKHRoaXMucHJvcHMuZm9ybWlrLnZhbHVlcyk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgX3Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShpbmRleCkge1xyXG4gICAgLy8gV2UgbmVlZCB0byBtYWtlIHN1cmUgd2UgYWxzbyByZW1vdmUgcmVsZXZhbnQgcGllY2VzIG9mIGB0b3VjaGVkYCBhbmQgYGVycm9yc2BcclxuICAgIHZhciByZXN1bHQ7XHJcbiAgICB0aGlzLnVwZGF0ZUFycmF5RmllbGQoIC8vIHNvIHRoaXMgZ2V0cyBjYWxsIDMgdGltZXNcclxuICAgIGZ1bmN0aW9uIChhcnJheSkge1xyXG4gICAgICB2YXIgY29weSA9IGFycmF5ID8gY29weUFycmF5TGlrZShhcnJheSkgOiBbXTtcclxuXHJcbiAgICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgICAgcmVzdWx0ID0gY29weVtpbmRleF07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpc0Z1bmN0aW9uKGNvcHkuc3BsaWNlKSkge1xyXG4gICAgICAgIGNvcHkuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgfSAvLyBpZiB0aGUgYXJyYXkgb25seSBpbmNsdWRlcyB1bmRlZmluZWQgdmFsdWVzIHdlIGhhdmUgdG8gcmV0dXJuIGFuIGVtcHR5IGFycmF5XHJcblxyXG5cclxuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oY29weS5ldmVyeSkgPyBjb3B5LmV2ZXJ5KGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZDtcclxuICAgICAgfSkgPyBbXSA6IGNvcHkgOiBjb3B5O1xyXG4gICAgfSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH07XHJcblxyXG4gIF9wcm90by5wb3AgPSBmdW5jdGlvbiBwb3AoKSB7XHJcbiAgICAvLyBSZW1vdmUgcmVsZXZhbnQgcGllY2VzIG9mIGB0b3VjaGVkYCBhbmQgYGVycm9yc2AgdG9vIVxyXG4gICAgdmFyIHJlc3VsdDtcclxuICAgIHRoaXMudXBkYXRlQXJyYXlGaWVsZCggLy8gc28gdGhpcyBnZXRzIGNhbGwgMyB0aW1lc1xyXG4gICAgZnVuY3Rpb24gKGFycmF5KSB7XHJcbiAgICAgIHZhciB0bXAgPSBhcnJheS5zbGljZSgpO1xyXG5cclxuICAgICAgaWYgKCFyZXN1bHQpIHtcclxuICAgICAgICByZXN1bHQgPSB0bXAgJiYgdG1wLnBvcCAmJiB0bXAucG9wKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0bXA7XHJcbiAgICB9LCB0cnVlLCB0cnVlKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfTtcclxuXHJcbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcclxuICAgIHZhciBhcnJheUhlbHBlcnMgPSB7XHJcbiAgICAgIHB1c2g6IHRoaXMucHVzaCxcclxuICAgICAgcG9wOiB0aGlzLnBvcCxcclxuICAgICAgc3dhcDogdGhpcy5zd2FwLFxyXG4gICAgICBtb3ZlOiB0aGlzLm1vdmUsXHJcbiAgICAgIGluc2VydDogdGhpcy5pbnNlcnQsXHJcbiAgICAgIHJlcGxhY2U6IHRoaXMucmVwbGFjZSxcclxuICAgICAgdW5zaGlmdDogdGhpcy51bnNoaWZ0LFxyXG4gICAgICByZW1vdmU6IHRoaXMucmVtb3ZlLFxyXG4gICAgICBoYW5kbGVQdXNoOiB0aGlzLmhhbmRsZVB1c2gsXHJcbiAgICAgIGhhbmRsZVBvcDogdGhpcy5oYW5kbGVQb3AsXHJcbiAgICAgIGhhbmRsZVN3YXA6IHRoaXMuaGFuZGxlU3dhcCxcclxuICAgICAgaGFuZGxlTW92ZTogdGhpcy5oYW5kbGVNb3ZlLFxyXG4gICAgICBoYW5kbGVJbnNlcnQ6IHRoaXMuaGFuZGxlSW5zZXJ0LFxyXG4gICAgICBoYW5kbGVSZXBsYWNlOiB0aGlzLmhhbmRsZVJlcGxhY2UsXHJcbiAgICAgIGhhbmRsZVVuc2hpZnQ6IHRoaXMuaGFuZGxlVW5zaGlmdCxcclxuICAgICAgaGFuZGxlUmVtb3ZlOiB0aGlzLmhhbmRsZVJlbW92ZVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBjb21wb25lbnQgPSBfdGhpcyRwcm9wczIuY29tcG9uZW50LFxyXG4gICAgICAgIHJlbmRlciA9IF90aGlzJHByb3BzMi5yZW5kZXIsXHJcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wczIuY2hpbGRyZW4sXHJcbiAgICAgICAgbmFtZSA9IF90aGlzJHByb3BzMi5uYW1lLFxyXG4gICAgICAgIF90aGlzJHByb3BzMiRmb3JtaWsgPSBfdGhpcyRwcm9wczIuZm9ybWlrLFxyXG4gICAgICAgIHJlc3RPZkZvcm1payA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzMiRmb3JtaWssIFtcInZhbGlkYXRlXCIsIFwidmFsaWRhdGlvblNjaGVtYVwiXSk7XHJcblxyXG4gICAgdmFyIHByb3BzID0gX2V4dGVuZHMoe30sIGFycmF5SGVscGVycywge1xyXG4gICAgICBmb3JtOiByZXN0T2ZGb3JtaWssXHJcbiAgICAgIG5hbWU6IG5hbWVcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBjb21wb25lbnQgPyBjcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgcHJvcHMpIDogcmVuZGVyID8gcmVuZGVyKHByb3BzKSA6IGNoaWxkcmVuIC8vIGNoaWxkcmVuIGNvbWUgbGFzdCwgYWx3YXlzIGNhbGxlZFxyXG4gICAgPyB0eXBlb2YgY2hpbGRyZW4gPT09ICdmdW5jdGlvbicgPyBjaGlsZHJlbihwcm9wcykgOiAhaXNFbXB0eUNoaWxkcmVuKGNoaWxkcmVuKSA/IENoaWxkcmVuLm9ubHkoY2hpbGRyZW4pIDogbnVsbCA6IG51bGw7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIEZpZWxkQXJyYXlJbm5lcjtcclxufShDb21wb25lbnQpO1xyXG5cclxuRmllbGRBcnJheUlubmVyLmRlZmF1bHRQcm9wcyA9IHtcclxuICB2YWxpZGF0ZU9uQ2hhbmdlOiB0cnVlXHJcbn07XHJcbnZhciBGaWVsZEFycmF5ID0gLyojX19QVVJFX18qL2Nvbm5lY3QoRmllbGRBcnJheUlubmVyKTtcclxuXHJcbnZhciBFcnJvck1lc3NhZ2VJbXBsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XHJcbiAgX2luaGVyaXRzTG9vc2UoRXJyb3JNZXNzYWdlSW1wbCwgX1JlYWN0JENvbXBvbmVudCk7XHJcblxyXG4gIGZ1bmN0aW9uIEVycm9yTWVzc2FnZUltcGwoKSB7XHJcbiAgICByZXR1cm4gX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgfVxyXG5cclxuICB2YXIgX3Byb3RvID0gRXJyb3JNZXNzYWdlSW1wbC5wcm90b3R5cGU7XHJcblxyXG4gIF9wcm90by5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiBzaG91bGRDb21wb25lbnRVcGRhdGUocHJvcHMpIHtcclxuICAgIGlmIChnZXRJbih0aGlzLnByb3BzLmZvcm1pay5lcnJvcnMsIHRoaXMucHJvcHMubmFtZSkgIT09IGdldEluKHByb3BzLmZvcm1pay5lcnJvcnMsIHRoaXMucHJvcHMubmFtZSkgfHwgZ2V0SW4odGhpcy5wcm9wcy5mb3JtaWsudG91Y2hlZCwgdGhpcy5wcm9wcy5uYW1lKSAhPT0gZ2V0SW4ocHJvcHMuZm9ybWlrLnRvdWNoZWQsIHRoaXMucHJvcHMubmFtZSkgfHwgT2JqZWN0LmtleXModGhpcy5wcm9wcykubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhwcm9wcykubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XHJcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxyXG4gICAgICAgIGNvbXBvbmVudCA9IF90aGlzJHByb3BzLmNvbXBvbmVudCxcclxuICAgICAgICBmb3JtaWsgPSBfdGhpcyRwcm9wcy5mb3JtaWssXHJcbiAgICAgICAgcmVuZGVyID0gX3RoaXMkcHJvcHMucmVuZGVyLFxyXG4gICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHMuY2hpbGRyZW4sXHJcbiAgICAgICAgbmFtZSA9IF90aGlzJHByb3BzLm5hbWUsXHJcbiAgICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzLCBbXCJjb21wb25lbnRcIiwgXCJmb3JtaWtcIiwgXCJyZW5kZXJcIiwgXCJjaGlsZHJlblwiLCBcIm5hbWVcIl0pO1xyXG5cclxuICAgIHZhciB0b3VjaCA9IGdldEluKGZvcm1pay50b3VjaGVkLCBuYW1lKTtcclxuICAgIHZhciBlcnJvciA9IGdldEluKGZvcm1pay5lcnJvcnMsIG5hbWUpO1xyXG4gICAgcmV0dXJuICEhdG91Y2ggJiYgISFlcnJvciA/IHJlbmRlciA/IGlzRnVuY3Rpb24ocmVuZGVyKSA/IHJlbmRlcihlcnJvcikgOiBudWxsIDogY2hpbGRyZW4gPyBpc0Z1bmN0aW9uKGNoaWxkcmVuKSA/IGNoaWxkcmVuKGVycm9yKSA6IG51bGwgOiBjb21wb25lbnQgPyBjcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgcmVzdCwgZXJyb3IpIDogZXJyb3IgOiBudWxsO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBFcnJvck1lc3NhZ2VJbXBsO1xyXG59KENvbXBvbmVudCk7XHJcblxyXG52YXIgRXJyb3JNZXNzYWdlID0gLyojX19QVVJFX18qL2Nvbm5lY3QoRXJyb3JNZXNzYWdlSW1wbCk7XHJcblxyXG4vKipcclxuICogQ3VzdG9tIEZpZWxkIGNvbXBvbmVudCBmb3IgcXVpY2tseSBob29raW5nIGludG8gRm9ybWlrXHJcbiAqIGNvbnRleHQgYW5kIHdpcmluZyB1cCBmb3Jtcy5cclxuICovXHJcblxyXG52YXIgRmFzdEZpZWxkSW5uZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcclxuICBfaW5oZXJpdHNMb29zZShGYXN0RmllbGRJbm5lciwgX1JlYWN0JENvbXBvbmVudCk7XHJcblxyXG4gIGZ1bmN0aW9uIEZhc3RGaWVsZElubmVyKHByb3BzKSB7XHJcbiAgICB2YXIgX3RoaXM7XHJcblxyXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XHJcbiAgICB2YXIgcmVuZGVyID0gcHJvcHMucmVuZGVyLFxyXG4gICAgICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXHJcbiAgICAgICAgY29tcG9uZW50ID0gcHJvcHMuY29tcG9uZW50LFxyXG4gICAgICAgIGlzID0gcHJvcHMuYXMsXHJcbiAgICAgICAgbmFtZSA9IHByb3BzLm5hbWU7XHJcbiAgICAhIXJlbmRlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCI8RmFzdEZpZWxkIHJlbmRlcj4gaGFzIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBhIGNoaWxkIGNhbGxiYWNrIGZ1bmN0aW9uIGluc3RlYWQ6IDxGYXN0RmllbGQgbmFtZT17XCIgKyBuYW1lICsgXCJ9Pntwcm9wcyA9PiAuLi59PC9GYXN0RmllbGQ+IGluc3RlYWQuXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcclxuICAgICEhKGNvbXBvbmVudCAmJiByZW5kZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnWW91IHNob3VsZCBub3QgdXNlIDxGYXN0RmllbGQgY29tcG9uZW50PiBhbmQgPEZhc3RGaWVsZCByZW5kZXI+IGluIHRoZSBzYW1lIDxGYXN0RmllbGQ+IGNvbXBvbmVudDsgPEZhc3RGaWVsZCBjb21wb25lbnQ+IHdpbGwgYmUgaWdub3JlZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcclxuICAgICEhKGlzICYmIGNoaWxkcmVuICYmIGlzRnVuY3Rpb24oY2hpbGRyZW4pKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1lvdSBzaG91bGQgbm90IHVzZSA8RmFzdEZpZWxkIGFzPiBhbmQgPEZhc3RGaWVsZCBjaGlsZHJlbj4gYXMgYSBmdW5jdGlvbiBpbiB0aGUgc2FtZSA8RmFzdEZpZWxkPiBjb21wb25lbnQ7IDxGYXN0RmllbGQgYXM+IHdpbGwgYmUgaWdub3JlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XHJcbiAgICAhIShjb21wb25lbnQgJiYgY2hpbGRyZW4gJiYgaXNGdW5jdGlvbihjaGlsZHJlbikpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnWW91IHNob3VsZCBub3QgdXNlIDxGYXN0RmllbGQgY29tcG9uZW50PiBhbmQgPEZhc3RGaWVsZCBjaGlsZHJlbj4gYXMgYSBmdW5jdGlvbiBpbiB0aGUgc2FtZSA8RmFzdEZpZWxkPiBjb21wb25lbnQ7IDxGYXN0RmllbGQgY29tcG9uZW50PiB3aWxsIGJlIGlnbm9yZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xyXG4gICAgISEocmVuZGVyICYmIGNoaWxkcmVuICYmICFpc0VtcHR5Q2hpbGRyZW4oY2hpbGRyZW4pKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1lvdSBzaG91bGQgbm90IHVzZSA8RmFzdEZpZWxkIHJlbmRlcj4gYW5kIDxGYXN0RmllbGQgY2hpbGRyZW4+IGluIHRoZSBzYW1lIDxGYXN0RmllbGQ+IGNvbXBvbmVudDsgPEZhc3RGaWVsZCBjaGlsZHJlbj4gd2lsbCBiZSBpZ25vcmVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xyXG4gICAgcmV0dXJuIF90aGlzO1xyXG4gIH1cclxuXHJcbiAgdmFyIF9wcm90byA9IEZhc3RGaWVsZElubmVyLnByb3RvdHlwZTtcclxuXHJcbiAgX3Byb3RvLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZShwcm9wcykge1xyXG4gICAgaWYgKHRoaXMucHJvcHMuc2hvdWxkVXBkYXRlKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLnNob3VsZFVwZGF0ZShwcm9wcywgdGhpcy5wcm9wcyk7XHJcbiAgICB9IGVsc2UgaWYgKHByb3BzLm5hbWUgIT09IHRoaXMucHJvcHMubmFtZSB8fCBnZXRJbihwcm9wcy5mb3JtaWsudmFsdWVzLCB0aGlzLnByb3BzLm5hbWUpICE9PSBnZXRJbih0aGlzLnByb3BzLmZvcm1pay52YWx1ZXMsIHRoaXMucHJvcHMubmFtZSkgfHwgZ2V0SW4ocHJvcHMuZm9ybWlrLmVycm9ycywgdGhpcy5wcm9wcy5uYW1lKSAhPT0gZ2V0SW4odGhpcy5wcm9wcy5mb3JtaWsuZXJyb3JzLCB0aGlzLnByb3BzLm5hbWUpIHx8IGdldEluKHByb3BzLmZvcm1pay50b3VjaGVkLCB0aGlzLnByb3BzLm5hbWUpICE9PSBnZXRJbih0aGlzLnByb3BzLmZvcm1pay50b3VjaGVkLCB0aGlzLnByb3BzLm5hbWUpIHx8IE9iamVjdC5rZXlzKHRoaXMucHJvcHMpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aCB8fCBwcm9wcy5mb3JtaWsuaXNTdWJtaXR0aW5nICE9PSB0aGlzLnByb3BzLmZvcm1pay5pc1N1Ym1pdHRpbmcpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XHJcbiAgICAvLyBSZWdpc3RlciB0aGUgRmllbGQgd2l0aCB0aGUgcGFyZW50IEZvcm1pay4gUGFyZW50IHdpbGwgY3ljbGUgdGhyb3VnaFxyXG4gICAgLy8gcmVnaXN0ZXJlZCBGaWVsZCdzIHZhbGlkYXRlIGZucyByaWdodCBwcmlvciB0byBzdWJtaXRcclxuICAgIHRoaXMucHJvcHMuZm9ybWlrLnJlZ2lzdGVyRmllbGQodGhpcy5wcm9wcy5uYW1lLCB7XHJcbiAgICAgIHZhbGlkYXRlOiB0aGlzLnByb3BzLnZhbGlkYXRlXHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICBfcHJvdG8uY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xyXG4gICAgaWYgKHRoaXMucHJvcHMubmFtZSAhPT0gcHJldlByb3BzLm5hbWUpIHtcclxuICAgICAgdGhpcy5wcm9wcy5mb3JtaWsudW5yZWdpc3RlckZpZWxkKHByZXZQcm9wcy5uYW1lKTtcclxuICAgICAgdGhpcy5wcm9wcy5mb3JtaWsucmVnaXN0ZXJGaWVsZCh0aGlzLnByb3BzLm5hbWUsIHtcclxuICAgICAgICB2YWxpZGF0ZTogdGhpcy5wcm9wcy52YWxpZGF0ZVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5wcm9wcy52YWxpZGF0ZSAhPT0gcHJldlByb3BzLnZhbGlkYXRlKSB7XHJcbiAgICAgIHRoaXMucHJvcHMuZm9ybWlrLnJlZ2lzdGVyRmllbGQodGhpcy5wcm9wcy5uYW1lLCB7XHJcbiAgICAgICAgdmFsaWRhdGU6IHRoaXMucHJvcHMudmFsaWRhdGVcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XHJcbiAgICB0aGlzLnByb3BzLmZvcm1pay51bnJlZ2lzdGVyRmllbGQodGhpcy5wcm9wcy5uYW1lKTtcclxuICB9O1xyXG5cclxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBuYW1lID0gX3RoaXMkcHJvcHMubmFtZSxcclxuICAgICAgICByZW5kZXIgPSBfdGhpcyRwcm9wcy5yZW5kZXIsXHJcbiAgICAgICAgaXMgPSBfdGhpcyRwcm9wcy5hcyxcclxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzLmNoaWxkcmVuLFxyXG4gICAgICAgIGNvbXBvbmVudCA9IF90aGlzJHByb3BzLmNvbXBvbmVudCxcclxuICAgICAgICBmb3JtaWsgPSBfdGhpcyRwcm9wcy5mb3JtaWssXHJcbiAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wcywgW1widmFsaWRhdGVcIiwgXCJuYW1lXCIsIFwicmVuZGVyXCIsIFwiYXNcIiwgXCJjaGlsZHJlblwiLCBcImNvbXBvbmVudFwiLCBcInNob3VsZFVwZGF0ZVwiLCBcImZvcm1pa1wiXSk7XHJcblxyXG4gICAgdmFyIHJlc3RPZkZvcm1payA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKGZvcm1paywgW1widmFsaWRhdGVcIiwgXCJ2YWxpZGF0aW9uU2NoZW1hXCJdKTtcclxuXHJcbiAgICB2YXIgZmllbGQgPSBmb3JtaWsuZ2V0RmllbGRQcm9wcyhfZXh0ZW5kcyh7XHJcbiAgICAgIG5hbWU6IG5hbWVcclxuICAgIH0sIHByb3BzKSk7XHJcbiAgICB2YXIgbWV0YSA9IHtcclxuICAgICAgdmFsdWU6IGdldEluKGZvcm1pay52YWx1ZXMsIG5hbWUpLFxyXG4gICAgICBlcnJvcjogZ2V0SW4oZm9ybWlrLmVycm9ycywgbmFtZSksXHJcbiAgICAgIHRvdWNoZWQ6ICEhZ2V0SW4oZm9ybWlrLnRvdWNoZWQsIG5hbWUpLFxyXG4gICAgICBpbml0aWFsVmFsdWU6IGdldEluKGZvcm1pay5pbml0aWFsVmFsdWVzLCBuYW1lKSxcclxuICAgICAgaW5pdGlhbFRvdWNoZWQ6ICEhZ2V0SW4oZm9ybWlrLmluaXRpYWxUb3VjaGVkLCBuYW1lKSxcclxuICAgICAgaW5pdGlhbEVycm9yOiBnZXRJbihmb3JtaWsuaW5pdGlhbEVycm9ycywgbmFtZSlcclxuICAgIH07XHJcbiAgICB2YXIgYmFnID0ge1xyXG4gICAgICBmaWVsZDogZmllbGQsXHJcbiAgICAgIG1ldGE6IG1ldGEsXHJcbiAgICAgIGZvcm06IHJlc3RPZkZvcm1pa1xyXG4gICAgfTtcclxuXHJcbiAgICBpZiAocmVuZGVyKSB7XHJcbiAgICAgIHJldHVybiByZW5kZXIoYmFnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNGdW5jdGlvbihjaGlsZHJlbikpIHtcclxuICAgICAgcmV0dXJuIGNoaWxkcmVuKGJhZyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNvbXBvbmVudCkge1xyXG4gICAgICAvLyBUaGlzIGJlaGF2aW9yIGlzIGJhY2t3YXJkcyBjb21wYXQgd2l0aCBlYXJsaWVyIEZvcm1payAwLjkgdG8gMS54XHJcbiAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHZhciBpbm5lclJlZiA9IHByb3BzLmlubmVyUmVmLFxyXG4gICAgICAgICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIFtcImlubmVyUmVmXCJdKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBfZXh0ZW5kcyh7XHJcbiAgICAgICAgICByZWY6IGlubmVyUmVmXHJcbiAgICAgICAgfSwgZmllbGQsIHJlc3QpLCBjaGlsZHJlbik7XHJcbiAgICAgIH0gLy8gV2UgZG9uJ3QgcGFzcyBgbWV0YWAgZm9yIGJhY2t3YXJkcyBjb21wYXRcclxuXHJcblxyXG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChjb21wb25lbnQsIF9leHRlbmRzKHtcclxuICAgICAgICBmaWVsZDogZmllbGQsXHJcbiAgICAgICAgZm9ybTogZm9ybWlrXHJcbiAgICAgIH0sIHByb3BzKSwgY2hpbGRyZW4pO1xyXG4gICAgfSAvLyBkZWZhdWx0IHRvIGlucHV0IGhlcmUgc28gd2UgY2FuIGNoZWNrIGZvciBib3RoIGBhc2AgYW5kIGBjaGlsZHJlbmAgYWJvdmVcclxuXHJcblxyXG4gICAgdmFyIGFzRWxlbWVudCA9IGlzIHx8ICdpbnB1dCc7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBhc0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHZhciBfaW5uZXJSZWYgPSBwcm9wcy5pbm5lclJlZixcclxuICAgICAgICAgIF9yZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIFtcImlubmVyUmVmXCJdKTtcclxuXHJcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KGFzRWxlbWVudCwgX2V4dGVuZHMoe1xyXG4gICAgICAgIHJlZjogX2lubmVyUmVmXHJcbiAgICAgIH0sIGZpZWxkLCBfcmVzdCksIGNoaWxkcmVuKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChhc0VsZW1lbnQsIF9leHRlbmRzKHt9LCBmaWVsZCwgcHJvcHMpLCBjaGlsZHJlbik7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIEZhc3RGaWVsZElubmVyO1xyXG59KENvbXBvbmVudCk7XHJcblxyXG52YXIgRmFzdEZpZWxkID0gLyojX19QVVJFX18qL2Nvbm5lY3QoRmFzdEZpZWxkSW5uZXIpO1xyXG5cclxuZXhwb3J0IHsgRXJyb3JNZXNzYWdlLCBGYXN0RmllbGQsIEZpZWxkLCBGaWVsZEFycmF5LCBGb3JtLCBGb3JtaWssIEZvcm1pa0NvbnN1bWVyLCBGb3JtaWtDb250ZXh0LCBGb3JtaWtQcm92aWRlciwgY29ubmVjdCwgZ2V0QWN0aXZlRWxlbWVudCwgZ2V0SW4sIGluc2VydCwgaXNFbXB0eUFycmF5LCBpc0VtcHR5Q2hpbGRyZW4sIGlzRnVuY3Rpb24sIGlzSW5wdXRFdmVudCwgaXNJbnRlZ2VyLCBpc05hTiQxIGFzIGlzTmFOLCBpc09iamVjdCwgaXNQcm9taXNlLCBpc1N0cmluZywgbW92ZSwgcHJlcGFyZURhdGFGb3JWYWxpZGF0aW9uLCByZXBsYWNlLCBzZXRJbiwgc2V0TmVzdGVkT2JqZWN0VmFsdWVzLCBzd2FwLCB1c2VGaWVsZCwgdXNlRm9ybWlrLCB1c2VGb3JtaWtDb250ZXh0LCB2YWxpZGF0ZVl1cFNjaGVtYSwgd2l0aEZvcm1paywgeXVwVG9Gb3JtRXJyb3JzIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1pay5lc20uanMubWFwXHJcbiJdLCJuYW1lcyI6WyJkZWVwbWVyZ2UiLCJpc1BsYWluT2JqZWN0IiwiY2xvbmVEZWVwIiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJDaGlsZHJlbiIsInVzZVJlZiIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJ1c2VNZW1vIiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsImNyZWF0ZUVsZW1lbnQiLCJ1c2VMYXlvdXRFZmZlY3QiLCJmb3J3YXJkUmVmIiwiQ29tcG9uZW50IiwiaXNFcXVhbCIsImludmFyaWFudCIsImNsb25lIiwidG9QYXRoIiwiaG9pc3ROb25SZWFjdFN0YXRpY3MiLCJfZXh0ZW5kcyIsIk9iamVjdCIsImFzc2lnbiIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIl9pbmhlcml0c0xvb3NlIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJfX3Byb3RvX18iLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImV4Y2x1ZGVkIiwic291cmNlS2V5cyIsImtleXMiLCJpbmRleE9mIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInNlbGYiLCJSZWZlcmVuY2VFcnJvciIsIkZvcm1pa0NvbnRleHQiLCJ1bmRlZmluZWQiLCJkaXNwbGF5TmFtZSIsIkZvcm1pa1Byb3ZpZGVyIiwiUHJvdmlkZXIiLCJGb3JtaWtDb25zdW1lciIsIkNvbnN1bWVyIiwidXNlRm9ybWlrQ29udGV4dCIsImZvcm1payIsInByb2Nlc3MiLCJpc0VtcHR5QXJyYXkiLCJ2YWx1ZSIsIkFycmF5IiwiaXNBcnJheSIsImlzRnVuY3Rpb24iLCJvYmoiLCJpc09iamVjdCIsImlzSW50ZWdlciIsIlN0cmluZyIsIk1hdGgiLCJmbG9vciIsIk51bWJlciIsImlzU3RyaW5nIiwidG9TdHJpbmciLCJpc05hTiQxIiwiaXNOYU4iLCJpc0VtcHR5Q2hpbGRyZW4iLCJjaGlsZHJlbiIsImNvdW50IiwiaXNQcm9taXNlIiwidGhlbiIsImlzSW5wdXRFdmVudCIsImdldEFjdGl2ZUVsZW1lbnQiLCJkb2MiLCJkb2N1bWVudCIsImFjdGl2ZUVsZW1lbnQiLCJib2R5IiwiZSIsImdldEluIiwiZGVmIiwicCIsInBhdGgiLCJzZXRJbiIsInJlcyIsInJlc1ZhbCIsInBhdGhBcnJheSIsImN1cnJlbnRQYXRoIiwiY3VycmVudE9iaiIsInNsaWNlIiwibmV4dFBhdGgiLCJzZXROZXN0ZWRPYmplY3RWYWx1ZXMiLCJvYmplY3QiLCJ2aXNpdGVkIiwicmVzcG9uc2UiLCJXZWFrTWFwIiwiX2kiLCJfT2JqZWN0JGtleXMiLCJrIiwidmFsIiwiZ2V0Iiwic2V0IiwiZm9ybWlrUmVkdWNlciIsInN0YXRlIiwibXNnIiwidHlwZSIsInZhbHVlcyIsInBheWxvYWQiLCJ0b3VjaGVkIiwiZXJyb3JzIiwic3RhdHVzIiwiaXNTdWJtaXR0aW5nIiwiaXNWYWxpZGF0aW5nIiwiZmllbGQiLCJzdWJtaXRDb3VudCIsImVtcHR5RXJyb3JzIiwiZW1wdHlUb3VjaGVkIiwidXNlRm9ybWlrIiwiX3JlZiIsIl9yZWYkdmFsaWRhdGVPbkNoYW5nZSIsInZhbGlkYXRlT25DaGFuZ2UiLCJfcmVmJHZhbGlkYXRlT25CbHVyIiwidmFsaWRhdGVPbkJsdXIiLCJfcmVmJHZhbGlkYXRlT25Nb3VudCIsInZhbGlkYXRlT25Nb3VudCIsImlzSW5pdGlhbFZhbGlkIiwiX3JlZiRlbmFibGVSZWluaXRpYWxpIiwiZW5hYmxlUmVpbml0aWFsaXplIiwib25TdWJtaXQiLCJyZXN0IiwicHJvcHMiLCJpbml0aWFsVmFsdWVzIiwiaW5pdGlhbEVycm9ycyIsImluaXRpYWxUb3VjaGVkIiwiaW5pdGlhbFN0YXR1cyIsImlzTW91bnRlZCIsImZpZWxkUmVnaXN0cnkiLCJjdXJyZW50IiwiX1JlYWN0JHVzZVN0YXRlIiwic2V0SXRlcmF0aW9uIiwic3RhdGVSZWYiLCJkaXNwYXRjaCIsImFjdGlvbiIsInByZXYiLCJ4IiwicnVuVmFsaWRhdGVIYW5kbGVyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJtYXliZVByb21pc2VkRXJyb3JzIiwidmFsaWRhdGUiLCJhY3R1YWxFeGNlcHRpb24iLCJjb25zb2xlIiwid2FybiIsInJ1blZhbGlkYXRpb25TY2hlbWEiLCJ2YWxpZGF0aW9uU2NoZW1hIiwic2NoZW1hIiwicHJvbWlzZSIsInZhbGlkYXRlQXQiLCJ2YWxpZGF0ZVl1cFNjaGVtYSIsImVyciIsIm5hbWUiLCJ5dXBUb0Zvcm1FcnJvcnMiLCJydW5TaW5nbGVGaWVsZExldmVsVmFsaWRhdGlvbiIsInJ1bkZpZWxkTGV2ZWxWYWxpZGF0aW9ucyIsImZpZWxkS2V5c1dpdGhWYWxpZGF0aW9uIiwiZmlsdGVyIiwiZiIsImZpZWxkVmFsaWRhdGlvbnMiLCJtYXAiLCJhbGwiLCJmaWVsZEVycm9yc0xpc3QiLCJyZWR1Y2UiLCJjdXJyIiwiaW5kZXgiLCJydW5BbGxWYWxpZGF0aW9ucyIsIl9yZWYyIiwiZmllbGRFcnJvcnMiLCJzY2hlbWFFcnJvcnMiLCJ2YWxpZGF0ZUVycm9ycyIsImNvbWJpbmVkRXJyb3JzIiwiYXJyYXlNZXJnZSIsInZhbGlkYXRlRm9ybVdpdGhIaWdoUHJpb3JpdHkiLCJ1c2VFdmVudENhbGxiYWNrIiwicmVzZXRGb3JtIiwibmV4dFN0YXRlIiwiZGlzcGF0Y2hGbiIsIm9uUmVzZXQiLCJtYXliZVByb21pc2VkT25SZXNldCIsImltcGVyYXRpdmVNZXRob2RzIiwidmFsaWRhdGVGaWVsZCIsIm1heWJlUHJvbWlzZSIsImVycm9yIiwicmVnaXN0ZXJGaWVsZCIsIl9yZWYzIiwidW5yZWdpc3RlckZpZWxkIiwic2V0VG91Y2hlZCIsInNob3VsZFZhbGlkYXRlIiwid2lsbFZhbGlkYXRlIiwic2V0RXJyb3JzIiwic2V0VmFsdWVzIiwicmVzb2x2ZWRWYWx1ZXMiLCJzZXRGaWVsZEVycm9yIiwic2V0RmllbGRWYWx1ZSIsImV4ZWN1dGVDaGFuZ2UiLCJldmVudE9yVGV4dFZhbHVlIiwibWF5YmVQYXRoIiwicGFyc2VkIiwicGVyc2lzdCIsImN1cnJlbnRUYXJnZXQiLCJpZCIsImNoZWNrZWQiLCJvdXRlckhUTUwiLCJvcHRpb25zIiwibXVsdGlwbGUiLCJ3YXJuQWJvdXRNaXNzaW5nSWRlbnRpZmllciIsImh0bWxDb250ZW50IiwiZG9jdW1lbnRhdGlvbkFuY2hvckxpbmsiLCJoYW5kbGVyTmFtZSIsInRlc3QiLCJwYXJzZUZsb2F0IiwiZ2V0VmFsdWVGb3JDaGVja2JveCIsImdldFNlbGVjdGVkVmFsdWVzIiwiaGFuZGxlQ2hhbmdlIiwiZXZlbnRPclBhdGgiLCJldmVudCIsInNldEZpZWxkVG91Y2hlZCIsImV4ZWN1dGVCbHVyIiwiX2UkdGFyZ2V0IiwiaGFuZGxlQmx1ciIsImV2ZW50T3JTdHJpbmciLCJzZXRGb3JtaWtTdGF0ZSIsInN0YXRlT3JDYiIsInNldFN0YXR1cyIsInNldFN1Ym1pdHRpbmciLCJzdWJtaXRGb3JtIiwiaXNJbnN0YW5jZU9mRXJyb3IiLCJFcnJvciIsImlzQWN0dWFsbHlWYWxpZCIsInByb21pc2VPclVuZGVmaW5lZCIsImV4ZWN1dGVTdWJtaXQiLCJyZXN1bHQiLCJfZXJyb3JzIiwiaGFuZGxlU3VibWl0IiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJIVE1MQnV0dG9uRWxlbWVudCIsImF0dHJpYnV0ZXMiLCJnZXROYW1lZEl0ZW0iLCJyZWFzb24iLCJ2YWxpZGF0ZUZvcm0iLCJoYW5kbGVSZXNldCIsImdldEZpZWxkTWV0YSIsImluaXRpYWxWYWx1ZSIsImluaXRpYWxFcnJvciIsImdldEZpZWxkSGVscGVycyIsInNldFZhbHVlIiwic2V0RXJyb3IiLCJnZXRGaWVsZFByb3BzIiwibmFtZU9yT3B0aW9ucyIsImlzQW5PYmplY3QiLCJ2YWx1ZVN0YXRlIiwib25DaGFuZ2UiLCJvbkJsdXIiLCJ2YWx1ZVByb3AiLCJpcyIsImFzIiwiZGlydHkiLCJpc1ZhbGlkIiwiY3R4IiwiRm9ybWlrIiwiZm9ybWlrYmFnIiwiY29tcG9uZW50IiwicmVuZGVyIiwiaW5uZXJSZWYiLCJvbmx5IiwiX3JlZjQiLCJ5dXBFcnJvciIsImlubmVyIiwibWVzc2FnZSIsIl9pdGVyYXRvciIsIl9pc0FycmF5IiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJfcmVmNSIsIm5leHQiLCJkb25lIiwic3luYyIsImNvbnRleHQiLCJub3JtYWxpemVkVmFsdWVzIiwicHJlcGFyZURhdGFGb3JWYWxpZGF0aW9uIiwiYWJvcnRFYXJseSIsImRhdGEiLCJkZXN0aW5hdGlvbiIsImZvckVhY2giLCJtZXJnZSIsImNsb25lUmVxdWVzdGVkIiwic2hvdWxkQ2xvbmUiLCJpc01lcmdlYWJsZU9iamVjdCIsInB1c2giLCJmcm9tIiwiZWwiLCJzZWxlY3RlZCIsImN1cnJlbnRWYWx1ZSIsIkJvb2xlYW4iLCJjdXJyZW50QXJyYXlPZlZhbHVlcyIsImlzVmFsdWVJbkFycmF5IiwiY29uY2F0IiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsIndpbmRvdyIsImZuIiwicmVmIiwiX2xlbiIsImFyZ3MiLCJfa2V5IiwidXNlRmllbGQiLCJwcm9wc09yRmllbGROYW1lIiwiZmllbGROYW1lIiwidmFsaWRhdGVGbiIsImZpZWxkSGVscGVycyIsIkZpZWxkIiwiY2xhc3NOYW1lIiwiX3VzZUZvcm1pa0NvbnRleHQiLCJtZXRhIiwibGVnYWN5QmFnIiwiZm9ybSIsImFzRWxlbWVudCIsIl9pbm5lclJlZiIsIl9yZXN0IiwiRm9ybSIsIl9hY3Rpb24iLCJ3aXRoRm9ybWlrIiwiX3JlZiRtYXBQcm9wc1RvVmFsdWVzIiwibWFwUHJvcHNUb1ZhbHVlcyIsInZhbmlsbGFQcm9wcyIsImNvbmZpZyIsImNyZWF0ZUZvcm1payIsIkNvbXBvbmVudCQxIiwiY29tcG9uZW50RGlzcGxheU5hbWUiLCJDIiwiX1JlYWN0JENvbXBvbmVudCIsIl90aGlzIiwiYWN0aW9ucyIsInJlbmRlckZvcm1Db21wb25lbnQiLCJmb3JtaWtQcm9wcyIsIl9wcm90byIsIl90aGlzJHByb3BzIiwibWFwUHJvcHNUb1N0YXR1cyIsIm1hcFByb3BzVG9FcnJvcnMiLCJtYXBQcm9wc1RvVG91Y2hlZCIsImNvbm5lY3QiLCJDb21wIiwiV3JhcHBlZENvbXBvbmVudCIsIm1vdmUiLCJhcnJheSIsInRvIiwiY29weSIsImNvcHlBcnJheUxpa2UiLCJzcGxpY2UiLCJzd2FwIiwiYXJyYXlMaWtlIiwiaW5kZXhBIiwiaW5kZXhCIiwiYSIsImluc2VydCIsInJlcGxhY2UiLCJtYXhJbmRleCIsInBhcnNlSW50IiwibWF4IiwiY3JlYXRlQWx0ZXJhdGlvbkhhbmRsZXIiLCJhbHRlcmF0aW9uIiwiZGVmYXVsdEZ1bmN0aW9uIiwiRmllbGRBcnJheUlubmVyIiwidXBkYXRlQXJyYXlGaWVsZCIsImFsdGVyVG91Y2hlZCIsImFsdGVyRXJyb3JzIiwicHJldlN0YXRlIiwidXBkYXRlRXJyb3JzIiwidXBkYXRlVG91Y2hlZCIsImZpZWxkRXJyb3IiLCJmaWVsZFRvdWNoZWQiLCJoYW5kbGVQdXNoIiwiaGFuZGxlU3dhcCIsImhhbmRsZU1vdmUiLCJoYW5kbGVJbnNlcnQiLCJoYW5kbGVSZXBsYWNlIiwidW5zaGlmdCIsImFyciIsImhhbmRsZVVuc2hpZnQiLCJoYW5kbGVSZW1vdmUiLCJyZW1vdmUiLCJoYW5kbGVQb3AiLCJwb3AiLCJiaW5kIiwiY29tcG9uZW50RGlkVXBkYXRlIiwicHJldlByb3BzIiwiZXZlcnkiLCJ2IiwidG1wIiwiYXJyYXlIZWxwZXJzIiwiX3RoaXMkcHJvcHMyIiwiX3RoaXMkcHJvcHMyJGZvcm1payIsInJlc3RPZkZvcm1payIsImRlZmF1bHRQcm9wcyIsIkZpZWxkQXJyYXkiLCJFcnJvck1lc3NhZ2VJbXBsIiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwidG91Y2giLCJFcnJvck1lc3NhZ2UiLCJGYXN0RmllbGRJbm5lciIsInNob3VsZFVwZGF0ZSIsImNvbXBvbmVudERpZE1vdW50IiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJiYWciLCJGYXN0RmllbGQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/formik/dist/formik.esm.js\n");

/***/ })

};
;