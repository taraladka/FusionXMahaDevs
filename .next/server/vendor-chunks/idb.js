"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/idb";
exports.ids = ["vendor-chunks/idb"];
exports.modules = {

/***/ "(ssr)/./node_modules/idb/build/index.js":
/*!*****************************************!*\
  !*** ./node_modules/idb/build/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deleteDB: () => (/* binding */ deleteDB),\n/* harmony export */   openDB: () => (/* binding */ openDB),\n/* harmony export */   unwrap: () => (/* reexport safe */ _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.u),\n/* harmony export */   wrap: () => (/* reexport safe */ _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)\n/* harmony export */ });\n/* harmony import */ var _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wrap-idb-value.js */ \"(ssr)/./node_modules/idb/build/wrap-idb-value.js\");\n\n\n/**\r\n * Open a database.\r\n *\r\n * @param name Name of the database.\r\n * @param version Schema version.\r\n * @param callbacks Additional callbacks.\r\n */ function openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = (0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request);\n    if (upgrade) {\n        request.addEventListener(\"upgradeneeded\", (event)=>{\n            upgrade((0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request.result), event.oldVersion, event.newVersion, (0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener(\"blocked\", (event)=>blocked(// Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n            event.oldVersion, event.newVersion, event));\n    }\n    openPromise.then((db)=>{\n        if (terminated) db.addEventListener(\"close\", ()=>terminated());\n        if (blocking) {\n            db.addEventListener(\"versionchange\", (event)=>blocking(event.oldVersion, event.newVersion, event));\n        }\n    }).catch(()=>{});\n    return openPromise;\n}\n/**\r\n * Delete a database.\r\n *\r\n * @param name Name of the database.\r\n */ function deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener(\"blocked\", (event)=>blocked(// Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n            event.oldVersion, event));\n    }\n    return (0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request).then(()=>undefined);\n}\nconst readMethods = [\n    \"get\",\n    \"getKey\",\n    \"getAll\",\n    \"getAllKeys\",\n    \"count\"\n];\nconst writeMethods = [\n    \"put\",\n    \"add\",\n    \"delete\",\n    \"clear\"\n];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === \"string\")) {\n        return;\n    }\n    if (cachedMethods.get(prop)) return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, \"\");\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (// Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function(storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? \"readwrite\" : \"readonly\");\n        let target = tx.store;\n        if (useIndex) target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\n(0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.r)((oldTraps)=>({\n        ...oldTraps,\n        get: (target, prop, receiver)=>getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n        has: (target, prop)=>!!getMethod(target, prop) || oldTraps.has(target, prop)\n    }));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaWRiL2J1aWxkL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW1FO0FBQ047QUFFN0Q7Ozs7OztDQU1DLEdBQ0QsU0FBU00sT0FBT0MsSUFBSSxFQUFFQyxPQUFPLEVBQUUsRUFBRUMsT0FBTyxFQUFFQyxPQUFPLEVBQUVDLFFBQVEsRUFBRUMsVUFBVSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQzFFLE1BQU1DLFVBQVVDLFVBQVVDLElBQUksQ0FBQ1IsTUFBTUM7SUFDckMsTUFBTVEsY0FBY2YscURBQUlBLENBQUNZO0lBQ3pCLElBQUlILFNBQVM7UUFDVEcsUUFBUUksZ0JBQWdCLENBQUMsaUJBQWlCLENBQUNDO1lBQ3ZDUixRQUFRVCxxREFBSUEsQ0FBQ1ksUUFBUU0sTUFBTSxHQUFHRCxNQUFNRSxVQUFVLEVBQUVGLE1BQU1HLFVBQVUsRUFBRXBCLHFEQUFJQSxDQUFDWSxRQUFRUyxXQUFXLEdBQUdKO1FBQ2pHO0lBQ0o7SUFDQSxJQUFJVCxTQUFTO1FBQ1RJLFFBQVFJLGdCQUFnQixDQUFDLFdBQVcsQ0FBQ0MsUUFBVVQsUUFDL0MscUZBQXFGO1lBQ3JGUyxNQUFNRSxVQUFVLEVBQUVGLE1BQU1HLFVBQVUsRUFBRUg7SUFDeEM7SUFDQUYsWUFDS08sSUFBSSxDQUFDLENBQUNDO1FBQ1AsSUFBSVosWUFDQVksR0FBR1AsZ0JBQWdCLENBQUMsU0FBUyxJQUFNTDtRQUN2QyxJQUFJRCxVQUFVO1lBQ1ZhLEdBQUdQLGdCQUFnQixDQUFDLGlCQUFpQixDQUFDQyxRQUFVUCxTQUFTTyxNQUFNRSxVQUFVLEVBQUVGLE1BQU1HLFVBQVUsRUFBRUg7UUFDakc7SUFDSixHQUNLTyxLQUFLLENBQUMsS0FBUTtJQUNuQixPQUFPVDtBQUNYO0FBQ0E7Ozs7Q0FJQyxHQUNELFNBQVNVLFNBQVNuQixJQUFJLEVBQUUsRUFBRUUsT0FBTyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ3BDLE1BQU1JLFVBQVVDLFVBQVVhLGNBQWMsQ0FBQ3BCO0lBQ3pDLElBQUlFLFNBQVM7UUFDVEksUUFBUUksZ0JBQWdCLENBQUMsV0FBVyxDQUFDQyxRQUFVVCxRQUMvQyxxRkFBcUY7WUFDckZTLE1BQU1FLFVBQVUsRUFBRUY7SUFDdEI7SUFDQSxPQUFPakIscURBQUlBLENBQUNZLFNBQVNVLElBQUksQ0FBQyxJQUFNSztBQUNwQztBQUVBLE1BQU1DLGNBQWM7SUFBQztJQUFPO0lBQVU7SUFBVTtJQUFjO0NBQVE7QUFDdEUsTUFBTUMsZUFBZTtJQUFDO0lBQU87SUFBTztJQUFVO0NBQVE7QUFDdEQsTUFBTUMsZ0JBQWdCLElBQUlDO0FBQzFCLFNBQVNDLFVBQVVDLE1BQU0sRUFBRUMsSUFBSTtJQUMzQixJQUFJLENBQUVELENBQUFBLGtCQUFrQkUsZUFDcEIsQ0FBRUQsQ0FBQUEsUUFBUUQsTUFBSyxLQUNmLE9BQU9DLFNBQVMsUUFBTyxHQUFJO1FBQzNCO0lBQ0o7SUFDQSxJQUFJSixjQUFjTSxHQUFHLENBQUNGLE9BQ2xCLE9BQU9KLGNBQWNNLEdBQUcsQ0FBQ0Y7SUFDN0IsTUFBTUcsaUJBQWlCSCxLQUFLSSxPQUFPLENBQUMsY0FBYztJQUNsRCxNQUFNQyxXQUFXTCxTQUFTRztJQUMxQixNQUFNRyxVQUFVWCxhQUFhWSxRQUFRLENBQUNKO0lBQ3RDLElBQ0EsNEVBQTRFO0lBQzVFLENBQUVBLENBQUFBLGtCQUFrQixDQUFDRSxXQUFXRyxXQUFXQyxjQUFhLEVBQUdDLFNBQVMsS0FDaEUsQ0FBRUosQ0FBQUEsV0FBV1osWUFBWWEsUUFBUSxDQUFDSixlQUFjLEdBQUk7UUFDcEQ7SUFDSjtJQUNBLE1BQU1RLFNBQVMsZUFBZ0JDLFNBQVMsRUFBRSxHQUFHQyxJQUFJO1FBQzdDLHdFQUF3RTtRQUN4RSxNQUFNQyxLQUFLLElBQUksQ0FBQzNCLFdBQVcsQ0FBQ3lCLFdBQVdOLFVBQVUsY0FBYztRQUMvRCxJQUFJUCxTQUFTZSxHQUFHQyxLQUFLO1FBQ3JCLElBQUlWLFVBQ0FOLFNBQVNBLE9BQU9pQixLQUFLLENBQUNILEtBQUtJLEtBQUs7UUFDcEMsNkJBQTZCO1FBQzdCLDZEQUE2RDtRQUM3RCx1Q0FBdUM7UUFDdkMsOEJBQThCO1FBQzlCLHNEQUFzRDtRQUN0RCxPQUFPLENBQUMsTUFBTUMsUUFBUUMsR0FBRyxDQUFDO1lBQ3RCcEIsTUFBTSxDQUFDSSxlQUFlLElBQUlVO1lBQzFCUCxXQUFXUSxHQUFHTSxJQUFJO1NBQ3JCLEVBQUUsQ0FBQyxFQUFFO0lBQ1Y7SUFDQXhCLGNBQWN5QixHQUFHLENBQUNyQixNQUFNVztJQUN4QixPQUFPQTtBQUNYO0FBQ0EzQyxxREFBWUEsQ0FBQyxDQUFDc0QsV0FBYztRQUN4QixHQUFHQSxRQUFRO1FBQ1hwQixLQUFLLENBQUNILFFBQVFDLE1BQU11QixXQUFhekIsVUFBVUMsUUFBUUMsU0FBU3NCLFNBQVNwQixHQUFHLENBQUNILFFBQVFDLE1BQU11QjtRQUN2RkMsS0FBSyxDQUFDekIsUUFBUUMsT0FBUyxDQUFDLENBQUNGLFVBQVVDLFFBQVFDLFNBQVNzQixTQUFTRSxHQUFHLENBQUN6QixRQUFRQztJQUM3RTtBQUU0QiIsInNvdXJjZXMiOlsid2VicGFjazovL2Z1c2lvbi1jbHViLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvaWRiL2J1aWxkL2luZGV4LmpzPzkxMzQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdyBhcyB3cmFwLCByIGFzIHJlcGxhY2VUcmFwcyB9IGZyb20gJy4vd3JhcC1pZGItdmFsdWUuanMnO1xyXG5leHBvcnQgeyB1IGFzIHVud3JhcCwgdyBhcyB3cmFwIH0gZnJvbSAnLi93cmFwLWlkYi12YWx1ZS5qcyc7XHJcblxyXG4vKipcclxuICogT3BlbiBhIGRhdGFiYXNlLlxyXG4gKlxyXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBkYXRhYmFzZS5cclxuICogQHBhcmFtIHZlcnNpb24gU2NoZW1hIHZlcnNpb24uXHJcbiAqIEBwYXJhbSBjYWxsYmFja3MgQWRkaXRpb25hbCBjYWxsYmFja3MuXHJcbiAqL1xyXG5mdW5jdGlvbiBvcGVuREIobmFtZSwgdmVyc2lvbiwgeyBibG9ja2VkLCB1cGdyYWRlLCBibG9ja2luZywgdGVybWluYXRlZCB9ID0ge30pIHtcclxuICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3BlbihuYW1lLCB2ZXJzaW9uKTtcclxuICAgIGNvbnN0IG9wZW5Qcm9taXNlID0gd3JhcChyZXF1ZXN0KTtcclxuICAgIGlmICh1cGdyYWRlKSB7XHJcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCd1cGdyYWRlbmVlZGVkJywgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHVwZ3JhZGUod3JhcChyZXF1ZXN0LnJlc3VsdCksIGV2ZW50Lm9sZFZlcnNpb24sIGV2ZW50Lm5ld1ZlcnNpb24sIHdyYXAocmVxdWVzdC50cmFuc2FjdGlvbiksIGV2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChibG9ja2VkKSB7XHJcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdibG9ja2VkJywgKGV2ZW50KSA9PiBibG9ja2VkKFxyXG4gICAgICAgIC8vIENhc3RpbmcgZHVlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC1ET00tbGliLWdlbmVyYXRvci9wdWxsLzE0MDVcclxuICAgICAgICBldmVudC5vbGRWZXJzaW9uLCBldmVudC5uZXdWZXJzaW9uLCBldmVudCkpO1xyXG4gICAgfVxyXG4gICAgb3BlblByb21pc2VcclxuICAgICAgICAudGhlbigoZGIpID0+IHtcclxuICAgICAgICBpZiAodGVybWluYXRlZClcclxuICAgICAgICAgICAgZGIuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCAoKSA9PiB0ZXJtaW5hdGVkKCkpO1xyXG4gICAgICAgIGlmIChibG9ja2luZykge1xyXG4gICAgICAgICAgICBkYi5hZGRFdmVudExpc3RlbmVyKCd2ZXJzaW9uY2hhbmdlJywgKGV2ZW50KSA9PiBibG9ja2luZyhldmVudC5vbGRWZXJzaW9uLCBldmVudC5uZXdWZXJzaW9uLCBldmVudCkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pXHJcbiAgICAgICAgLmNhdGNoKCgpID0+IHsgfSk7XHJcbiAgICByZXR1cm4gb3BlblByb21pc2U7XHJcbn1cclxuLyoqXHJcbiAqIERlbGV0ZSBhIGRhdGFiYXNlLlxyXG4gKlxyXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBkYXRhYmFzZS5cclxuICovXHJcbmZ1bmN0aW9uIGRlbGV0ZURCKG5hbWUsIHsgYmxvY2tlZCB9ID0ge30pIHtcclxuICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIuZGVsZXRlRGF0YWJhc2UobmFtZSk7XHJcbiAgICBpZiAoYmxvY2tlZCkge1xyXG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignYmxvY2tlZCcsIChldmVudCkgPT4gYmxvY2tlZChcclxuICAgICAgICAvLyBDYXN0aW5nIGR1ZSB0byBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQtRE9NLWxpYi1nZW5lcmF0b3IvcHVsbC8xNDA1XHJcbiAgICAgICAgZXZlbnQub2xkVmVyc2lvbiwgZXZlbnQpKTtcclxuICAgIH1cclxuICAgIHJldHVybiB3cmFwKHJlcXVlc3QpLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcclxufVxyXG5cclxuY29uc3QgcmVhZE1ldGhvZHMgPSBbJ2dldCcsICdnZXRLZXknLCAnZ2V0QWxsJywgJ2dldEFsbEtleXMnLCAnY291bnQnXTtcclxuY29uc3Qgd3JpdGVNZXRob2RzID0gWydwdXQnLCAnYWRkJywgJ2RlbGV0ZScsICdjbGVhciddO1xyXG5jb25zdCBjYWNoZWRNZXRob2RzID0gbmV3IE1hcCgpO1xyXG5mdW5jdGlvbiBnZXRNZXRob2QodGFyZ2V0LCBwcm9wKSB7XHJcbiAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBJREJEYXRhYmFzZSAmJlxyXG4gICAgICAgICEocHJvcCBpbiB0YXJnZXQpICYmXHJcbiAgICAgICAgdHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChjYWNoZWRNZXRob2RzLmdldChwcm9wKSlcclxuICAgICAgICByZXR1cm4gY2FjaGVkTWV0aG9kcy5nZXQocHJvcCk7XHJcbiAgICBjb25zdCB0YXJnZXRGdW5jTmFtZSA9IHByb3AucmVwbGFjZSgvRnJvbUluZGV4JC8sICcnKTtcclxuICAgIGNvbnN0IHVzZUluZGV4ID0gcHJvcCAhPT0gdGFyZ2V0RnVuY05hbWU7XHJcbiAgICBjb25zdCBpc1dyaXRlID0gd3JpdGVNZXRob2RzLmluY2x1ZGVzKHRhcmdldEZ1bmNOYW1lKTtcclxuICAgIGlmIChcclxuICAgIC8vIEJhaWwgaWYgdGhlIHRhcmdldCBkb2Vzbid0IGV4aXN0IG9uIHRoZSB0YXJnZXQuIEVnLCBnZXRBbGwgaXNuJ3QgaW4gRWRnZS5cclxuICAgICEodGFyZ2V0RnVuY05hbWUgaW4gKHVzZUluZGV4ID8gSURCSW5kZXggOiBJREJPYmplY3RTdG9yZSkucHJvdG90eXBlKSB8fFxyXG4gICAgICAgICEoaXNXcml0ZSB8fCByZWFkTWV0aG9kcy5pbmNsdWRlcyh0YXJnZXRGdW5jTmFtZSkpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbWV0aG9kID0gYXN5bmMgZnVuY3Rpb24gKHN0b3JlTmFtZSwgLi4uYXJncykge1xyXG4gICAgICAgIC8vIGlzV3JpdGUgPyAncmVhZHdyaXRlJyA6IHVuZGVmaW5lZCBnemlwcHMgYmV0dGVyLCBidXQgZmFpbHMgaW4gRWRnZSA6KFxyXG4gICAgICAgIGNvbnN0IHR4ID0gdGhpcy50cmFuc2FjdGlvbihzdG9yZU5hbWUsIGlzV3JpdGUgPyAncmVhZHdyaXRlJyA6ICdyZWFkb25seScpO1xyXG4gICAgICAgIGxldCB0YXJnZXQgPSB0eC5zdG9yZTtcclxuICAgICAgICBpZiAodXNlSW5kZXgpXHJcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5pbmRleChhcmdzLnNoaWZ0KCkpO1xyXG4gICAgICAgIC8vIE11c3QgcmVqZWN0IGlmIG9wIHJlamVjdHMuXHJcbiAgICAgICAgLy8gSWYgaXQncyBhIHdyaXRlIG9wZXJhdGlvbiwgbXVzdCByZWplY3QgaWYgdHguZG9uZSByZWplY3RzLlxyXG4gICAgICAgIC8vIE11c3QgcmVqZWN0IHdpdGggb3AgcmVqZWN0aW9uIGZpcnN0LlxyXG4gICAgICAgIC8vIE11c3QgcmVzb2x2ZSB3aXRoIG9wIHZhbHVlLlxyXG4gICAgICAgIC8vIE11c3QgaGFuZGxlIGJvdGggcHJvbWlzZXMgKG5vIHVuaGFuZGxlZCByZWplY3Rpb25zKVxyXG4gICAgICAgIHJldHVybiAoYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICB0YXJnZXRbdGFyZ2V0RnVuY05hbWVdKC4uLmFyZ3MpLFxyXG4gICAgICAgICAgICBpc1dyaXRlICYmIHR4LmRvbmUsXHJcbiAgICAgICAgXSkpWzBdO1xyXG4gICAgfTtcclxuICAgIGNhY2hlZE1ldGhvZHMuc2V0KHByb3AsIG1ldGhvZCk7XHJcbiAgICByZXR1cm4gbWV0aG9kO1xyXG59XHJcbnJlcGxhY2VUcmFwcygob2xkVHJhcHMpID0+ICh7XHJcbiAgICAuLi5vbGRUcmFwcyxcclxuICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IGdldE1ldGhvZCh0YXJnZXQsIHByb3ApIHx8IG9sZFRyYXBzLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSxcclxuICAgIGhhczogKHRhcmdldCwgcHJvcCkgPT4gISFnZXRNZXRob2QodGFyZ2V0LCBwcm9wKSB8fCBvbGRUcmFwcy5oYXModGFyZ2V0LCBwcm9wKSxcclxufSkpO1xyXG5cclxuZXhwb3J0IHsgZGVsZXRlREIsIG9wZW5EQiB9O1xyXG4iXSwibmFtZXMiOlsidyIsIndyYXAiLCJyIiwicmVwbGFjZVRyYXBzIiwidSIsInVud3JhcCIsIm9wZW5EQiIsIm5hbWUiLCJ2ZXJzaW9uIiwiYmxvY2tlZCIsInVwZ3JhZGUiLCJibG9ja2luZyIsInRlcm1pbmF0ZWQiLCJyZXF1ZXN0IiwiaW5kZXhlZERCIiwib3BlbiIsIm9wZW5Qcm9taXNlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwicmVzdWx0Iiwib2xkVmVyc2lvbiIsIm5ld1ZlcnNpb24iLCJ0cmFuc2FjdGlvbiIsInRoZW4iLCJkYiIsImNhdGNoIiwiZGVsZXRlREIiLCJkZWxldGVEYXRhYmFzZSIsInVuZGVmaW5lZCIsInJlYWRNZXRob2RzIiwid3JpdGVNZXRob2RzIiwiY2FjaGVkTWV0aG9kcyIsIk1hcCIsImdldE1ldGhvZCIsInRhcmdldCIsInByb3AiLCJJREJEYXRhYmFzZSIsImdldCIsInRhcmdldEZ1bmNOYW1lIiwicmVwbGFjZSIsInVzZUluZGV4IiwiaXNXcml0ZSIsImluY2x1ZGVzIiwiSURCSW5kZXgiLCJJREJPYmplY3RTdG9yZSIsInByb3RvdHlwZSIsIm1ldGhvZCIsInN0b3JlTmFtZSIsImFyZ3MiLCJ0eCIsInN0b3JlIiwiaW5kZXgiLCJzaGlmdCIsIlByb21pc2UiLCJhbGwiLCJkb25lIiwic2V0Iiwib2xkVHJhcHMiLCJyZWNlaXZlciIsImhhcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/idb/build/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/idb/build/wrap-idb-value.js":
/*!**************************************************!*\
  !*** ./node_modules/idb/build/wrap-idb-value.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ reverseTransformCache),\n/* harmony export */   i: () => (/* binding */ instanceOfAny),\n/* harmony export */   r: () => (/* binding */ replaceTraps),\n/* harmony export */   u: () => (/* binding */ unwrap),\n/* harmony export */   w: () => (/* binding */ wrap)\n/* harmony export */ });\nconst instanceOfAny = (object, constructors)=>constructors.some((c)=>object instanceof c);\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return idbProxyableTypes || (idbProxyableTypes = [\n        IDBDatabase,\n        IDBObjectStore,\n        IDBIndex,\n        IDBCursor,\n        IDBTransaction\n    ]);\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return cursorAdvanceMethods || (cursorAdvanceMethods = [\n        IDBCursor.prototype.advance,\n        IDBCursor.prototype.continue,\n        IDBCursor.prototype.continuePrimaryKey\n    ]);\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject)=>{\n        const unlisten = ()=>{\n            request.removeEventListener(\"success\", success);\n            request.removeEventListener(\"error\", error);\n        };\n        const success = ()=>{\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = ()=>{\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener(\"success\", success);\n        request.addEventListener(\"error\", error);\n    });\n    promise.then((value)=>{\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n    // Catching to avoid \"Uncaught Promise exceptions\"\n    }).catch(()=>{});\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx)) return;\n    const done = new Promise((resolve, reject)=>{\n        const unlisten = ()=>{\n            tx.removeEventListener(\"complete\", complete);\n            tx.removeEventListener(\"error\", error);\n            tx.removeEventListener(\"abort\", error);\n        };\n        const complete = ()=>{\n            resolve();\n            unlisten();\n        };\n        const error = ()=>{\n            reject(tx.error || new DOMException(\"AbortError\", \"AbortError\"));\n            unlisten();\n        };\n        tx.addEventListener(\"complete\", complete);\n        tx.addEventListener(\"error\", error);\n        tx.addEventListener(\"abort\", error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get (target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === \"done\") return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === \"objectStoreNames\") {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === \"store\") {\n                return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set (target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has (target, prop) {\n        if (target instanceof IDBTransaction && (prop === \"done\" || prop === \"store\")) {\n            return true;\n        }\n        return prop in target;\n    }\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction && !(\"objectStoreNames\" in IDBTransaction.prototype)) {\n        return function(storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [\n                storeNames\n            ]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function(...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function(...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === \"function\") return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest) return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value)) return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value)=>reverseTransformCache.get(value);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaWRiL2J1aWxkL3dyYXAtaWRiLXZhbHVlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsTUFBTUEsZ0JBQWdCLENBQUNDLFFBQVFDLGVBQWlCQSxhQUFhQyxJQUFJLENBQUMsQ0FBQ0MsSUFBTUgsa0JBQWtCRztBQUUzRixJQUFJQztBQUNKLElBQUlDO0FBQ0oscUVBQXFFO0FBQ3JFLFNBQVNDO0lBQ0wsT0FBUUYscUJBQ0hBLENBQUFBLG9CQUFvQjtRQUNqQkc7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7S0FDSDtBQUNUO0FBQ0EscUVBQXFFO0FBQ3JFLFNBQVNDO0lBQ0wsT0FBUVAsd0JBQ0hBLENBQUFBLHVCQUF1QjtRQUNwQkssVUFBVUcsU0FBUyxDQUFDQyxPQUFPO1FBQzNCSixVQUFVRyxTQUFTLENBQUNFLFFBQVE7UUFDNUJMLFVBQVVHLFNBQVMsQ0FBQ0csa0JBQWtCO0tBQ3pDO0FBQ1Q7QUFDQSxNQUFNQyxtQkFBbUIsSUFBSUM7QUFDN0IsTUFBTUMscUJBQXFCLElBQUlEO0FBQy9CLE1BQU1FLDJCQUEyQixJQUFJRjtBQUNyQyxNQUFNRyxpQkFBaUIsSUFBSUg7QUFDM0IsTUFBTUksd0JBQXdCLElBQUlKO0FBQ2xDLFNBQVNLLGlCQUFpQkMsT0FBTztJQUM3QixNQUFNQyxVQUFVLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7UUFDbEMsTUFBTUMsV0FBVztZQUNiTCxRQUFRTSxtQkFBbUIsQ0FBQyxXQUFXQztZQUN2Q1AsUUFBUU0sbUJBQW1CLENBQUMsU0FBU0U7UUFDekM7UUFDQSxNQUFNRCxVQUFVO1lBQ1pKLFFBQVFNLEtBQUtULFFBQVFVLE1BQU07WUFDM0JMO1FBQ0o7UUFDQSxNQUFNRyxRQUFRO1lBQ1ZKLE9BQU9KLFFBQVFRLEtBQUs7WUFDcEJIO1FBQ0o7UUFDQUwsUUFBUVcsZ0JBQWdCLENBQUMsV0FBV0o7UUFDcENQLFFBQVFXLGdCQUFnQixDQUFDLFNBQVNIO0lBQ3RDO0lBQ0FQLFFBQ0tXLElBQUksQ0FBQyxDQUFDQztRQUNQLGtGQUFrRjtRQUNsRixzQkFBc0I7UUFDdEIsSUFBSUEsaUJBQWlCM0IsV0FBVztZQUM1Qk8saUJBQWlCcUIsR0FBRyxDQUFDRCxPQUFPYjtRQUNoQztJQUNBLGtEQUFrRDtJQUN0RCxHQUNLZSxLQUFLLENBQUMsS0FBUTtJQUNuQixpR0FBaUc7SUFDakcsK0RBQStEO0lBQy9EakIsc0JBQXNCZ0IsR0FBRyxDQUFDYixTQUFTRDtJQUNuQyxPQUFPQztBQUNYO0FBQ0EsU0FBU2UsK0JBQStCQyxFQUFFO0lBQ3RDLDJFQUEyRTtJQUMzRSxJQUFJdEIsbUJBQW1CdUIsR0FBRyxDQUFDRCxLQUN2QjtJQUNKLE1BQU1FLE9BQU8sSUFBSWpCLFFBQVEsQ0FBQ0MsU0FBU0M7UUFDL0IsTUFBTUMsV0FBVztZQUNiWSxHQUFHWCxtQkFBbUIsQ0FBQyxZQUFZYztZQUNuQ0gsR0FBR1gsbUJBQW1CLENBQUMsU0FBU0U7WUFDaENTLEdBQUdYLG1CQUFtQixDQUFDLFNBQVNFO1FBQ3BDO1FBQ0EsTUFBTVksV0FBVztZQUNiakI7WUFDQUU7UUFDSjtRQUNBLE1BQU1HLFFBQVE7WUFDVkosT0FBT2EsR0FBR1QsS0FBSyxJQUFJLElBQUlhLGFBQWEsY0FBYztZQUNsRGhCO1FBQ0o7UUFDQVksR0FBR04sZ0JBQWdCLENBQUMsWUFBWVM7UUFDaENILEdBQUdOLGdCQUFnQixDQUFDLFNBQVNIO1FBQzdCUyxHQUFHTixnQkFBZ0IsQ0FBQyxTQUFTSDtJQUNqQztJQUNBLGdDQUFnQztJQUNoQ2IsbUJBQW1CbUIsR0FBRyxDQUFDRyxJQUFJRTtBQUMvQjtBQUNBLElBQUlHLGdCQUFnQjtJQUNoQkMsS0FBSUMsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLFFBQVE7UUFDdEIsSUFBSUYsa0JBQWtCckMsZ0JBQWdCO1lBQ2xDLHlDQUF5QztZQUN6QyxJQUFJc0MsU0FBUyxRQUNULE9BQU85QixtQkFBbUI0QixHQUFHLENBQUNDO1lBQ2xDLGlEQUFpRDtZQUNqRCxJQUFJQyxTQUFTLG9CQUFvQjtnQkFDN0IsT0FBT0QsT0FBT0csZ0JBQWdCLElBQUkvQix5QkFBeUIyQixHQUFHLENBQUNDO1lBQ25FO1lBQ0EsMEZBQTBGO1lBQzFGLElBQUlDLFNBQVMsU0FBUztnQkFDbEIsT0FBT0MsU0FBU0MsZ0JBQWdCLENBQUMsRUFBRSxHQUM3QkMsWUFDQUYsU0FBU0csV0FBVyxDQUFDSCxTQUFTQyxnQkFBZ0IsQ0FBQyxFQUFFO1lBQzNEO1FBQ0o7UUFDQSx1Q0FBdUM7UUFDdkMsT0FBT2xCLEtBQUtlLE1BQU0sQ0FBQ0MsS0FBSztJQUM1QjtJQUNBWCxLQUFJVSxNQUFNLEVBQUVDLElBQUksRUFBRVosS0FBSztRQUNuQlcsTUFBTSxDQUFDQyxLQUFLLEdBQUdaO1FBQ2YsT0FBTztJQUNYO0lBQ0FLLEtBQUlNLE1BQU0sRUFBRUMsSUFBSTtRQUNaLElBQUlELGtCQUFrQnJDLGtCQUNqQnNDLENBQUFBLFNBQVMsVUFBVUEsU0FBUyxPQUFNLEdBQUk7WUFDdkMsT0FBTztRQUNYO1FBQ0EsT0FBT0EsUUFBUUQ7SUFDbkI7QUFDSjtBQUNBLFNBQVNNLGFBQWFDLFFBQVE7SUFDMUJULGdCQUFnQlMsU0FBU1Q7QUFDN0I7QUFDQSxTQUFTVSxhQUFhQyxJQUFJO0lBQ3RCLG1GQUFtRjtJQUNuRixxQ0FBcUM7SUFDckMsd0VBQXdFO0lBQ3hFLElBQUlBLFNBQVNsRCxZQUFZTSxTQUFTLENBQUM2QyxXQUFXLElBQzFDLENBQUUsdUJBQXNCL0MsZUFBZUUsU0FBUyxHQUFHO1FBQ25ELE9BQU8sU0FBVThDLFVBQVUsRUFBRSxHQUFHQyxJQUFJO1lBQ2hDLE1BQU1uQixLQUFLZ0IsS0FBS0ksSUFBSSxDQUFDQyxPQUFPLElBQUksR0FBR0gsZUFBZUM7WUFDbER4Qyx5QkFBeUJrQixHQUFHLENBQUNHLElBQUlrQixXQUFXSSxJQUFJLEdBQUdKLFdBQVdJLElBQUksS0FBSztnQkFBQ0o7YUFBVztZQUNuRixPQUFPMUIsS0FBS1E7UUFDaEI7SUFDSjtJQUNBLDhGQUE4RjtJQUM5RiwrRkFBK0Y7SUFDL0YsK0ZBQStGO0lBQy9GLDhGQUE4RjtJQUM5Rix1REFBdUQ7SUFDdkQsSUFBSTdCLDBCQUEwQm9ELFFBQVEsQ0FBQ1AsT0FBTztRQUMxQyxPQUFPLFNBQVUsR0FBR0csSUFBSTtZQUNwQiw4RkFBOEY7WUFDOUYsdUJBQXVCO1lBQ3ZCSCxLQUFLUSxLQUFLLENBQUNILE9BQU8sSUFBSSxHQUFHRjtZQUN6QixPQUFPM0IsS0FBS2hCLGlCQUFpQjhCLEdBQUcsQ0FBQyxJQUFJO1FBQ3pDO0lBQ0o7SUFDQSxPQUFPLFNBQVUsR0FBR2EsSUFBSTtRQUNwQiw4RkFBOEY7UUFDOUYsdUJBQXVCO1FBQ3ZCLE9BQU8zQixLQUFLd0IsS0FBS1EsS0FBSyxDQUFDSCxPQUFPLElBQUksR0FBR0Y7SUFDekM7QUFDSjtBQUNBLFNBQVNNLHVCQUF1QjdCLEtBQUs7SUFDakMsSUFBSSxPQUFPQSxVQUFVLFlBQ2pCLE9BQU9tQixhQUFhbkI7SUFDeEIsNkVBQTZFO0lBQzdFLHVFQUF1RTtJQUN2RSxJQUFJQSxpQkFBaUIxQixnQkFDakI2QiwrQkFBK0JIO0lBQ25DLElBQUl0QyxjQUFjc0MsT0FBTy9CLHlCQUNyQixPQUFPLElBQUk2RCxNQUFNOUIsT0FBT1M7SUFDNUIsaUVBQWlFO0lBQ2pFLE9BQU9UO0FBQ1g7QUFDQSxTQUFTSixLQUFLSSxLQUFLO0lBQ2YsZ0dBQWdHO0lBQ2hHLDJGQUEyRjtJQUMzRixJQUFJQSxpQkFBaUIrQixZQUNqQixPQUFPN0MsaUJBQWlCYztJQUM1QiwrRUFBK0U7SUFDL0Usd0RBQXdEO0lBQ3hELElBQUloQixlQUFlcUIsR0FBRyxDQUFDTCxRQUNuQixPQUFPaEIsZUFBZTBCLEdBQUcsQ0FBQ1Y7SUFDOUIsTUFBTWdDLFdBQVdILHVCQUF1QjdCO0lBQ3hDLGlDQUFpQztJQUNqQywrREFBK0Q7SUFDL0QsSUFBSWdDLGFBQWFoQyxPQUFPO1FBQ3BCaEIsZUFBZWlCLEdBQUcsQ0FBQ0QsT0FBT2dDO1FBQzFCL0Msc0JBQXNCZ0IsR0FBRyxDQUFDK0IsVUFBVWhDO0lBQ3hDO0lBQ0EsT0FBT2dDO0FBQ1g7QUFDQSxNQUFNUCxTQUFTLENBQUN6QixRQUFVZixzQkFBc0J5QixHQUFHLENBQUNWO0FBRWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnVzaW9uLWNsdWItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9pZGIvYnVpbGQvd3JhcC1pZGItdmFsdWUuanM/ODY5YyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBpbnN0YW5jZU9mQW55ID0gKG9iamVjdCwgY29uc3RydWN0b3JzKSA9PiBjb25zdHJ1Y3RvcnMuc29tZSgoYykgPT4gb2JqZWN0IGluc3RhbmNlb2YgYyk7XHJcblxyXG5sZXQgaWRiUHJveHlhYmxlVHlwZXM7XHJcbmxldCBjdXJzb3JBZHZhbmNlTWV0aG9kcztcclxuLy8gVGhpcyBpcyBhIGZ1bmN0aW9uIHRvIHByZXZlbnQgaXQgdGhyb3dpbmcgdXAgaW4gbm9kZSBlbnZpcm9ubWVudHMuXHJcbmZ1bmN0aW9uIGdldElkYlByb3h5YWJsZVR5cGVzKCkge1xyXG4gICAgcmV0dXJuIChpZGJQcm94eWFibGVUeXBlcyB8fFxyXG4gICAgICAgIChpZGJQcm94eWFibGVUeXBlcyA9IFtcclxuICAgICAgICAgICAgSURCRGF0YWJhc2UsXHJcbiAgICAgICAgICAgIElEQk9iamVjdFN0b3JlLFxyXG4gICAgICAgICAgICBJREJJbmRleCxcclxuICAgICAgICAgICAgSURCQ3Vyc29yLFxyXG4gICAgICAgICAgICBJREJUcmFuc2FjdGlvbixcclxuICAgICAgICBdKSk7XHJcbn1cclxuLy8gVGhpcyBpcyBhIGZ1bmN0aW9uIHRvIHByZXZlbnQgaXQgdGhyb3dpbmcgdXAgaW4gbm9kZSBlbnZpcm9ubWVudHMuXHJcbmZ1bmN0aW9uIGdldEN1cnNvckFkdmFuY2VNZXRob2RzKCkge1xyXG4gICAgcmV0dXJuIChjdXJzb3JBZHZhbmNlTWV0aG9kcyB8fFxyXG4gICAgICAgIChjdXJzb3JBZHZhbmNlTWV0aG9kcyA9IFtcclxuICAgICAgICAgICAgSURCQ3Vyc29yLnByb3RvdHlwZS5hZHZhbmNlLFxyXG4gICAgICAgICAgICBJREJDdXJzb3IucHJvdG90eXBlLmNvbnRpbnVlLFxyXG4gICAgICAgICAgICBJREJDdXJzb3IucHJvdG90eXBlLmNvbnRpbnVlUHJpbWFyeUtleSxcclxuICAgICAgICBdKSk7XHJcbn1cclxuY29uc3QgY3Vyc29yUmVxdWVzdE1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IHRyYW5zYWN0aW9uRG9uZU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IHRyYW5zYWN0aW9uU3RvcmVOYW1lc01hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IHRyYW5zZm9ybUNhY2hlID0gbmV3IFdlYWtNYXAoKTtcclxuY29uc3QgcmV2ZXJzZVRyYW5zZm9ybUNhY2hlID0gbmV3IFdlYWtNYXAoKTtcclxuZnVuY3Rpb24gcHJvbWlzaWZ5UmVxdWVzdChyZXF1ZXN0KSB7XHJcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHVubGlzdGVuID0gKCkgPT4ge1xyXG4gICAgICAgICAgICByZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N1Y2Nlc3MnLCBzdWNjZXNzKTtcclxuICAgICAgICAgICAgcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHJlc29sdmUod3JhcChyZXF1ZXN0LnJlc3VsdCkpO1xyXG4gICAgICAgICAgICB1bmxpc3RlbigpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHJlamVjdChyZXF1ZXN0LmVycm9yKTtcclxuICAgICAgICAgICAgdW5saXN0ZW4oKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignc3VjY2VzcycsIHN1Y2Nlc3MpO1xyXG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvcik7XHJcbiAgICB9KTtcclxuICAgIHByb21pc2VcclxuICAgICAgICAudGhlbigodmFsdWUpID0+IHtcclxuICAgICAgICAvLyBTaW5jZSBjdXJzb3JpbmcgcmV1c2VzIHRoZSBJREJSZXF1ZXN0ICgqc2lnaCopLCB3ZSBjYWNoZSBpdCBmb3IgbGF0ZXIgcmV0cmlldmFsXHJcbiAgICAgICAgLy8gKHNlZSB3cmFwRnVuY3Rpb24pLlxyXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIElEQkN1cnNvcikge1xyXG4gICAgICAgICAgICBjdXJzb3JSZXF1ZXN0TWFwLnNldCh2YWx1ZSwgcmVxdWVzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENhdGNoaW5nIHRvIGF2b2lkIFwiVW5jYXVnaHQgUHJvbWlzZSBleGNlcHRpb25zXCJcclxuICAgIH0pXHJcbiAgICAgICAgLmNhdGNoKCgpID0+IHsgfSk7XHJcbiAgICAvLyBUaGlzIG1hcHBpbmcgZXhpc3RzIGluIHJldmVyc2VUcmFuc2Zvcm1DYWNoZSBidXQgZG9lc24ndCBkb2Vzbid0IGV4aXN0IGluIHRyYW5zZm9ybUNhY2hlLiBUaGlzXHJcbiAgICAvLyBpcyBiZWNhdXNlIHdlIGNyZWF0ZSBtYW55IHByb21pc2VzIGZyb20gYSBzaW5nbGUgSURCUmVxdWVzdC5cclxuICAgIHJldmVyc2VUcmFuc2Zvcm1DYWNoZS5zZXQocHJvbWlzZSwgcmVxdWVzdCk7XHJcbiAgICByZXR1cm4gcHJvbWlzZTtcclxufVxyXG5mdW5jdGlvbiBjYWNoZURvbmVQcm9taXNlRm9yVHJhbnNhY3Rpb24odHgpIHtcclxuICAgIC8vIEVhcmx5IGJhaWwgaWYgd2UndmUgYWxyZWFkeSBjcmVhdGVkIGEgZG9uZSBwcm9taXNlIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxyXG4gICAgaWYgKHRyYW5zYWN0aW9uRG9uZU1hcC5oYXModHgpKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGNvbnN0IGRvbmUgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgY29uc3QgdW5saXN0ZW4gPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHR4LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbXBsZXRlJywgY29tcGxldGUpO1xyXG4gICAgICAgICAgICB0eC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yKTtcclxuICAgICAgICAgICAgdHgucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBlcnJvcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB1bmxpc3RlbigpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHJlamVjdCh0eC5lcnJvciB8fCBuZXcgRE9NRXhjZXB0aW9uKCdBYm9ydEVycm9yJywgJ0Fib3J0RXJyb3InKSk7XHJcbiAgICAgICAgICAgIHVubGlzdGVuKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0eC5hZGRFdmVudExpc3RlbmVyKCdjb21wbGV0ZScsIGNvbXBsZXRlKTtcclxuICAgICAgICB0eC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yKTtcclxuICAgICAgICB0eC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGVycm9yKTtcclxuICAgIH0pO1xyXG4gICAgLy8gQ2FjaGUgaXQgZm9yIGxhdGVyIHJldHJpZXZhbC5cclxuICAgIHRyYW5zYWN0aW9uRG9uZU1hcC5zZXQodHgsIGRvbmUpO1xyXG59XHJcbmxldCBpZGJQcm94eVRyYXBzID0ge1xyXG4gICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcclxuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSURCVHJhbnNhY3Rpb24pIHtcclxuICAgICAgICAgICAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgdHJhbnNhY3Rpb24uZG9uZS5cclxuICAgICAgICAgICAgaWYgKHByb3AgPT09ICdkb25lJylcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbkRvbmVNYXAuZ2V0KHRhcmdldCk7XHJcbiAgICAgICAgICAgIC8vIFBvbHlmaWxsIGZvciBvYmplY3RTdG9yZU5hbWVzIGJlY2F1c2Ugb2YgRWRnZS5cclxuICAgICAgICAgICAgaWYgKHByb3AgPT09ICdvYmplY3RTdG9yZU5hbWVzJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5vYmplY3RTdG9yZU5hbWVzIHx8IHRyYW5zYWN0aW9uU3RvcmVOYW1lc01hcC5nZXQodGFyZ2V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBNYWtlIHR4LnN0b3JlIHJldHVybiB0aGUgb25seSBzdG9yZSBpbiB0aGUgdHJhbnNhY3Rpb24sIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBhcmUgbWFueS5cclxuICAgICAgICAgICAgaWYgKHByb3AgPT09ICdzdG9yZScpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZWNlaXZlci5vYmplY3RTdG9yZU5hbWVzWzFdXHJcbiAgICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICA6IHJlY2VpdmVyLm9iamVjdFN0b3JlKHJlY2VpdmVyLm9iamVjdFN0b3JlTmFtZXNbMF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEVsc2UgdHJhbnNmb3JtIHdoYXRldmVyIHdlIGdldCBiYWNrLlxyXG4gICAgICAgIHJldHVybiB3cmFwKHRhcmdldFtwcm9wXSk7XHJcbiAgICB9LFxyXG4gICAgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcclxuICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0sXHJcbiAgICBoYXModGFyZ2V0LCBwcm9wKSB7XHJcbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIElEQlRyYW5zYWN0aW9uICYmXHJcbiAgICAgICAgICAgIChwcm9wID09PSAnZG9uZScgfHwgcHJvcCA9PT0gJ3N0b3JlJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcm9wIGluIHRhcmdldDtcclxuICAgIH0sXHJcbn07XHJcbmZ1bmN0aW9uIHJlcGxhY2VUcmFwcyhjYWxsYmFjaykge1xyXG4gICAgaWRiUHJveHlUcmFwcyA9IGNhbGxiYWNrKGlkYlByb3h5VHJhcHMpO1xyXG59XHJcbmZ1bmN0aW9uIHdyYXBGdW5jdGlvbihmdW5jKSB7XHJcbiAgICAvLyBEdWUgdG8gZXhwZWN0ZWQgb2JqZWN0IGVxdWFsaXR5ICh3aGljaCBpcyBlbmZvcmNlZCBieSB0aGUgY2FjaGluZyBpbiBgd3JhcGApLCB3ZVxyXG4gICAgLy8gb25seSBjcmVhdGUgb25lIG5ldyBmdW5jIHBlciBmdW5jLlxyXG4gICAgLy8gRWRnZSBkb2Vzbid0IHN1cHBvcnQgb2JqZWN0U3RvcmVOYW1lcyAoYm9vbyksIHNvIHdlIHBvbHlmaWxsIGl0IGhlcmUuXHJcbiAgICBpZiAoZnVuYyA9PT0gSURCRGF0YWJhc2UucHJvdG90eXBlLnRyYW5zYWN0aW9uICYmXHJcbiAgICAgICAgISgnb2JqZWN0U3RvcmVOYW1lcycgaW4gSURCVHJhbnNhY3Rpb24ucHJvdG90eXBlKSkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RvcmVOYW1lcywgLi4uYXJncykge1xyXG4gICAgICAgICAgICBjb25zdCB0eCA9IGZ1bmMuY2FsbCh1bndyYXAodGhpcyksIHN0b3JlTmFtZXMsIC4uLmFyZ3MpO1xyXG4gICAgICAgICAgICB0cmFuc2FjdGlvblN0b3JlTmFtZXNNYXAuc2V0KHR4LCBzdG9yZU5hbWVzLnNvcnQgPyBzdG9yZU5hbWVzLnNvcnQoKSA6IFtzdG9yZU5hbWVzXSk7XHJcbiAgICAgICAgICAgIHJldHVybiB3cmFwKHR4KTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLy8gQ3Vyc29yIG1ldGhvZHMgYXJlIHNwZWNpYWwsIGFzIHRoZSBiZWhhdmlvdXIgaXMgYSBsaXR0bGUgbW9yZSBkaWZmZXJlbnQgdG8gc3RhbmRhcmQgSURCLiBJblxyXG4gICAgLy8gSURCLCB5b3UgYWR2YW5jZSB0aGUgY3Vyc29yIGFuZCB3YWl0IGZvciBhIG5ldyAnc3VjY2Vzcycgb24gdGhlIElEQlJlcXVlc3QgdGhhdCBnYXZlIHlvdSB0aGVcclxuICAgIC8vIGN1cnNvci4gSXQncyBraW5kYSBsaWtlIGEgcHJvbWlzZSB0aGF0IGNhbiByZXNvbHZlIHdpdGggbWFueSB2YWx1ZXMuIFRoYXQgZG9lc24ndCBtYWtlIHNlbnNlXHJcbiAgICAvLyB3aXRoIHJlYWwgcHJvbWlzZXMsIHNvIGVhY2ggYWR2YW5jZSBtZXRob2RzIHJldHVybnMgYSBuZXcgcHJvbWlzZSBmb3IgdGhlIGN1cnNvciBvYmplY3QsIG9yXHJcbiAgICAvLyB1bmRlZmluZWQgaWYgdGhlIGVuZCBvZiB0aGUgY3Vyc29yIGhhcyBiZWVuIHJlYWNoZWQuXHJcbiAgICBpZiAoZ2V0Q3Vyc29yQWR2YW5jZU1ldGhvZHMoKS5pbmNsdWRlcyhmdW5jKSkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgICAgICAvLyBDYWxsaW5nIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiB3aXRoIHRoZSBwcm94eSBhcyAndGhpcycgY2F1c2VzIElMTEVHQUwgSU5WT0NBVElPTiwgc28gd2UgdXNlXHJcbiAgICAgICAgICAgIC8vIHRoZSBvcmlnaW5hbCBvYmplY3QuXHJcbiAgICAgICAgICAgIGZ1bmMuYXBwbHkodW53cmFwKHRoaXMpLCBhcmdzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHdyYXAoY3Vyc29yUmVxdWVzdE1hcC5nZXQodGhpcykpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuICAgICAgICAvLyBDYWxsaW5nIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiB3aXRoIHRoZSBwcm94eSBhcyAndGhpcycgY2F1c2VzIElMTEVHQUwgSU5WT0NBVElPTiwgc28gd2UgdXNlXHJcbiAgICAgICAgLy8gdGhlIG9yaWdpbmFsIG9iamVjdC5cclxuICAgICAgICByZXR1cm4gd3JhcChmdW5jLmFwcGx5KHVud3JhcCh0aGlzKSwgYXJncykpO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1DYWNoYWJsZVZhbHVlKHZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgIHJldHVybiB3cmFwRnVuY3Rpb24odmFsdWUpO1xyXG4gICAgLy8gVGhpcyBkb2Vzbid0IHJldHVybiwgaXQganVzdCBjcmVhdGVzIGEgJ2RvbmUnIHByb21pc2UgZm9yIHRoZSB0cmFuc2FjdGlvbixcclxuICAgIC8vIHdoaWNoIGlzIGxhdGVyIHJldHVybmVkIGZvciB0cmFuc2FjdGlvbi5kb25lIChzZWUgaWRiT2JqZWN0SGFuZGxlcikuXHJcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJREJUcmFuc2FjdGlvbilcclxuICAgICAgICBjYWNoZURvbmVQcm9taXNlRm9yVHJhbnNhY3Rpb24odmFsdWUpO1xyXG4gICAgaWYgKGluc3RhbmNlT2ZBbnkodmFsdWUsIGdldElkYlByb3h5YWJsZVR5cGVzKCkpKVxyXG4gICAgICAgIHJldHVybiBuZXcgUHJveHkodmFsdWUsIGlkYlByb3h5VHJhcHMpO1xyXG4gICAgLy8gUmV0dXJuIHRoZSBzYW1lIHZhbHVlIGJhY2sgaWYgd2UncmUgbm90IGdvaW5nIHRvIHRyYW5zZm9ybSBpdC5cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG5mdW5jdGlvbiB3cmFwKHZhbHVlKSB7XHJcbiAgICAvLyBXZSBzb21ldGltZXMgZ2VuZXJhdGUgbXVsdGlwbGUgcHJvbWlzZXMgZnJvbSBhIHNpbmdsZSBJREJSZXF1ZXN0IChlZyB3aGVuIGN1cnNvcmluZyksIGJlY2F1c2VcclxuICAgIC8vIElEQiBpcyB3ZWlyZCBhbmQgYSBzaW5nbGUgSURCUmVxdWVzdCBjYW4geWllbGQgbWFueSByZXNwb25zZXMsIHNvIHRoZXNlIGNhbid0IGJlIGNhY2hlZC5cclxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIElEQlJlcXVlc3QpXHJcbiAgICAgICAgcmV0dXJuIHByb21pc2lmeVJlcXVlc3QodmFsdWUpO1xyXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSB0cmFuc2Zvcm1lZCB0aGlzIHZhbHVlIGJlZm9yZSwgcmV1c2UgdGhlIHRyYW5zZm9ybWVkIHZhbHVlLlxyXG4gICAgLy8gVGhpcyBpcyBmYXN0ZXIsIGJ1dCBpdCBhbHNvIHByb3ZpZGVzIG9iamVjdCBlcXVhbGl0eS5cclxuICAgIGlmICh0cmFuc2Zvcm1DYWNoZS5oYXModmFsdWUpKVxyXG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1DYWNoZS5nZXQodmFsdWUpO1xyXG4gICAgY29uc3QgbmV3VmFsdWUgPSB0cmFuc2Zvcm1DYWNoYWJsZVZhbHVlKHZhbHVlKTtcclxuICAgIC8vIE5vdCBhbGwgdHlwZXMgYXJlIHRyYW5zZm9ybWVkLlxyXG4gICAgLy8gVGhlc2UgbWF5IGJlIHByaW1pdGl2ZSB0eXBlcywgc28gdGhleSBjYW4ndCBiZSBXZWFrTWFwIGtleXMuXHJcbiAgICBpZiAobmV3VmFsdWUgIT09IHZhbHVlKSB7XHJcbiAgICAgICAgdHJhbnNmb3JtQ2FjaGUuc2V0KHZhbHVlLCBuZXdWYWx1ZSk7XHJcbiAgICAgICAgcmV2ZXJzZVRyYW5zZm9ybUNhY2hlLnNldChuZXdWYWx1ZSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld1ZhbHVlO1xyXG59XHJcbmNvbnN0IHVud3JhcCA9ICh2YWx1ZSkgPT4gcmV2ZXJzZVRyYW5zZm9ybUNhY2hlLmdldCh2YWx1ZSk7XHJcblxyXG5leHBvcnQgeyByZXZlcnNlVHJhbnNmb3JtQ2FjaGUgYXMgYSwgaW5zdGFuY2VPZkFueSBhcyBpLCByZXBsYWNlVHJhcHMgYXMgciwgdW53cmFwIGFzIHUsIHdyYXAgYXMgdyB9O1xyXG4iXSwibmFtZXMiOlsiaW5zdGFuY2VPZkFueSIsIm9iamVjdCIsImNvbnN0cnVjdG9ycyIsInNvbWUiLCJjIiwiaWRiUHJveHlhYmxlVHlwZXMiLCJjdXJzb3JBZHZhbmNlTWV0aG9kcyIsImdldElkYlByb3h5YWJsZVR5cGVzIiwiSURCRGF0YWJhc2UiLCJJREJPYmplY3RTdG9yZSIsIklEQkluZGV4IiwiSURCQ3Vyc29yIiwiSURCVHJhbnNhY3Rpb24iLCJnZXRDdXJzb3JBZHZhbmNlTWV0aG9kcyIsInByb3RvdHlwZSIsImFkdmFuY2UiLCJjb250aW51ZSIsImNvbnRpbnVlUHJpbWFyeUtleSIsImN1cnNvclJlcXVlc3RNYXAiLCJXZWFrTWFwIiwidHJhbnNhY3Rpb25Eb25lTWFwIiwidHJhbnNhY3Rpb25TdG9yZU5hbWVzTWFwIiwidHJhbnNmb3JtQ2FjaGUiLCJyZXZlcnNlVHJhbnNmb3JtQ2FjaGUiLCJwcm9taXNpZnlSZXF1ZXN0IiwicmVxdWVzdCIsInByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInVubGlzdGVuIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInN1Y2Nlc3MiLCJlcnJvciIsIndyYXAiLCJyZXN1bHQiLCJhZGRFdmVudExpc3RlbmVyIiwidGhlbiIsInZhbHVlIiwic2V0IiwiY2F0Y2giLCJjYWNoZURvbmVQcm9taXNlRm9yVHJhbnNhY3Rpb24iLCJ0eCIsImhhcyIsImRvbmUiLCJjb21wbGV0ZSIsIkRPTUV4Y2VwdGlvbiIsImlkYlByb3h5VHJhcHMiLCJnZXQiLCJ0YXJnZXQiLCJwcm9wIiwicmVjZWl2ZXIiLCJvYmplY3RTdG9yZU5hbWVzIiwidW5kZWZpbmVkIiwib2JqZWN0U3RvcmUiLCJyZXBsYWNlVHJhcHMiLCJjYWxsYmFjayIsIndyYXBGdW5jdGlvbiIsImZ1bmMiLCJ0cmFuc2FjdGlvbiIsInN0b3JlTmFtZXMiLCJhcmdzIiwiY2FsbCIsInVud3JhcCIsInNvcnQiLCJpbmNsdWRlcyIsImFwcGx5IiwidHJhbnNmb3JtQ2FjaGFibGVWYWx1ZSIsIlByb3h5IiwiSURCUmVxdWVzdCIsIm5ld1ZhbHVlIiwiYSIsImkiLCJyIiwidSIsInciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/idb/build/wrap-idb-value.js\n");

/***/ })

};
;