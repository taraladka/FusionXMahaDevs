"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/yup";
exports.ids = ["vendor-chunks/yup"];
exports.modules = {

/***/ "(ssr)/./node_modules/yup/index.esm.js":
/*!***************************************!*\
  !*** ./node_modules/yup/index.esm.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArraySchema: () => (/* binding */ ArraySchema),\n/* harmony export */   BooleanSchema: () => (/* binding */ BooleanSchema),\n/* harmony export */   DateSchema: () => (/* binding */ DateSchema),\n/* harmony export */   LazySchema: () => (/* binding */ Lazy),\n/* harmony export */   MixedSchema: () => (/* binding */ MixedSchema),\n/* harmony export */   NumberSchema: () => (/* binding */ NumberSchema),\n/* harmony export */   ObjectSchema: () => (/* binding */ ObjectSchema),\n/* harmony export */   Schema: () => (/* binding */ Schema),\n/* harmony export */   StringSchema: () => (/* binding */ StringSchema),\n/* harmony export */   TupleSchema: () => (/* binding */ TupleSchema),\n/* harmony export */   ValidationError: () => (/* binding */ ValidationError),\n/* harmony export */   addMethod: () => (/* binding */ addMethod),\n/* harmony export */   array: () => (/* binding */ create$2),\n/* harmony export */   bool: () => (/* binding */ create$7),\n/* harmony export */   boolean: () => (/* binding */ create$7),\n/* harmony export */   date: () => (/* binding */ create$4),\n/* harmony export */   defaultLocale: () => (/* binding */ locale),\n/* harmony export */   getIn: () => (/* binding */ getIn),\n/* harmony export */   isSchema: () => (/* binding */ isSchema),\n/* harmony export */   lazy: () => (/* binding */ create),\n/* harmony export */   mixed: () => (/* binding */ create$8),\n/* harmony export */   number: () => (/* binding */ create$5),\n/* harmony export */   object: () => (/* binding */ create$3),\n/* harmony export */   printValue: () => (/* binding */ printValue),\n/* harmony export */   reach: () => (/* binding */ reach),\n/* harmony export */   ref: () => (/* binding */ create$9),\n/* harmony export */   setLocale: () => (/* binding */ setLocale),\n/* harmony export */   string: () => (/* binding */ create$6),\n/* harmony export */   tuple: () => (/* binding */ create$1)\n/* harmony export */ });\n/* harmony import */ var property_expr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! property-expr */ \"(ssr)/./node_modules/property-expr/index.js\");\n/* harmony import */ var property_expr__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(property_expr__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var tiny_case__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-case */ \"(ssr)/./node_modules/tiny-case/index.js\");\n/* harmony import */ var tiny_case__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(tiny_case__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var toposort__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! toposort */ \"(ssr)/./node_modules/toposort/index.js\");\n/* harmony import */ var toposort__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(toposort__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nconst toString = Object.prototype.toString;\nconst errorToString = Error.prototype.toString;\nconst regExpToString = RegExp.prototype.toString;\nconst symbolToString = typeof Symbol !== \"undefined\" ? Symbol.prototype.toString : ()=>\"\";\nconst SYMBOL_REGEXP = /^Symbol\\((.*)\\)(.*)$/;\nfunction printNumber(val) {\n    if (val != +val) return \"NaN\";\n    const isNegativeZero = val === 0 && 1 / val < 0;\n    return isNegativeZero ? \"-0\" : \"\" + val;\n}\nfunction printSimpleValue(val, quoteStrings = false) {\n    if (val == null || val === true || val === false) return \"\" + val;\n    const typeOf = typeof val;\n    if (typeOf === \"number\") return printNumber(val);\n    if (typeOf === \"string\") return quoteStrings ? `\"${val}\"` : val;\n    if (typeOf === \"function\") return \"[Function \" + (val.name || \"anonymous\") + \"]\";\n    if (typeOf === \"symbol\") return symbolToString.call(val).replace(SYMBOL_REGEXP, \"Symbol($1)\");\n    const tag = toString.call(val).slice(8, -1);\n    if (tag === \"Date\") return isNaN(val.getTime()) ? \"\" + val : val.toISOString(val);\n    if (tag === \"Error\" || val instanceof Error) return \"[\" + errorToString.call(val) + \"]\";\n    if (tag === \"RegExp\") return regExpToString.call(val);\n    return null;\n}\nfunction printValue(value, quoteStrings) {\n    let result = printSimpleValue(value, quoteStrings);\n    if (result !== null) return result;\n    return JSON.stringify(value, function(key, value) {\n        let result = printSimpleValue(this[key], quoteStrings);\n        if (result !== null) return result;\n        return value;\n    }, 2);\n}\nfunction toArray(value) {\n    return value == null ? [] : [].concat(value);\n}\nlet _Symbol$toStringTag, _Symbol$hasInstance, _Symbol$toStringTag2;\nlet strReg = /\\$\\{\\s*(\\w+)\\s*\\}/g;\n_Symbol$toStringTag = Symbol.toStringTag;\nclass ValidationErrorNoStack {\n    constructor(errorOrErrors, value, field, type){\n        this.name = void 0;\n        this.message = void 0;\n        this.value = void 0;\n        this.path = void 0;\n        this.type = void 0;\n        this.params = void 0;\n        this.errors = void 0;\n        this.inner = void 0;\n        this[_Symbol$toStringTag] = \"Error\";\n        this.name = \"ValidationError\";\n        this.value = value;\n        this.path = field;\n        this.type = type;\n        this.errors = [];\n        this.inner = [];\n        toArray(errorOrErrors).forEach((err)=>{\n            if (ValidationError.isError(err)) {\n                this.errors.push(...err.errors);\n                const innerErrors = err.inner.length ? err.inner : [\n                    err\n                ];\n                this.inner.push(...innerErrors);\n            } else {\n                this.errors.push(err);\n            }\n        });\n        this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0];\n    }\n}\n_Symbol$hasInstance = Symbol.hasInstance;\n_Symbol$toStringTag2 = Symbol.toStringTag;\nclass ValidationError extends Error {\n    static formatError(message, params) {\n        // Attempt to make the path more friendly for error message interpolation.\n        const path = params.label || params.path || \"this\";\n        // Store the original path under `originalPath` so it isn't lost to custom\n        // message functions; e.g., ones provided in `setLocale()` calls.\n        params = Object.assign({}, params, {\n            path,\n            originalPath: params.path\n        });\n        if (typeof message === \"string\") return message.replace(strReg, (_, key)=>printValue(params[key]));\n        if (typeof message === \"function\") return message(params);\n        return message;\n    }\n    static isError(err) {\n        return err && err.name === \"ValidationError\";\n    }\n    constructor(errorOrErrors, value, field, type, disableStack){\n        const errorNoStack = new ValidationErrorNoStack(errorOrErrors, value, field, type);\n        if (disableStack) {\n            return errorNoStack;\n        }\n        super();\n        this.value = void 0;\n        this.path = void 0;\n        this.type = void 0;\n        this.params = void 0;\n        this.errors = [];\n        this.inner = [];\n        this[_Symbol$toStringTag2] = \"Error\";\n        this.name = errorNoStack.name;\n        this.message = errorNoStack.message;\n        this.type = errorNoStack.type;\n        this.value = errorNoStack.value;\n        this.path = errorNoStack.path;\n        this.errors = errorNoStack.errors;\n        this.inner = errorNoStack.inner;\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, ValidationError);\n        }\n    }\n    static [_Symbol$hasInstance](inst) {\n        return ValidationErrorNoStack[Symbol.hasInstance](inst) || super[Symbol.hasInstance](inst);\n    }\n}\nlet mixed = {\n    default: \"${path} is invalid\",\n    required: \"${path} is a required field\",\n    defined: \"${path} must be defined\",\n    notNull: \"${path} cannot be null\",\n    oneOf: \"${path} must be one of the following values: ${values}\",\n    notOneOf: \"${path} must not be one of the following values: ${values}\",\n    notType: ({ path, type, value, originalValue })=>{\n        const castMsg = originalValue != null && originalValue !== value ? ` (cast from the value \\`${printValue(originalValue, true)}\\`).` : \".\";\n        return type !== \"mixed\" ? `${path} must be a \\`${type}\\` type, ` + `but the final value was: \\`${printValue(value, true)}\\`` + castMsg : `${path} must match the configured type. ` + `The validated value was: \\`${printValue(value, true)}\\`` + castMsg;\n    }\n};\nlet string = {\n    length: \"${path} must be exactly ${length} characters\",\n    min: \"${path} must be at least ${min} characters\",\n    max: \"${path} must be at most ${max} characters\",\n    matches: '${path} must match the following: \"${regex}\"',\n    email: \"${path} must be a valid email\",\n    url: \"${path} must be a valid URL\",\n    uuid: \"${path} must be a valid UUID\",\n    datetime: \"${path} must be a valid ISO date-time\",\n    datetime_precision: \"${path} must be a valid ISO date-time with a sub-second precision of exactly ${precision} digits\",\n    datetime_offset: '${path} must be a valid ISO date-time with UTC \"Z\" timezone',\n    trim: \"${path} must be a trimmed string\",\n    lowercase: \"${path} must be a lowercase string\",\n    uppercase: \"${path} must be a upper case string\"\n};\nlet number = {\n    min: \"${path} must be greater than or equal to ${min}\",\n    max: \"${path} must be less than or equal to ${max}\",\n    lessThan: \"${path} must be less than ${less}\",\n    moreThan: \"${path} must be greater than ${more}\",\n    positive: \"${path} must be a positive number\",\n    negative: \"${path} must be a negative number\",\n    integer: \"${path} must be an integer\"\n};\nlet date = {\n    min: \"${path} field must be later than ${min}\",\n    max: \"${path} field must be at earlier than ${max}\"\n};\nlet boolean = {\n    isValue: \"${path} field must be ${value}\"\n};\nlet object = {\n    noUnknown: \"${path} field has unspecified keys: ${unknown}\",\n    exact: \"${path} object contains unknown properties: ${properties}\"\n};\nlet array = {\n    min: \"${path} field must have at least ${min} items\",\n    max: \"${path} field must have less than or equal to ${max} items\",\n    length: \"${path} must have ${length} items\"\n};\nlet tuple = {\n    notType: (params)=>{\n        const { path, value, spec } = params;\n        const typeLen = spec.types.length;\n        if (Array.isArray(value)) {\n            if (value.length < typeLen) return `${path} tuple value has too few items, expected a length of ${typeLen} but got ${value.length} for value: \\`${printValue(value, true)}\\``;\n            if (value.length > typeLen) return `${path} tuple value has too many items, expected a length of ${typeLen} but got ${value.length} for value: \\`${printValue(value, true)}\\``;\n        }\n        return ValidationError.formatError(mixed.notType, params);\n    }\n};\nvar locale = Object.assign(Object.create(null), {\n    mixed,\n    string,\n    number,\n    date,\n    object,\n    array,\n    boolean,\n    tuple\n});\nconst isSchema = (obj)=>obj && obj.__isYupSchema__;\nclass Condition {\n    static fromOptions(refs, config) {\n        if (!config.then && !config.otherwise) throw new TypeError(\"either `then:` or `otherwise:` is required for `when()` conditions\");\n        let { is, then, otherwise } = config;\n        let check = typeof is === \"function\" ? is : (...values)=>values.every((value)=>value === is);\n        return new Condition(refs, (values, schema)=>{\n            var _branch;\n            let branch = check(...values) ? then : otherwise;\n            return (_branch = branch == null ? void 0 : branch(schema)) != null ? _branch : schema;\n        });\n    }\n    constructor(refs, builder){\n        this.fn = void 0;\n        this.refs = refs;\n        this.refs = refs;\n        this.fn = builder;\n    }\n    resolve(base, options) {\n        let values = this.refs.map((ref)=>// TODO: ? operator here?\n            ref.getValue(options == null ? void 0 : options.value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context));\n        let schema = this.fn(values, base, options);\n        if (schema === undefined || // @ts-ignore this can be base\n        schema === base) {\n            return base;\n        }\n        if (!isSchema(schema)) throw new TypeError(\"conditions must return a schema object\");\n        return schema.resolve(options);\n    }\n}\nconst prefixes = {\n    context: \"$\",\n    value: \".\"\n};\nfunction create$9(key, options) {\n    return new Reference(key, options);\n}\nclass Reference {\n    constructor(key, options = {}){\n        this.key = void 0;\n        this.isContext = void 0;\n        this.isValue = void 0;\n        this.isSibling = void 0;\n        this.path = void 0;\n        this.getter = void 0;\n        this.map = void 0;\n        if (typeof key !== \"string\") throw new TypeError(\"ref must be a string, got: \" + key);\n        this.key = key.trim();\n        if (key === \"\") throw new TypeError(\"ref must be a non-empty string\");\n        this.isContext = this.key[0] === prefixes.context;\n        this.isValue = this.key[0] === prefixes.value;\n        this.isSibling = !this.isContext && !this.isValue;\n        let prefix = this.isContext ? prefixes.context : this.isValue ? prefixes.value : \"\";\n        this.path = this.key.slice(prefix.length);\n        this.getter = this.path && (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.getter)(this.path, true);\n        this.map = options.map;\n    }\n    getValue(value, parent, context) {\n        let result = this.isContext ? context : this.isValue ? value : parent;\n        if (this.getter) result = this.getter(result || {});\n        if (this.map) result = this.map(result);\n        return result;\n    }\n    /**\r\n   *\r\n   * @param {*} value\r\n   * @param {Object} options\r\n   * @param {Object=} options.context\r\n   * @param {Object=} options.parent\r\n   */ cast(value, options) {\n        return this.getValue(value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context);\n    }\n    resolve() {\n        return this;\n    }\n    describe() {\n        return {\n            type: \"ref\",\n            key: this.key\n        };\n    }\n    toString() {\n        return `Ref(${this.key})`;\n    }\n    static isRef(value) {\n        return value && value.__isYupRef;\n    }\n}\n// @ts-ignore\nReference.prototype.__isYupRef = true;\nconst isAbsent = (value)=>value == null;\nfunction createValidation(config) {\n    function validate({ value, path = \"\", options, originalValue, schema }, panic, next) {\n        const { name, test, params, message, skipAbsent } = config;\n        let { parent, context, abortEarly = schema.spec.abortEarly, disableStackTrace = schema.spec.disableStackTrace } = options;\n        function resolve(item) {\n            return Reference.isRef(item) ? item.getValue(value, parent, context) : item;\n        }\n        function createError(overrides = {}) {\n            const nextParams = Object.assign({\n                value,\n                originalValue,\n                label: schema.spec.label,\n                path: overrides.path || path,\n                spec: schema.spec,\n                disableStackTrace: overrides.disableStackTrace || disableStackTrace\n            }, params, overrides.params);\n            for (const key of Object.keys(nextParams))nextParams[key] = resolve(nextParams[key]);\n            const error = new ValidationError(ValidationError.formatError(overrides.message || message, nextParams), value, nextParams.path, overrides.type || name, nextParams.disableStackTrace);\n            error.params = nextParams;\n            return error;\n        }\n        const invalid = abortEarly ? panic : next;\n        let ctx = {\n            path,\n            parent,\n            type: name,\n            from: options.from,\n            createError,\n            resolve,\n            options,\n            originalValue,\n            schema\n        };\n        const handleResult = (validOrError)=>{\n            if (ValidationError.isError(validOrError)) invalid(validOrError);\n            else if (!validOrError) invalid(createError());\n            else next(null);\n        };\n        const handleError = (err)=>{\n            if (ValidationError.isError(err)) invalid(err);\n            else panic(err);\n        };\n        const shouldSkip = skipAbsent && isAbsent(value);\n        if (shouldSkip) {\n            return handleResult(true);\n        }\n        let result;\n        try {\n            var _result;\n            result = test.call(ctx, value, ctx);\n            if (typeof ((_result = result) == null ? void 0 : _result.then) === \"function\") {\n                if (options.sync) {\n                    throw new Error(`Validation test of type: \"${ctx.type}\" returned a Promise during a synchronous validate. ` + `This test will finish after the validate call has returned`);\n                }\n                return Promise.resolve(result).then(handleResult, handleError);\n            }\n        } catch (err) {\n            handleError(err);\n            return;\n        }\n        handleResult(result);\n    }\n    validate.OPTIONS = config;\n    return validate;\n}\nfunction getIn(schema, path, value, context = value) {\n    let parent, lastPart, lastPartDebug;\n    // root path: ''\n    if (!path) return {\n        parent,\n        parentPath: path,\n        schema\n    };\n    (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.forEach)(path, (_part, isBracket, isArray)=>{\n        let part = isBracket ? _part.slice(1, _part.length - 1) : _part;\n        schema = schema.resolve({\n            context,\n            parent,\n            value\n        });\n        let isTuple = schema.type === \"tuple\";\n        let idx = isArray ? parseInt(part, 10) : 0;\n        if (schema.innerType || isTuple) {\n            if (isTuple && !isArray) throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part \"${lastPartDebug}\" must contain an index to the tuple element, e.g. \"${lastPartDebug}[0]\"`);\n            if (value && idx >= value.length) {\n                throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path}. ` + `because there is no value at that index. `);\n            }\n            parent = value;\n            value = value && value[idx];\n            schema = isTuple ? schema.spec.types[idx] : schema.innerType;\n        }\n        // sometimes the array index part of a path doesn't exist: \"nested.arr.child\"\n        // in these cases the current part is the next schema and should be processed\n        // in this iteration. For cases where the index signature is included this\n        // check will fail and we'll handle the `child` part on the next iteration like normal\n        if (!isArray) {\n            if (!schema.fields || !schema.fields[part]) throw new Error(`The schema does not contain the path: ${path}. ` + `(failed at: ${lastPartDebug} which is a type: \"${schema.type}\")`);\n            parent = value;\n            value = value && value[part];\n            schema = schema.fields[part];\n        }\n        lastPart = part;\n        lastPartDebug = isBracket ? \"[\" + _part + \"]\" : \".\" + _part;\n    });\n    return {\n        schema,\n        parent,\n        parentPath: lastPart\n    };\n}\nfunction reach(obj, path, value, context) {\n    return getIn(obj, path, value, context).schema;\n}\nclass ReferenceSet extends Set {\n    describe() {\n        const description = [];\n        for (const item of this.values()){\n            description.push(Reference.isRef(item) ? item.describe() : item);\n        }\n        return description;\n    }\n    resolveAll(resolve) {\n        let result = [];\n        for (const item of this.values()){\n            result.push(resolve(item));\n        }\n        return result;\n    }\n    clone() {\n        return new ReferenceSet(this.values());\n    }\n    merge(newItems, removeItems) {\n        const next = this.clone();\n        newItems.forEach((value)=>next.add(value));\n        removeItems.forEach((value)=>next.delete(value));\n        return next;\n    }\n}\n// tweaked from https://github.com/Kelin2025/nanoclone/blob/0abeb7635bda9b68ef2277093f76dbe3bf3948e1/src/index.js\nfunction clone(src, seen = new Map()) {\n    if (isSchema(src) || !src || typeof src !== \"object\") return src;\n    if (seen.has(src)) return seen.get(src);\n    let copy;\n    if (src instanceof Date) {\n        // Date\n        copy = new Date(src.getTime());\n        seen.set(src, copy);\n    } else if (src instanceof RegExp) {\n        // RegExp\n        copy = new RegExp(src);\n        seen.set(src, copy);\n    } else if (Array.isArray(src)) {\n        // Array\n        copy = new Array(src.length);\n        seen.set(src, copy);\n        for(let i = 0; i < src.length; i++)copy[i] = clone(src[i], seen);\n    } else if (src instanceof Map) {\n        // Map\n        copy = new Map();\n        seen.set(src, copy);\n        for (const [k, v] of src.entries())copy.set(k, clone(v, seen));\n    } else if (src instanceof Set) {\n        // Set\n        copy = new Set();\n        seen.set(src, copy);\n        for (const v of src)copy.add(clone(v, seen));\n    } else if (src instanceof Object) {\n        // Object\n        copy = {};\n        seen.set(src, copy);\n        for (const [k, v] of Object.entries(src))copy[k] = clone(v, seen);\n    } else {\n        throw Error(`Unable to clone ${src}`);\n    }\n    return copy;\n}\n// If `CustomSchemaMeta` isn't extended with any keys, we'll fall back to a\n// loose Record definition allowing free form usage.\nclass Schema {\n    constructor(options){\n        this.type = void 0;\n        this.deps = [];\n        this.tests = void 0;\n        this.transforms = void 0;\n        this.conditions = [];\n        this._mutate = void 0;\n        this.internalTests = {};\n        this._whitelist = new ReferenceSet();\n        this._blacklist = new ReferenceSet();\n        this.exclusiveTests = Object.create(null);\n        this._typeCheck = void 0;\n        this.spec = void 0;\n        this.tests = [];\n        this.transforms = [];\n        this.withMutation(()=>{\n            this.typeError(mixed.notType);\n        });\n        this.type = options.type;\n        this._typeCheck = options.check;\n        this.spec = Object.assign({\n            strip: false,\n            strict: false,\n            abortEarly: true,\n            recursive: true,\n            disableStackTrace: false,\n            nullable: false,\n            optional: true,\n            coerce: true\n        }, options == null ? void 0 : options.spec);\n        this.withMutation((s)=>{\n            s.nonNullable();\n        });\n    }\n    // TODO: remove\n    get _type() {\n        return this.type;\n    }\n    clone(spec) {\n        if (this._mutate) {\n            if (spec) Object.assign(this.spec, spec);\n            return this;\n        }\n        // if the nested value is a schema we can skip cloning, since\n        // they are already immutable\n        const next = Object.create(Object.getPrototypeOf(this));\n        // @ts-expect-error this is readonly\n        next.type = this.type;\n        next._typeCheck = this._typeCheck;\n        next._whitelist = this._whitelist.clone();\n        next._blacklist = this._blacklist.clone();\n        next.internalTests = Object.assign({}, this.internalTests);\n        next.exclusiveTests = Object.assign({}, this.exclusiveTests);\n        // @ts-expect-error this is readonly\n        next.deps = [\n            ...this.deps\n        ];\n        next.conditions = [\n            ...this.conditions\n        ];\n        next.tests = [\n            ...this.tests\n        ];\n        next.transforms = [\n            ...this.transforms\n        ];\n        next.spec = clone(Object.assign({}, this.spec, spec));\n        return next;\n    }\n    label(label) {\n        let next = this.clone();\n        next.spec.label = label;\n        return next;\n    }\n    meta(...args) {\n        if (args.length === 0) return this.spec.meta;\n        let next = this.clone();\n        next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);\n        return next;\n    }\n    withMutation(fn) {\n        let before = this._mutate;\n        this._mutate = true;\n        let result = fn(this);\n        this._mutate = before;\n        return result;\n    }\n    concat(schema) {\n        if (!schema || schema === this) return this;\n        if (schema.type !== this.type && this.type !== \"mixed\") throw new TypeError(`You cannot \\`concat()\\` schema's of different types: ${this.type} and ${schema.type}`);\n        let base = this;\n        let combined = schema.clone();\n        const mergedSpec = Object.assign({}, base.spec, combined.spec);\n        combined.spec = mergedSpec;\n        combined.internalTests = Object.assign({}, base.internalTests, combined.internalTests);\n        // manually merge the blacklist/whitelist (the other `schema` takes\n        // precedence in case of conflicts)\n        combined._whitelist = base._whitelist.merge(schema._whitelist, schema._blacklist);\n        combined._blacklist = base._blacklist.merge(schema._blacklist, schema._whitelist);\n        // start with the current tests\n        combined.tests = base.tests;\n        combined.exclusiveTests = base.exclusiveTests;\n        // manually add the new tests to ensure\n        // the deduping logic is consistent\n        combined.withMutation((next)=>{\n            schema.tests.forEach((fn)=>{\n                next.test(fn.OPTIONS);\n            });\n        });\n        combined.transforms = [\n            ...base.transforms,\n            ...combined.transforms\n        ];\n        return combined;\n    }\n    isType(v) {\n        if (v == null) {\n            if (this.spec.nullable && v === null) return true;\n            if (this.spec.optional && v === undefined) return true;\n            return false;\n        }\n        return this._typeCheck(v);\n    }\n    resolve(options) {\n        let schema = this;\n        if (schema.conditions.length) {\n            let conditions = schema.conditions;\n            schema = schema.clone();\n            schema.conditions = [];\n            schema = conditions.reduce((prevSchema, condition)=>condition.resolve(prevSchema, options), schema);\n            schema = schema.resolve(options);\n        }\n        return schema;\n    }\n    resolveOptions(options) {\n        var _options$strict, _options$abortEarly, _options$recursive, _options$disableStack;\n        return Object.assign({}, options, {\n            from: options.from || [],\n            strict: (_options$strict = options.strict) != null ? _options$strict : this.spec.strict,\n            abortEarly: (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly,\n            recursive: (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive,\n            disableStackTrace: (_options$disableStack = options.disableStackTrace) != null ? _options$disableStack : this.spec.disableStackTrace\n        });\n    }\n    /**\r\n   * Run the configured transform pipeline over an input value.\r\n   */ cast(value, options = {}) {\n        let resolvedSchema = this.resolve(Object.assign({\n            value\n        }, options));\n        let allowOptionality = options.assert === \"ignore-optionality\";\n        let result = resolvedSchema._cast(value, options);\n        if (options.assert !== false && !resolvedSchema.isType(result)) {\n            if (allowOptionality && isAbsent(result)) {\n                return result;\n            }\n            let formattedValue = printValue(value);\n            let formattedResult = printValue(result);\n            throw new TypeError(`The value of ${options.path || \"field\"} could not be cast to a value ` + `that satisfies the schema type: \"${resolvedSchema.type}\". \\n\\n` + `attempted value: ${formattedValue} \\n` + (formattedResult !== formattedValue ? `result of cast: ${formattedResult}` : \"\"));\n        }\n        return result;\n    }\n    _cast(rawValue, options) {\n        let value = rawValue === undefined ? rawValue : this.transforms.reduce((prevValue, fn)=>fn.call(this, prevValue, rawValue, this), rawValue);\n        if (value === undefined) {\n            value = this.getDefault(options);\n        }\n        return value;\n    }\n    _validate(_value, options = {}, panic, next) {\n        let { path, originalValue = _value, strict = this.spec.strict } = options;\n        let value = _value;\n        if (!strict) {\n            value = this._cast(value, Object.assign({\n                assert: false\n            }, options));\n        }\n        let initialTests = [];\n        for (let test of Object.values(this.internalTests)){\n            if (test) initialTests.push(test);\n        }\n        this.runTests({\n            path,\n            value,\n            originalValue,\n            options,\n            tests: initialTests\n        }, panic, (initialErrors)=>{\n            // even if we aren't ending early we can't proceed further if the types aren't correct\n            if (initialErrors.length) {\n                return next(initialErrors, value);\n            }\n            this.runTests({\n                path,\n                value,\n                originalValue,\n                options,\n                tests: this.tests\n            }, panic, next);\n        });\n    }\n    /**\r\n   * Executes a set of validations, either schema, produced Tests or a nested\r\n   * schema validate result.\r\n   */ runTests(runOptions, panic, next) {\n        let fired = false;\n        let { tests, value, originalValue, path, options } = runOptions;\n        let panicOnce = (arg)=>{\n            if (fired) return;\n            fired = true;\n            panic(arg, value);\n        };\n        let nextOnce = (arg)=>{\n            if (fired) return;\n            fired = true;\n            next(arg, value);\n        };\n        let count = tests.length;\n        let nestedErrors = [];\n        if (!count) return nextOnce([]);\n        let args = {\n            value,\n            originalValue,\n            path,\n            options,\n            schema: this\n        };\n        for(let i = 0; i < tests.length; i++){\n            const test = tests[i];\n            test(args, panicOnce, function finishTestRun(err) {\n                if (err) {\n                    Array.isArray(err) ? nestedErrors.push(...err) : nestedErrors.push(err);\n                }\n                if (--count <= 0) {\n                    nextOnce(nestedErrors);\n                }\n            });\n        }\n    }\n    asNestedTest({ key, index, parent, parentPath, originalParent, options }) {\n        const k = key != null ? key : index;\n        if (k == null) {\n            throw TypeError(\"Must include `key` or `index` for nested validations\");\n        }\n        const isIndex = typeof k === \"number\";\n        let value = parent[k];\n        const testOptions = Object.assign({}, options, {\n            // Nested validations fields are always strict:\n            //    1. parent isn't strict so the casting will also have cast inner values\n            //    2. parent is strict in which case the nested values weren't cast either\n            strict: true,\n            parent,\n            value,\n            originalValue: originalParent[k],\n            // FIXME: tests depend on `index` being passed around deeply,\n            //   we should not let the options.key/index bleed through\n            key: undefined,\n            // index: undefined,\n            [isIndex ? \"index\" : \"key\"]: k,\n            path: isIndex || k.includes(\".\") ? `${parentPath || \"\"}[${isIndex ? k : `\"${k}\"`}]` : (parentPath ? `${parentPath}.` : \"\") + key\n        });\n        return (_, panic, next)=>this.resolve(testOptions)._validate(value, testOptions, panic, next);\n    }\n    validate(value, options) {\n        var _options$disableStack2;\n        let schema = this.resolve(Object.assign({}, options, {\n            value\n        }));\n        let disableStackTrace = (_options$disableStack2 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack2 : schema.spec.disableStackTrace;\n        return new Promise((resolve, reject)=>schema._validate(value, options, (error, parsed)=>{\n                if (ValidationError.isError(error)) error.value = parsed;\n                reject(error);\n            }, (errors, validated)=>{\n                if (errors.length) reject(new ValidationError(errors, validated, undefined, undefined, disableStackTrace));\n                else resolve(validated);\n            }));\n    }\n    validateSync(value, options) {\n        var _options$disableStack3;\n        let schema = this.resolve(Object.assign({}, options, {\n            value\n        }));\n        let result;\n        let disableStackTrace = (_options$disableStack3 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack3 : schema.spec.disableStackTrace;\n        schema._validate(value, Object.assign({}, options, {\n            sync: true\n        }), (error, parsed)=>{\n            if (ValidationError.isError(error)) error.value = parsed;\n            throw error;\n        }, (errors, validated)=>{\n            if (errors.length) throw new ValidationError(errors, value, undefined, undefined, disableStackTrace);\n            result = validated;\n        });\n        return result;\n    }\n    isValid(value, options) {\n        return this.validate(value, options).then(()=>true, (err)=>{\n            if (ValidationError.isError(err)) return false;\n            throw err;\n        });\n    }\n    isValidSync(value, options) {\n        try {\n            this.validateSync(value, options);\n            return true;\n        } catch (err) {\n            if (ValidationError.isError(err)) return false;\n            throw err;\n        }\n    }\n    _getDefault(options) {\n        let defaultValue = this.spec.default;\n        if (defaultValue == null) {\n            return defaultValue;\n        }\n        return typeof defaultValue === \"function\" ? defaultValue.call(this, options) : clone(defaultValue);\n    }\n    getDefault(options) {\n        let schema = this.resolve(options || {});\n        return schema._getDefault(options);\n    }\n    default(def) {\n        if (arguments.length === 0) {\n            return this._getDefault();\n        }\n        let next = this.clone({\n            default: def\n        });\n        return next;\n    }\n    strict(isStrict = true) {\n        return this.clone({\n            strict: isStrict\n        });\n    }\n    nullability(nullable, message) {\n        const next = this.clone({\n            nullable\n        });\n        next.internalTests.nullable = createValidation({\n            message,\n            name: \"nullable\",\n            test (value) {\n                return value === null ? this.schema.spec.nullable : true;\n            }\n        });\n        return next;\n    }\n    optionality(optional, message) {\n        const next = this.clone({\n            optional\n        });\n        next.internalTests.optionality = createValidation({\n            message,\n            name: \"optionality\",\n            test (value) {\n                return value === undefined ? this.schema.spec.optional : true;\n            }\n        });\n        return next;\n    }\n    optional() {\n        return this.optionality(true);\n    }\n    defined(message = mixed.defined) {\n        return this.optionality(false, message);\n    }\n    nullable() {\n        return this.nullability(true);\n    }\n    nonNullable(message = mixed.notNull) {\n        return this.nullability(false, message);\n    }\n    required(message = mixed.required) {\n        return this.clone().withMutation((next)=>next.nonNullable(message).defined(message));\n    }\n    notRequired() {\n        return this.clone().withMutation((next)=>next.nullable().optional());\n    }\n    transform(fn) {\n        let next = this.clone();\n        next.transforms.push(fn);\n        return next;\n    }\n    /**\r\n   * Adds a test function to the schema's queue of tests.\r\n   * tests can be exclusive or non-exclusive.\r\n   *\r\n   * - exclusive tests, will replace any existing tests of the same name.\r\n   * - non-exclusive: can be stacked\r\n   *\r\n   * If a non-exclusive test is added to a schema with an exclusive test of the same name\r\n   * the exclusive test is removed and further tests of the same name will be stacked.\r\n   *\r\n   * If an exclusive test is added to a schema with non-exclusive tests of the same name\r\n   * the previous tests are removed and further tests of the same name will replace each other.\r\n   */ test(...args) {\n        let opts;\n        if (args.length === 1) {\n            if (typeof args[0] === \"function\") {\n                opts = {\n                    test: args[0]\n                };\n            } else {\n                opts = args[0];\n            }\n        } else if (args.length === 2) {\n            opts = {\n                name: args[0],\n                test: args[1]\n            };\n        } else {\n            opts = {\n                name: args[0],\n                message: args[1],\n                test: args[2]\n            };\n        }\n        if (opts.message === undefined) opts.message = mixed.default;\n        if (typeof opts.test !== \"function\") throw new TypeError(\"`test` is a required parameters\");\n        let next = this.clone();\n        let validate = createValidation(opts);\n        let isExclusive = opts.exclusive || opts.name && next.exclusiveTests[opts.name] === true;\n        if (opts.exclusive) {\n            if (!opts.name) throw new TypeError(\"Exclusive tests must provide a unique `name` identifying the test\");\n        }\n        if (opts.name) next.exclusiveTests[opts.name] = !!opts.exclusive;\n        next.tests = next.tests.filter((fn)=>{\n            if (fn.OPTIONS.name === opts.name) {\n                if (isExclusive) return false;\n                if (fn.OPTIONS.test === validate.OPTIONS.test) return false;\n            }\n            return true;\n        });\n        next.tests.push(validate);\n        return next;\n    }\n    when(keys, options) {\n        if (!Array.isArray(keys) && typeof keys !== \"string\") {\n            options = keys;\n            keys = \".\";\n        }\n        let next = this.clone();\n        let deps = toArray(keys).map((key)=>new Reference(key));\n        deps.forEach((dep)=>{\n            // @ts-ignore readonly array\n            if (dep.isSibling) next.deps.push(dep.key);\n        });\n        next.conditions.push(typeof options === \"function\" ? new Condition(deps, options) : Condition.fromOptions(deps, options));\n        return next;\n    }\n    typeError(message) {\n        let next = this.clone();\n        next.internalTests.typeError = createValidation({\n            message,\n            name: \"typeError\",\n            skipAbsent: true,\n            test (value) {\n                if (!this.schema._typeCheck(value)) return this.createError({\n                    params: {\n                        type: this.schema.type\n                    }\n                });\n                return true;\n            }\n        });\n        return next;\n    }\n    oneOf(enums, message = mixed.oneOf) {\n        let next = this.clone();\n        enums.forEach((val)=>{\n            next._whitelist.add(val);\n            next._blacklist.delete(val);\n        });\n        next.internalTests.whiteList = createValidation({\n            message,\n            name: \"oneOf\",\n            skipAbsent: true,\n            test (value) {\n                let valids = this.schema._whitelist;\n                let resolved = valids.resolveAll(this.resolve);\n                return resolved.includes(value) ? true : this.createError({\n                    params: {\n                        values: Array.from(valids).join(\", \"),\n                        resolved\n                    }\n                });\n            }\n        });\n        return next;\n    }\n    notOneOf(enums, message = mixed.notOneOf) {\n        let next = this.clone();\n        enums.forEach((val)=>{\n            next._blacklist.add(val);\n            next._whitelist.delete(val);\n        });\n        next.internalTests.blacklist = createValidation({\n            message,\n            name: \"notOneOf\",\n            test (value) {\n                let invalids = this.schema._blacklist;\n                let resolved = invalids.resolveAll(this.resolve);\n                if (resolved.includes(value)) return this.createError({\n                    params: {\n                        values: Array.from(invalids).join(\", \"),\n                        resolved\n                    }\n                });\n                return true;\n            }\n        });\n        return next;\n    }\n    strip(strip = true) {\n        let next = this.clone();\n        next.spec.strip = strip;\n        return next;\n    }\n    /**\r\n   * Return a serialized description of the schema including validations, flags, types etc.\r\n   *\r\n   * @param options Provide any needed context for resolving runtime schema alterations (lazy, when conditions, etc).\r\n   */ describe(options) {\n        const next = (options ? this.resolve(options) : this).clone();\n        const { label, meta, optional, nullable } = next.spec;\n        const description = {\n            meta,\n            label,\n            optional,\n            nullable,\n            default: next.getDefault(options),\n            type: next.type,\n            oneOf: next._whitelist.describe(),\n            notOneOf: next._blacklist.describe(),\n            tests: next.tests.map((fn)=>({\n                    name: fn.OPTIONS.name,\n                    params: fn.OPTIONS.params\n                })).filter((n, idx, list)=>list.findIndex((c)=>c.name === n.name) === idx)\n        };\n        return description;\n    }\n}\n// @ts-expect-error\nSchema.prototype.__isYupSchema__ = true;\nfor (const method of [\n    \"validate\",\n    \"validateSync\"\n])Schema.prototype[`${method}At`] = function(path, value, options = {}) {\n    const { parent, parentPath, schema } = getIn(this, path, value, options.context);\n    return schema[method](parent && parent[parentPath], Object.assign({}, options, {\n        parent,\n        path\n    }));\n};\nfor (const alias of [\n    \"equals\",\n    \"is\"\n])Schema.prototype[alias] = Schema.prototype.oneOf;\nfor (const alias of [\n    \"not\",\n    \"nope\"\n])Schema.prototype[alias] = Schema.prototype.notOneOf;\nconst returnsTrue = ()=>true;\nfunction create$8(spec) {\n    return new MixedSchema(spec);\n}\nclass MixedSchema extends Schema {\n    constructor(spec){\n        super(typeof spec === \"function\" ? {\n            type: \"mixed\",\n            check: spec\n        } : Object.assign({\n            type: \"mixed\",\n            check: returnsTrue\n        }, spec));\n    }\n}\ncreate$8.prototype = MixedSchema.prototype;\nfunction create$7() {\n    return new BooleanSchema();\n}\nclass BooleanSchema extends Schema {\n    constructor(){\n        super({\n            type: \"boolean\",\n            check (v) {\n                if (v instanceof Boolean) v = v.valueOf();\n                return typeof v === \"boolean\";\n            }\n        });\n        this.withMutation(()=>{\n            this.transform((value, _raw, ctx)=>{\n                if (ctx.spec.coerce && !ctx.isType(value)) {\n                    if (/^(true|1)$/i.test(String(value))) return true;\n                    if (/^(false|0)$/i.test(String(value))) return false;\n                }\n                return value;\n            });\n        });\n    }\n    isTrue(message = boolean.isValue) {\n        return this.test({\n            message,\n            name: \"is-value\",\n            exclusive: true,\n            params: {\n                value: \"true\"\n            },\n            test (value) {\n                return isAbsent(value) || value === true;\n            }\n        });\n    }\n    isFalse(message = boolean.isValue) {\n        return this.test({\n            message,\n            name: \"is-value\",\n            exclusive: true,\n            params: {\n                value: \"false\"\n            },\n            test (value) {\n                return isAbsent(value) || value === false;\n            }\n        });\n    }\n    default(def) {\n        return super.default(def);\n    }\n    defined(msg) {\n        return super.defined(msg);\n    }\n    optional() {\n        return super.optional();\n    }\n    required(msg) {\n        return super.required(msg);\n    }\n    notRequired() {\n        return super.notRequired();\n    }\n    nullable() {\n        return super.nullable();\n    }\n    nonNullable(msg) {\n        return super.nonNullable(msg);\n    }\n    strip(v) {\n        return super.strip(v);\n    }\n}\ncreate$7.prototype = BooleanSchema.prototype;\n/**\r\n * This file is a modified version of the file from the following repository:\r\n * Date.parse with progressive enhancement for ISO 8601 <https://github.com/csnover/js-iso8601>\r\n * NON-CONFORMANT EDITION.\r\n * © 2011 Colin Snover <http://zetafleet.com>\r\n * Released under MIT license.\r\n */ // prettier-ignore\n//                1 YYYY                2 MM        3 DD              4 HH     5 mm        6 ss           7 msec         8 Z 9 ±   10 tzHH    11 tzmm\nconst isoReg = /^(\\d{4}|[+-]\\d{6})(?:-?(\\d{2})(?:-?(\\d{2}))?)?(?:[ T]?(\\d{2}):?(\\d{2})(?::?(\\d{2})(?:[,.](\\d{1,}))?)?(?:(Z)|([+-])(\\d{2})(?::?(\\d{2}))?)?)?$/;\nfunction parseIsoDate(date) {\n    const struct = parseDateStruct(date);\n    if (!struct) return Date.parse ? Date.parse(date) : Number.NaN;\n    // timestamps without timezone identifiers should be considered local time\n    if (struct.z === undefined && struct.plusMinus === undefined) {\n        return new Date(struct.year, struct.month, struct.day, struct.hour, struct.minute, struct.second, struct.millisecond).valueOf();\n    }\n    let totalMinutesOffset = 0;\n    if (struct.z !== \"Z\" && struct.plusMinus !== undefined) {\n        totalMinutesOffset = struct.hourOffset * 60 + struct.minuteOffset;\n        if (struct.plusMinus === \"+\") totalMinutesOffset = 0 - totalMinutesOffset;\n    }\n    return Date.UTC(struct.year, struct.month, struct.day, struct.hour, struct.minute + totalMinutesOffset, struct.second, struct.millisecond);\n}\nfunction parseDateStruct(date) {\n    var _regexResult$7$length, _regexResult$;\n    const regexResult = isoReg.exec(date);\n    if (!regexResult) return null;\n    // use of toNumber() avoids NaN timestamps caused by “undefined”\n    // values being passed to Date constructor\n    return {\n        year: toNumber(regexResult[1]),\n        month: toNumber(regexResult[2], 1) - 1,\n        day: toNumber(regexResult[3], 1),\n        hour: toNumber(regexResult[4]),\n        minute: toNumber(regexResult[5]),\n        second: toNumber(regexResult[6]),\n        millisecond: regexResult[7] ? // allow arbitrary sub-second precision beyond milliseconds\n        toNumber(regexResult[7].substring(0, 3)) : 0,\n        precision: (_regexResult$7$length = (_regexResult$ = regexResult[7]) == null ? void 0 : _regexResult$.length) != null ? _regexResult$7$length : undefined,\n        z: regexResult[8] || undefined,\n        plusMinus: regexResult[9] || undefined,\n        hourOffset: toNumber(regexResult[10]),\n        minuteOffset: toNumber(regexResult[11])\n    };\n}\nfunction toNumber(str, defaultValue = 0) {\n    return Number(str) || defaultValue;\n}\n// Taken from HTML spec: https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address\nlet rEmail = // eslint-disable-next-line\n/^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\nlet rUrl = // eslint-disable-next-line\n/^((https?|ftp):)?\\/\\/(((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(\\#((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/i;\n// eslint-disable-next-line\nlet rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\nlet yearMonthDay = \"^\\\\d{4}-\\\\d{2}-\\\\d{2}\";\nlet hourMinuteSecond = \"\\\\d{2}:\\\\d{2}:\\\\d{2}\";\nlet zOrOffset = \"(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)\";\nlet rIsoDateTime = new RegExp(`${yearMonthDay}T${hourMinuteSecond}(\\\\.\\\\d+)?${zOrOffset}$`);\nlet isTrimmed = (value)=>isAbsent(value) || value === value.trim();\nlet objStringTag = ({}).toString();\nfunction create$6() {\n    return new StringSchema();\n}\nclass StringSchema extends Schema {\n    constructor(){\n        super({\n            type: \"string\",\n            check (value) {\n                if (value instanceof String) value = value.valueOf();\n                return typeof value === \"string\";\n            }\n        });\n        this.withMutation(()=>{\n            this.transform((value, _raw, ctx)=>{\n                if (!ctx.spec.coerce || ctx.isType(value)) return value;\n                // don't ever convert arrays\n                if (Array.isArray(value)) return value;\n                const strValue = value != null && value.toString ? value.toString() : value;\n                // no one wants plain objects converted to [Object object]\n                if (strValue === objStringTag) return value;\n                return strValue;\n            });\n        });\n    }\n    required(message) {\n        return super.required(message).withMutation((schema)=>schema.test({\n                message: message || mixed.required,\n                name: \"required\",\n                skipAbsent: true,\n                test: (value)=>!!value.length\n            }));\n    }\n    notRequired() {\n        return super.notRequired().withMutation((schema)=>{\n            schema.tests = schema.tests.filter((t)=>t.OPTIONS.name !== \"required\");\n            return schema;\n        });\n    }\n    length(length, message = string.length) {\n        return this.test({\n            message,\n            name: \"length\",\n            exclusive: true,\n            params: {\n                length\n            },\n            skipAbsent: true,\n            test (value) {\n                return value.length === this.resolve(length);\n            }\n        });\n    }\n    min(min, message = string.min) {\n        return this.test({\n            message,\n            name: \"min\",\n            exclusive: true,\n            params: {\n                min\n            },\n            skipAbsent: true,\n            test (value) {\n                return value.length >= this.resolve(min);\n            }\n        });\n    }\n    max(max, message = string.max) {\n        return this.test({\n            name: \"max\",\n            exclusive: true,\n            message,\n            params: {\n                max\n            },\n            skipAbsent: true,\n            test (value) {\n                return value.length <= this.resolve(max);\n            }\n        });\n    }\n    matches(regex, options) {\n        let excludeEmptyString = false;\n        let message;\n        let name;\n        if (options) {\n            if (typeof options === \"object\") {\n                ({ excludeEmptyString = false, message, name } = options);\n            } else {\n                message = options;\n            }\n        }\n        return this.test({\n            name: name || \"matches\",\n            message: message || string.matches,\n            params: {\n                regex\n            },\n            skipAbsent: true,\n            test: (value)=>value === \"\" && excludeEmptyString || value.search(regex) !== -1\n        });\n    }\n    email(message = string.email) {\n        return this.matches(rEmail, {\n            name: \"email\",\n            message,\n            excludeEmptyString: true\n        });\n    }\n    url(message = string.url) {\n        return this.matches(rUrl, {\n            name: \"url\",\n            message,\n            excludeEmptyString: true\n        });\n    }\n    uuid(message = string.uuid) {\n        return this.matches(rUUID, {\n            name: \"uuid\",\n            message,\n            excludeEmptyString: false\n        });\n    }\n    datetime(options) {\n        let message = \"\";\n        let allowOffset;\n        let precision;\n        if (options) {\n            if (typeof options === \"object\") {\n                ({ message = \"\", allowOffset = false, precision = undefined } = options);\n            } else {\n                message = options;\n            }\n        }\n        return this.matches(rIsoDateTime, {\n            name: \"datetime\",\n            message: message || string.datetime,\n            excludeEmptyString: true\n        }).test({\n            name: \"datetime_offset\",\n            message: message || string.datetime_offset,\n            params: {\n                allowOffset\n            },\n            skipAbsent: true,\n            test: (value)=>{\n                if (!value || allowOffset) return true;\n                const struct = parseDateStruct(value);\n                if (!struct) return false;\n                return !!struct.z;\n            }\n        }).test({\n            name: \"datetime_precision\",\n            message: message || string.datetime_precision,\n            params: {\n                precision\n            },\n            skipAbsent: true,\n            test: (value)=>{\n                if (!value || precision == undefined) return true;\n                const struct = parseDateStruct(value);\n                if (!struct) return false;\n                return struct.precision === precision;\n            }\n        });\n    }\n    //-- transforms --\n    ensure() {\n        return this.default(\"\").transform((val)=>val === null ? \"\" : val);\n    }\n    trim(message = string.trim) {\n        return this.transform((val)=>val != null ? val.trim() : val).test({\n            message,\n            name: \"trim\",\n            test: isTrimmed\n        });\n    }\n    lowercase(message = string.lowercase) {\n        return this.transform((value)=>!isAbsent(value) ? value.toLowerCase() : value).test({\n            message,\n            name: \"string_case\",\n            exclusive: true,\n            skipAbsent: true,\n            test: (value)=>isAbsent(value) || value === value.toLowerCase()\n        });\n    }\n    uppercase(message = string.uppercase) {\n        return this.transform((value)=>!isAbsent(value) ? value.toUpperCase() : value).test({\n            message,\n            name: \"string_case\",\n            exclusive: true,\n            skipAbsent: true,\n            test: (value)=>isAbsent(value) || value === value.toUpperCase()\n        });\n    }\n}\ncreate$6.prototype = StringSchema.prototype;\n//\n// String Interfaces\n//\nlet isNaN$1 = (value)=>value != +value;\nfunction create$5() {\n    return new NumberSchema();\n}\nclass NumberSchema extends Schema {\n    constructor(){\n        super({\n            type: \"number\",\n            check (value) {\n                if (value instanceof Number) value = value.valueOf();\n                return typeof value === \"number\" && !isNaN$1(value);\n            }\n        });\n        this.withMutation(()=>{\n            this.transform((value, _raw, ctx)=>{\n                if (!ctx.spec.coerce) return value;\n                let parsed = value;\n                if (typeof parsed === \"string\") {\n                    parsed = parsed.replace(/\\s/g, \"\");\n                    if (parsed === \"\") return NaN;\n                    // don't use parseFloat to avoid positives on alpha-numeric strings\n                    parsed = +parsed;\n                }\n                // null -> NaN isn't useful; treat all nulls as null and let it fail on\n                // nullability check vs TypeErrors\n                if (ctx.isType(parsed) || parsed === null) return parsed;\n                return parseFloat(parsed);\n            });\n        });\n    }\n    min(min, message = number.min) {\n        return this.test({\n            message,\n            name: \"min\",\n            exclusive: true,\n            params: {\n                min\n            },\n            skipAbsent: true,\n            test (value) {\n                return value >= this.resolve(min);\n            }\n        });\n    }\n    max(max, message = number.max) {\n        return this.test({\n            message,\n            name: \"max\",\n            exclusive: true,\n            params: {\n                max\n            },\n            skipAbsent: true,\n            test (value) {\n                return value <= this.resolve(max);\n            }\n        });\n    }\n    lessThan(less, message = number.lessThan) {\n        return this.test({\n            message,\n            name: \"max\",\n            exclusive: true,\n            params: {\n                less\n            },\n            skipAbsent: true,\n            test (value) {\n                return value < this.resolve(less);\n            }\n        });\n    }\n    moreThan(more, message = number.moreThan) {\n        return this.test({\n            message,\n            name: \"min\",\n            exclusive: true,\n            params: {\n                more\n            },\n            skipAbsent: true,\n            test (value) {\n                return value > this.resolve(more);\n            }\n        });\n    }\n    positive(msg = number.positive) {\n        return this.moreThan(0, msg);\n    }\n    negative(msg = number.negative) {\n        return this.lessThan(0, msg);\n    }\n    integer(message = number.integer) {\n        return this.test({\n            name: \"integer\",\n            message,\n            skipAbsent: true,\n            test: (val)=>Number.isInteger(val)\n        });\n    }\n    truncate() {\n        return this.transform((value)=>!isAbsent(value) ? value | 0 : value);\n    }\n    round(method) {\n        var _method;\n        let avail = [\n            \"ceil\",\n            \"floor\",\n            \"round\",\n            \"trunc\"\n        ];\n        method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || \"round\";\n        // this exists for symemtry with the new Math.trunc\n        if (method === \"trunc\") return this.truncate();\n        if (avail.indexOf(method.toLowerCase()) === -1) throw new TypeError(\"Only valid options for round() are: \" + avail.join(\", \"));\n        return this.transform((value)=>!isAbsent(value) ? Math[method](value) : value);\n    }\n}\ncreate$5.prototype = NumberSchema.prototype;\n//\n// Number Interfaces\n//\nlet invalidDate = new Date(\"\");\nlet isDate = (obj)=>Object.prototype.toString.call(obj) === \"[object Date]\";\nfunction create$4() {\n    return new DateSchema();\n}\nclass DateSchema extends Schema {\n    constructor(){\n        super({\n            type: \"date\",\n            check (v) {\n                return isDate(v) && !isNaN(v.getTime());\n            }\n        });\n        this.withMutation(()=>{\n            this.transform((value, _raw, ctx)=>{\n                // null -> InvalidDate isn't useful; treat all nulls as null and let it fail on\n                // nullability check vs TypeErrors\n                if (!ctx.spec.coerce || ctx.isType(value) || value === null) return value;\n                value = parseIsoDate(value);\n                // 0 is a valid timestamp equivalent to 1970-01-01T00:00:00Z(unix epoch) or before.\n                return !isNaN(value) ? new Date(value) : DateSchema.INVALID_DATE;\n            });\n        });\n    }\n    prepareParam(ref, name) {\n        let param;\n        if (!Reference.isRef(ref)) {\n            let cast = this.cast(ref);\n            if (!this._typeCheck(cast)) throw new TypeError(`\\`${name}\\` must be a Date or a value that can be \\`cast()\\` to a Date`);\n            param = cast;\n        } else {\n            param = ref;\n        }\n        return param;\n    }\n    min(min, message = date.min) {\n        let limit = this.prepareParam(min, \"min\");\n        return this.test({\n            message,\n            name: \"min\",\n            exclusive: true,\n            params: {\n                min\n            },\n            skipAbsent: true,\n            test (value) {\n                return value >= this.resolve(limit);\n            }\n        });\n    }\n    max(max, message = date.max) {\n        let limit = this.prepareParam(max, \"max\");\n        return this.test({\n            message,\n            name: \"max\",\n            exclusive: true,\n            params: {\n                max\n            },\n            skipAbsent: true,\n            test (value) {\n                return value <= this.resolve(limit);\n            }\n        });\n    }\n}\nDateSchema.INVALID_DATE = invalidDate;\ncreate$4.prototype = DateSchema.prototype;\ncreate$4.INVALID_DATE = invalidDate;\n// @ts-expect-error\nfunction sortFields(fields, excludedEdges = []) {\n    let edges = [];\n    let nodes = new Set();\n    let excludes = new Set(excludedEdges.map(([a, b])=>`${a}-${b}`));\n    function addNode(depPath, key) {\n        let node = (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.split)(depPath)[0];\n        nodes.add(node);\n        if (!excludes.has(`${key}-${node}`)) edges.push([\n            key,\n            node\n        ]);\n    }\n    for (const key of Object.keys(fields)){\n        let value = fields[key];\n        nodes.add(key);\n        if (Reference.isRef(value) && value.isSibling) addNode(value.path, key);\n        else if (isSchema(value) && \"deps\" in value) value.deps.forEach((path)=>addNode(path, key));\n    }\n    return toposort__WEBPACK_IMPORTED_MODULE_2___default().array(Array.from(nodes), edges).reverse();\n}\nfunction findIndex(arr, err) {\n    let idx = Infinity;\n    arr.some((key, ii)=>{\n        var _err$path;\n        if ((_err$path = err.path) != null && _err$path.includes(key)) {\n            idx = ii;\n            return true;\n        }\n    });\n    return idx;\n}\nfunction sortByKeyOrder(keys) {\n    return (a, b)=>{\n        return findIndex(keys, a) - findIndex(keys, b);\n    };\n}\nconst parseJson = (value, _, ctx)=>{\n    if (typeof value !== \"string\") {\n        return value;\n    }\n    let parsed = value;\n    try {\n        parsed = JSON.parse(value);\n    } catch (err) {\n    /* */ }\n    return ctx.isType(parsed) ? parsed : value;\n};\n// @ts-ignore\nfunction deepPartial(schema) {\n    if (\"fields\" in schema) {\n        const partial = {};\n        for (const [key, fieldSchema] of Object.entries(schema.fields)){\n            partial[key] = deepPartial(fieldSchema);\n        }\n        return schema.setFields(partial);\n    }\n    if (schema.type === \"array\") {\n        const nextArray = schema.optional();\n        if (nextArray.innerType) nextArray.innerType = deepPartial(nextArray.innerType);\n        return nextArray;\n    }\n    if (schema.type === \"tuple\") {\n        return schema.optional().clone({\n            types: schema.spec.types.map(deepPartial)\n        });\n    }\n    if (\"optional\" in schema) {\n        return schema.optional();\n    }\n    return schema;\n}\nconst deepHas = (obj, p)=>{\n    const path = [\n        ...(0,property_expr__WEBPACK_IMPORTED_MODULE_0__.normalizePath)(p)\n    ];\n    if (path.length === 1) return path[0] in obj;\n    let last = path.pop();\n    let parent = (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.getter)((0,property_expr__WEBPACK_IMPORTED_MODULE_0__.join)(path), true)(obj);\n    return !!(parent && last in parent);\n};\nlet isObject = (obj)=>Object.prototype.toString.call(obj) === \"[object Object]\";\nfunction unknown(ctx, value) {\n    let known = Object.keys(ctx.fields);\n    return Object.keys(value).filter((key)=>known.indexOf(key) === -1);\n}\nconst defaultSort = sortByKeyOrder([]);\nfunction create$3(spec) {\n    return new ObjectSchema(spec);\n}\nclass ObjectSchema extends Schema {\n    constructor(spec){\n        super({\n            type: \"object\",\n            check (value) {\n                return isObject(value) || typeof value === \"function\";\n            }\n        });\n        this.fields = Object.create(null);\n        this._sortErrors = defaultSort;\n        this._nodes = [];\n        this._excludedEdges = [];\n        this.withMutation(()=>{\n            if (spec) {\n                this.shape(spec);\n            }\n        });\n    }\n    _cast(_value, options = {}) {\n        var _options$stripUnknown;\n        let value = super._cast(_value, options);\n        //should ignore nulls here\n        if (value === undefined) return this.getDefault(options);\n        if (!this._typeCheck(value)) return value;\n        let fields = this.fields;\n        let strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;\n        let props = [].concat(this._nodes, Object.keys(value).filter((v)=>!this._nodes.includes(v)));\n        let intermediateValue = {}; // is filled during the transform below\n        let innerOptions = Object.assign({}, options, {\n            parent: intermediateValue,\n            __validating: options.__validating || false\n        });\n        let isChanged = false;\n        for (const prop of props){\n            let field = fields[prop];\n            let exists = prop in value;\n            if (field) {\n                let fieldValue;\n                let inputValue = value[prop];\n                // safe to mutate since this is fired in sequence\n                innerOptions.path = (options.path ? `${options.path}.` : \"\") + prop;\n                field = field.resolve({\n                    value: inputValue,\n                    context: options.context,\n                    parent: intermediateValue\n                });\n                let fieldSpec = field instanceof Schema ? field.spec : undefined;\n                let strict = fieldSpec == null ? void 0 : fieldSpec.strict;\n                if (fieldSpec != null && fieldSpec.strip) {\n                    isChanged = isChanged || prop in value;\n                    continue;\n                }\n                fieldValue = !options.__validating || !strict ? // TODO: use _cast, this is double resolving\n                field.cast(value[prop], innerOptions) : value[prop];\n                if (fieldValue !== undefined) {\n                    intermediateValue[prop] = fieldValue;\n                }\n            } else if (exists && !strip) {\n                intermediateValue[prop] = value[prop];\n            }\n            if (exists !== prop in intermediateValue || intermediateValue[prop] !== value[prop]) {\n                isChanged = true;\n            }\n        }\n        return isChanged ? intermediateValue : value;\n    }\n    _validate(_value, options = {}, panic, next) {\n        let { from = [], originalValue = _value, recursive = this.spec.recursive } = options;\n        options.from = [\n            {\n                schema: this,\n                value: originalValue\n            },\n            ...from\n        ];\n        // this flag is needed for handling `strict` correctly in the context of\n        // validation vs just casting. e.g strict() on a field is only used when validating\n        options.__validating = true;\n        options.originalValue = originalValue;\n        super._validate(_value, options, panic, (objectErrors, value)=>{\n            if (!recursive || !isObject(value)) {\n                next(objectErrors, value);\n                return;\n            }\n            originalValue = originalValue || value;\n            let tests = [];\n            for (let key of this._nodes){\n                let field = this.fields[key];\n                if (!field || Reference.isRef(field)) {\n                    continue;\n                }\n                tests.push(field.asNestedTest({\n                    options,\n                    key,\n                    parent: value,\n                    parentPath: options.path,\n                    originalParent: originalValue\n                }));\n            }\n            this.runTests({\n                tests,\n                value,\n                originalValue,\n                options\n            }, panic, (fieldErrors)=>{\n                next(fieldErrors.sort(this._sortErrors).concat(objectErrors), value);\n            });\n        });\n    }\n    clone(spec) {\n        const next = super.clone(spec);\n        next.fields = Object.assign({}, this.fields);\n        next._nodes = this._nodes;\n        next._excludedEdges = this._excludedEdges;\n        next._sortErrors = this._sortErrors;\n        return next;\n    }\n    concat(schema) {\n        let next = super.concat(schema);\n        let nextFields = next.fields;\n        for (let [field, schemaOrRef] of Object.entries(this.fields)){\n            const target = nextFields[field];\n            nextFields[field] = target === undefined ? schemaOrRef : target;\n        }\n        return next.withMutation((s)=>// XXX: excludes here is wrong\n            s.setFields(nextFields, [\n                ...this._excludedEdges,\n                ...schema._excludedEdges\n            ]));\n    }\n    _getDefault(options) {\n        if (\"default\" in this.spec) {\n            return super._getDefault(options);\n        }\n        // if there is no default set invent one\n        if (!this._nodes.length) {\n            return undefined;\n        }\n        let dft = {};\n        this._nodes.forEach((key)=>{\n            var _innerOptions;\n            const field = this.fields[key];\n            let innerOptions = options;\n            if ((_innerOptions = innerOptions) != null && _innerOptions.value) {\n                innerOptions = Object.assign({}, innerOptions, {\n                    parent: innerOptions.value,\n                    value: innerOptions.value[key]\n                });\n            }\n            dft[key] = field && \"getDefault\" in field ? field.getDefault(innerOptions) : undefined;\n        });\n        return dft;\n    }\n    setFields(shape, excludedEdges) {\n        let next = this.clone();\n        next.fields = shape;\n        next._nodes = sortFields(shape, excludedEdges);\n        next._sortErrors = sortByKeyOrder(Object.keys(shape));\n        // XXX: this carries over edges which may not be what you want\n        if (excludedEdges) next._excludedEdges = excludedEdges;\n        return next;\n    }\n    shape(additions, excludes = []) {\n        return this.clone().withMutation((next)=>{\n            let edges = next._excludedEdges;\n            if (excludes.length) {\n                if (!Array.isArray(excludes[0])) excludes = [\n                    excludes\n                ];\n                edges = [\n                    ...next._excludedEdges,\n                    ...excludes\n                ];\n            }\n            // XXX: excludes here is wrong\n            return next.setFields(Object.assign(next.fields, additions), edges);\n        });\n    }\n    partial() {\n        const partial = {};\n        for (const [key, schema] of Object.entries(this.fields)){\n            partial[key] = \"optional\" in schema && schema.optional instanceof Function ? schema.optional() : schema;\n        }\n        return this.setFields(partial);\n    }\n    deepPartial() {\n        const next = deepPartial(this);\n        return next;\n    }\n    pick(keys) {\n        const picked = {};\n        for (const key of keys){\n            if (this.fields[key]) picked[key] = this.fields[key];\n        }\n        return this.setFields(picked, this._excludedEdges.filter(([a, b])=>keys.includes(a) && keys.includes(b)));\n    }\n    omit(keys) {\n        const remaining = [];\n        for (const key of Object.keys(this.fields)){\n            if (keys.includes(key)) continue;\n            remaining.push(key);\n        }\n        return this.pick(remaining);\n    }\n    from(from, to, alias) {\n        let fromGetter = (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.getter)(from, true);\n        return this.transform((obj)=>{\n            if (!obj) return obj;\n            let newObj = obj;\n            if (deepHas(obj, from)) {\n                newObj = Object.assign({}, obj);\n                if (!alias) delete newObj[from];\n                newObj[to] = fromGetter(obj);\n            }\n            return newObj;\n        });\n    }\n    /** Parse an input JSON string to an object */ json() {\n        return this.transform(parseJson);\n    }\n    /**\r\n   * Similar to `noUnknown` but only validates that an object is the right shape without stripping the unknown keys\r\n   */ exact(message) {\n        return this.test({\n            name: \"exact\",\n            exclusive: true,\n            message: message || object.exact,\n            test (value) {\n                if (value == null) return true;\n                const unknownKeys = unknown(this.schema, value);\n                return unknownKeys.length === 0 || this.createError({\n                    params: {\n                        properties: unknownKeys.join(\", \")\n                    }\n                });\n            }\n        });\n    }\n    stripUnknown() {\n        return this.clone({\n            noUnknown: true\n        });\n    }\n    noUnknown(noAllow = true, message = object.noUnknown) {\n        if (typeof noAllow !== \"boolean\") {\n            message = noAllow;\n            noAllow = true;\n        }\n        let next = this.test({\n            name: \"noUnknown\",\n            exclusive: true,\n            message: message,\n            test (value) {\n                if (value == null) return true;\n                const unknownKeys = unknown(this.schema, value);\n                return !noAllow || unknownKeys.length === 0 || this.createError({\n                    params: {\n                        unknown: unknownKeys.join(\", \")\n                    }\n                });\n            }\n        });\n        next.spec.noUnknown = noAllow;\n        return next;\n    }\n    unknown(allow = true, message = object.noUnknown) {\n        return this.noUnknown(!allow, message);\n    }\n    transformKeys(fn) {\n        return this.transform((obj)=>{\n            if (!obj) return obj;\n            const result = {};\n            for (const key of Object.keys(obj))result[fn(key)] = obj[key];\n            return result;\n        });\n    }\n    camelCase() {\n        return this.transformKeys(tiny_case__WEBPACK_IMPORTED_MODULE_1__.camelCase);\n    }\n    snakeCase() {\n        return this.transformKeys(tiny_case__WEBPACK_IMPORTED_MODULE_1__.snakeCase);\n    }\n    constantCase() {\n        return this.transformKeys((key)=>(0,tiny_case__WEBPACK_IMPORTED_MODULE_1__.snakeCase)(key).toUpperCase());\n    }\n    describe(options) {\n        const next = (options ? this.resolve(options) : this).clone();\n        const base = super.describe(options);\n        base.fields = {};\n        for (const [key, value] of Object.entries(next.fields)){\n            var _innerOptions2;\n            let innerOptions = options;\n            if ((_innerOptions2 = innerOptions) != null && _innerOptions2.value) {\n                innerOptions = Object.assign({}, innerOptions, {\n                    parent: innerOptions.value,\n                    value: innerOptions.value[key]\n                });\n            }\n            base.fields[key] = value.describe(innerOptions);\n        }\n        return base;\n    }\n}\ncreate$3.prototype = ObjectSchema.prototype;\nfunction create$2(type) {\n    return new ArraySchema(type);\n}\nclass ArraySchema extends Schema {\n    constructor(type){\n        super({\n            type: \"array\",\n            spec: {\n                types: type\n            },\n            check (v) {\n                return Array.isArray(v);\n            }\n        });\n        // `undefined` specifically means uninitialized, as opposed to \"no subtype\"\n        this.innerType = void 0;\n        this.innerType = type;\n    }\n    _cast(_value, _opts) {\n        const value = super._cast(_value, _opts);\n        // should ignore nulls here\n        if (!this._typeCheck(value) || !this.innerType) {\n            return value;\n        }\n        let isChanged = false;\n        const castArray = value.map((v, idx)=>{\n            const castElement = this.innerType.cast(v, Object.assign({}, _opts, {\n                path: `${_opts.path || \"\"}[${idx}]`\n            }));\n            if (castElement !== v) {\n                isChanged = true;\n            }\n            return castElement;\n        });\n        return isChanged ? castArray : value;\n    }\n    _validate(_value, options = {}, panic, next) {\n        var _options$recursive;\n        // let sync = options.sync;\n        // let path = options.path;\n        let innerType = this.innerType;\n        // let endEarly = options.abortEarly ?? this.spec.abortEarly;\n        let recursive = (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive;\n        options.originalValue != null ? options.originalValue : _value;\n        super._validate(_value, options, panic, (arrayErrors, value)=>{\n            var _options$originalValu2;\n            if (!recursive || !innerType || !this._typeCheck(value)) {\n                next(arrayErrors, value);\n                return;\n            }\n            // #950 Ensure that sparse array empty slots are validated\n            let tests = new Array(value.length);\n            for(let index = 0; index < value.length; index++){\n                var _options$originalValu;\n                tests[index] = innerType.asNestedTest({\n                    options,\n                    index,\n                    parent: value,\n                    parentPath: options.path,\n                    originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value\n                });\n            }\n            this.runTests({\n                value,\n                tests,\n                originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,\n                options\n            }, panic, (innerTypeErrors)=>next(innerTypeErrors.concat(arrayErrors), value));\n        });\n    }\n    clone(spec) {\n        const next = super.clone(spec);\n        // @ts-expect-error readonly\n        next.innerType = this.innerType;\n        return next;\n    }\n    /** Parse an input JSON string to an object */ json() {\n        return this.transform(parseJson);\n    }\n    concat(schema) {\n        let next = super.concat(schema);\n        // @ts-expect-error readonly\n        next.innerType = this.innerType;\n        if (schema.innerType) // @ts-expect-error readonly\n        next.innerType = next.innerType ? // @ts-expect-error Lazy doesn't have concat and will break\n        next.innerType.concat(schema.innerType) : schema.innerType;\n        return next;\n    }\n    of(schema) {\n        // FIXME: this should return a new instance of array without the default to be\n        let next = this.clone();\n        if (!isSchema(schema)) throw new TypeError(\"`array.of()` sub-schema must be a valid yup schema not: \" + printValue(schema));\n        // @ts-expect-error readonly\n        next.innerType = schema;\n        next.spec = Object.assign({}, next.spec, {\n            types: schema\n        });\n        return next;\n    }\n    length(length, message = array.length) {\n        return this.test({\n            message,\n            name: \"length\",\n            exclusive: true,\n            params: {\n                length\n            },\n            skipAbsent: true,\n            test (value) {\n                return value.length === this.resolve(length);\n            }\n        });\n    }\n    min(min, message) {\n        message = message || array.min;\n        return this.test({\n            message,\n            name: \"min\",\n            exclusive: true,\n            params: {\n                min\n            },\n            skipAbsent: true,\n            // FIXME(ts): Array<typeof T>\n            test (value) {\n                return value.length >= this.resolve(min);\n            }\n        });\n    }\n    max(max, message) {\n        message = message || array.max;\n        return this.test({\n            message,\n            name: \"max\",\n            exclusive: true,\n            params: {\n                max\n            },\n            skipAbsent: true,\n            test (value) {\n                return value.length <= this.resolve(max);\n            }\n        });\n    }\n    ensure() {\n        return this.default(()=>[]).transform((val, original)=>{\n            // We don't want to return `null` for nullable schema\n            if (this._typeCheck(val)) return val;\n            return original == null ? [] : [].concat(original);\n        });\n    }\n    compact(rejector) {\n        let reject = !rejector ? (v)=>!!v : (v, i, a)=>!rejector(v, i, a);\n        return this.transform((values)=>values != null ? values.filter(reject) : values);\n    }\n    describe(options) {\n        const next = (options ? this.resolve(options) : this).clone();\n        const base = super.describe(options);\n        if (next.innerType) {\n            var _innerOptions;\n            let innerOptions = options;\n            if ((_innerOptions = innerOptions) != null && _innerOptions.value) {\n                innerOptions = Object.assign({}, innerOptions, {\n                    parent: innerOptions.value,\n                    value: innerOptions.value[0]\n                });\n            }\n            base.innerType = next.innerType.describe(innerOptions);\n        }\n        return base;\n    }\n}\ncreate$2.prototype = ArraySchema.prototype;\n// @ts-ignore\nfunction create$1(schemas) {\n    return new TupleSchema(schemas);\n}\nclass TupleSchema extends Schema {\n    constructor(schemas){\n        super({\n            type: \"tuple\",\n            spec: {\n                types: schemas\n            },\n            check (v) {\n                const types = this.spec.types;\n                return Array.isArray(v) && v.length === types.length;\n            }\n        });\n        this.withMutation(()=>{\n            this.typeError(tuple.notType);\n        });\n    }\n    _cast(inputValue, options) {\n        const { types } = this.spec;\n        const value = super._cast(inputValue, options);\n        if (!this._typeCheck(value)) {\n            return value;\n        }\n        let isChanged = false;\n        const castArray = types.map((type, idx)=>{\n            const castElement = type.cast(value[idx], Object.assign({}, options, {\n                path: `${options.path || \"\"}[${idx}]`\n            }));\n            if (castElement !== value[idx]) isChanged = true;\n            return castElement;\n        });\n        return isChanged ? castArray : value;\n    }\n    _validate(_value, options = {}, panic, next) {\n        let itemTypes = this.spec.types;\n        super._validate(_value, options, panic, (tupleErrors, value)=>{\n            var _options$originalValu2;\n            // intentionally not respecting recursive\n            if (!this._typeCheck(value)) {\n                next(tupleErrors, value);\n                return;\n            }\n            let tests = [];\n            for (let [index, itemSchema] of itemTypes.entries()){\n                var _options$originalValu;\n                tests[index] = itemSchema.asNestedTest({\n                    options,\n                    index,\n                    parent: value,\n                    parentPath: options.path,\n                    originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value\n                });\n            }\n            this.runTests({\n                value,\n                tests,\n                originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,\n                options\n            }, panic, (innerTypeErrors)=>next(innerTypeErrors.concat(tupleErrors), value));\n        });\n    }\n    describe(options) {\n        const next = (options ? this.resolve(options) : this).clone();\n        const base = super.describe(options);\n        base.innerType = next.spec.types.map((schema, index)=>{\n            var _innerOptions;\n            let innerOptions = options;\n            if ((_innerOptions = innerOptions) != null && _innerOptions.value) {\n                innerOptions = Object.assign({}, innerOptions, {\n                    parent: innerOptions.value,\n                    value: innerOptions.value[index]\n                });\n            }\n            return schema.describe(innerOptions);\n        });\n        return base;\n    }\n}\ncreate$1.prototype = TupleSchema.prototype;\nfunction create(builder) {\n    return new Lazy(builder);\n}\nfunction catchValidationError(fn) {\n    try {\n        return fn();\n    } catch (err) {\n        if (ValidationError.isError(err)) return Promise.reject(err);\n        throw err;\n    }\n}\nclass Lazy {\n    constructor(builder){\n        this.type = \"lazy\";\n        this.__isYupSchema__ = true;\n        this.spec = void 0;\n        this._resolve = (value, options = {})=>{\n            let schema = this.builder(value, options);\n            if (!isSchema(schema)) throw new TypeError(\"lazy() functions must return a valid schema\");\n            if (this.spec.optional) schema = schema.optional();\n            return schema.resolve(options);\n        };\n        this.builder = builder;\n        this.spec = {\n            meta: undefined,\n            optional: false\n        };\n    }\n    clone(spec) {\n        const next = new Lazy(this.builder);\n        next.spec = Object.assign({}, this.spec, spec);\n        return next;\n    }\n    optionality(optional) {\n        const next = this.clone({\n            optional\n        });\n        return next;\n    }\n    optional() {\n        return this.optionality(true);\n    }\n    resolve(options) {\n        return this._resolve(options.value, options);\n    }\n    cast(value, options) {\n        return this._resolve(value, options).cast(value, options);\n    }\n    asNestedTest(config) {\n        let { key, index, parent, options } = config;\n        let value = parent[index != null ? index : key];\n        return this._resolve(value, Object.assign({}, options, {\n            value,\n            parent\n        })).asNestedTest(config);\n    }\n    validate(value, options) {\n        return catchValidationError(()=>this._resolve(value, options).validate(value, options));\n    }\n    validateSync(value, options) {\n        return this._resolve(value, options).validateSync(value, options);\n    }\n    validateAt(path, value, options) {\n        return catchValidationError(()=>this._resolve(value, options).validateAt(path, value, options));\n    }\n    validateSyncAt(path, value, options) {\n        return this._resolve(value, options).validateSyncAt(path, value, options);\n    }\n    isValid(value, options) {\n        try {\n            return this._resolve(value, options).isValid(value, options);\n        } catch (err) {\n            if (ValidationError.isError(err)) {\n                return Promise.resolve(false);\n            }\n            throw err;\n        }\n    }\n    isValidSync(value, options) {\n        return this._resolve(value, options).isValidSync(value, options);\n    }\n    describe(options) {\n        return options ? this.resolve(options).describe(options) : {\n            type: \"lazy\",\n            meta: this.spec.meta,\n            label: undefined\n        };\n    }\n    meta(...args) {\n        if (args.length === 0) return this.spec.meta;\n        let next = this.clone();\n        next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);\n        return next;\n    }\n}\nfunction setLocale(custom) {\n    Object.keys(custom).forEach((type)=>{\n        // @ts-ignore\n        Object.keys(custom[type]).forEach((method)=>{\n            // @ts-ignore\n            locale[type][method] = custom[type][method];\n        });\n    });\n}\nfunction addMethod(schemaType, name, fn) {\n    if (!schemaType || !isSchema(schemaType.prototype)) throw new TypeError(\"You must provide a yup schema constructor function\");\n    if (typeof name !== \"string\") throw new TypeError(\"A Method name must be provided\");\n    if (typeof fn !== \"function\") throw new TypeError(\"Method function must be provided\");\n    schemaType.prototype[name] = fn;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Z0QsSUFBSSxDQUFDaUksSUFBSTtRQUM1QyxJQUFJaEYsT0FBTyxJQUFJLENBQUN1QyxLQUFLO1FBQ3JCdkMsS0FBS2pELElBQUksQ0FBQ2lJLElBQUksR0FBR3BPLE9BQU91RCxNQUFNLENBQUM2RixLQUFLakQsSUFBSSxDQUFDaUksSUFBSSxJQUFJLENBQUMsR0FBR0MsSUFBSSxDQUFDLEVBQUU7UUFDNUQsT0FBT2pGO0lBQ1Q7QUFDRjtBQUVBLFNBQVNnVixVQUFVQyxNQUFNO0lBQ3ZCcmUsT0FBTzZKLElBQUksQ0FBQ3dVLFFBQVE3ZSxPQUFPLENBQUNnRCxDQUFBQTtRQUMxQixhQUFhO1FBQ2J4QyxPQUFPNkosSUFBSSxDQUFDd1UsTUFBTSxDQUFDN2IsS0FBSyxFQUFFaEQsT0FBTyxDQUFDdVQsQ0FBQUE7WUFDaEMsYUFBYTtZQUNidk0sTUFBTSxDQUFDaEUsS0FBSyxDQUFDdVEsT0FBTyxHQUFHc0wsTUFBTSxDQUFDN2IsS0FBSyxDQUFDdVEsT0FBTztRQUM3QztJQUNGO0FBQ0Y7QUFFQSxTQUFTdUwsVUFBVUMsVUFBVSxFQUFFeGQsSUFBSSxFQUFFNkcsRUFBRTtJQUNyQyxJQUFJLENBQUMyVyxjQUFjLENBQUM3WCxTQUFTNlgsV0FBV3RlLFNBQVMsR0FBRyxNQUFNLElBQUlrSCxVQUFVO0lBQ3hFLElBQUksT0FBT3BHLFNBQVMsVUFBVSxNQUFNLElBQUlvRyxVQUFVO0lBQ2xELElBQUksT0FBT1MsT0FBTyxZQUFZLE1BQU0sSUFBSVQsVUFBVTtJQUNsRG9YLFdBQVd0ZSxTQUFTLENBQUNjLEtBQUssR0FBRzZHO0FBQy9CO0FBRXFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnVzaW9uLWNsdWItd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy95dXAvaW5kZXguZXNtLmpzPzJlZmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0dGVyLCBmb3JFYWNoLCBzcGxpdCwgbm9ybWFsaXplUGF0aCwgam9pbiB9IGZyb20gJ3Byb3BlcnR5LWV4cHInO1xyXG5pbXBvcnQgeyBjYW1lbENhc2UsIHNuYWtlQ2FzZSB9IGZyb20gJ3RpbnktY2FzZSc7XHJcbmltcG9ydCB0b3Bvc29ydCBmcm9tICd0b3Bvc29ydCc7XHJcblxyXG5jb25zdCB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XHJcbmNvbnN0IGVycm9yVG9TdHJpbmcgPSBFcnJvci5wcm90b3R5cGUudG9TdHJpbmc7XHJcbmNvbnN0IHJlZ0V4cFRvU3RyaW5nID0gUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZztcclxuY29uc3Qgc3ltYm9sVG9TdHJpbmcgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcgOiAoKSA9PiAnJztcclxuY29uc3QgU1lNQk9MX1JFR0VYUCA9IC9eU3ltYm9sXFwoKC4qKVxcKSguKikkLztcclxuZnVuY3Rpb24gcHJpbnROdW1iZXIodmFsKSB7XHJcbiAgaWYgKHZhbCAhPSArdmFsKSByZXR1cm4gJ05hTic7XHJcbiAgY29uc3QgaXNOZWdhdGl2ZVplcm8gPSB2YWwgPT09IDAgJiYgMSAvIHZhbCA8IDA7XHJcbiAgcmV0dXJuIGlzTmVnYXRpdmVaZXJvID8gJy0wJyA6ICcnICsgdmFsO1xyXG59XHJcbmZ1bmN0aW9uIHByaW50U2ltcGxlVmFsdWUodmFsLCBxdW90ZVN0cmluZ3MgPSBmYWxzZSkge1xyXG4gIGlmICh2YWwgPT0gbnVsbCB8fCB2YWwgPT09IHRydWUgfHwgdmFsID09PSBmYWxzZSkgcmV0dXJuICcnICsgdmFsO1xyXG4gIGNvbnN0IHR5cGVPZiA9IHR5cGVvZiB2YWw7XHJcbiAgaWYgKHR5cGVPZiA9PT0gJ251bWJlcicpIHJldHVybiBwcmludE51bWJlcih2YWwpO1xyXG4gIGlmICh0eXBlT2YgPT09ICdzdHJpbmcnKSByZXR1cm4gcXVvdGVTdHJpbmdzID8gYFwiJHt2YWx9XCJgIDogdmFsO1xyXG4gIGlmICh0eXBlT2YgPT09ICdmdW5jdGlvbicpIHJldHVybiAnW0Z1bmN0aW9uICcgKyAodmFsLm5hbWUgfHwgJ2Fub255bW91cycpICsgJ10nO1xyXG4gIGlmICh0eXBlT2YgPT09ICdzeW1ib2wnKSByZXR1cm4gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWwpLnJlcGxhY2UoU1lNQk9MX1JFR0VYUCwgJ1N5bWJvbCgkMSknKTtcclxuICBjb25zdCB0YWcgPSB0b1N0cmluZy5jYWxsKHZhbCkuc2xpY2UoOCwgLTEpO1xyXG4gIGlmICh0YWcgPT09ICdEYXRlJykgcmV0dXJuIGlzTmFOKHZhbC5nZXRUaW1lKCkpID8gJycgKyB2YWwgOiB2YWwudG9JU09TdHJpbmcodmFsKTtcclxuICBpZiAodGFnID09PSAnRXJyb3InIHx8IHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gJ1snICsgZXJyb3JUb1N0cmluZy5jYWxsKHZhbCkgKyAnXSc7XHJcbiAgaWYgKHRhZyA9PT0gJ1JlZ0V4cCcpIHJldHVybiByZWdFeHBUb1N0cmluZy5jYWxsKHZhbCk7XHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxuZnVuY3Rpb24gcHJpbnRWYWx1ZSh2YWx1ZSwgcXVvdGVTdHJpbmdzKSB7XHJcbiAgbGV0IHJlc3VsdCA9IHByaW50U2ltcGxlVmFsdWUodmFsdWUsIHF1b3RlU3RyaW5ncyk7XHJcbiAgaWYgKHJlc3VsdCAhPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcclxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICBsZXQgcmVzdWx0ID0gcHJpbnRTaW1wbGVWYWx1ZSh0aGlzW2tleV0sIHF1b3RlU3RyaW5ncyk7XHJcbiAgICBpZiAocmVzdWx0ICE9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH0sIDIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0b0FycmF5KHZhbHVlKSB7XHJcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBbXSA6IFtdLmNvbmNhdCh2YWx1ZSk7XHJcbn1cclxuXHJcbmxldCBfU3ltYm9sJHRvU3RyaW5nVGFnLCBfU3ltYm9sJGhhc0luc3RhbmNlLCBfU3ltYm9sJHRvU3RyaW5nVGFnMjtcclxubGV0IHN0clJlZyA9IC9cXCRcXHtcXHMqKFxcdyspXFxzKlxcfS9nO1xyXG5fU3ltYm9sJHRvU3RyaW5nVGFnID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xyXG5jbGFzcyBWYWxpZGF0aW9uRXJyb3JOb1N0YWNrIHtcclxuICBjb25zdHJ1Y3RvcihlcnJvck9yRXJyb3JzLCB2YWx1ZSwgZmllbGQsIHR5cGUpIHtcclxuICAgIHRoaXMubmFtZSA9IHZvaWQgMDtcclxuICAgIHRoaXMubWVzc2FnZSA9IHZvaWQgMDtcclxuICAgIHRoaXMudmFsdWUgPSB2b2lkIDA7XHJcbiAgICB0aGlzLnBhdGggPSB2b2lkIDA7XHJcbiAgICB0aGlzLnR5cGUgPSB2b2lkIDA7XHJcbiAgICB0aGlzLnBhcmFtcyA9IHZvaWQgMDtcclxuICAgIHRoaXMuZXJyb3JzID0gdm9pZCAwO1xyXG4gICAgdGhpcy5pbm5lciA9IHZvaWQgMDtcclxuICAgIHRoaXNbX1N5bWJvbCR0b1N0cmluZ1RhZ10gPSAnRXJyb3InO1xyXG4gICAgdGhpcy5uYW1lID0gJ1ZhbGlkYXRpb25FcnJvcic7XHJcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICB0aGlzLnBhdGggPSBmaWVsZDtcclxuICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICB0aGlzLmVycm9ycyA9IFtdO1xyXG4gICAgdGhpcy5pbm5lciA9IFtdO1xyXG4gICAgdG9BcnJheShlcnJvck9yRXJyb3JzKS5mb3JFYWNoKGVyciA9PiB7XHJcbiAgICAgIGlmIChWYWxpZGF0aW9uRXJyb3IuaXNFcnJvcihlcnIpKSB7XHJcbiAgICAgICAgdGhpcy5lcnJvcnMucHVzaCguLi5lcnIuZXJyb3JzKTtcclxuICAgICAgICBjb25zdCBpbm5lckVycm9ycyA9IGVyci5pbm5lci5sZW5ndGggPyBlcnIuaW5uZXIgOiBbZXJyXTtcclxuICAgICAgICB0aGlzLmlubmVyLnB1c2goLi4uaW5uZXJFcnJvcnMpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuZXJyb3JzLnB1c2goZXJyKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLmVycm9ycy5sZW5ndGggPiAxID8gYCR7dGhpcy5lcnJvcnMubGVuZ3RofSBlcnJvcnMgb2NjdXJyZWRgIDogdGhpcy5lcnJvcnNbMF07XHJcbiAgfVxyXG59XHJcbl9TeW1ib2wkaGFzSW5zdGFuY2UgPSBTeW1ib2wuaGFzSW5zdGFuY2U7XHJcbl9TeW1ib2wkdG9TdHJpbmdUYWcyID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xyXG5jbGFzcyBWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgc3RhdGljIGZvcm1hdEVycm9yKG1lc3NhZ2UsIHBhcmFtcykge1xyXG4gICAgLy8gQXR0ZW1wdCB0byBtYWtlIHRoZSBwYXRoIG1vcmUgZnJpZW5kbHkgZm9yIGVycm9yIG1lc3NhZ2UgaW50ZXJwb2xhdGlvbi5cclxuICAgIGNvbnN0IHBhdGggPSBwYXJhbXMubGFiZWwgfHwgcGFyYW1zLnBhdGggfHwgJ3RoaXMnO1xyXG4gICAgLy8gU3RvcmUgdGhlIG9yaWdpbmFsIHBhdGggdW5kZXIgYG9yaWdpbmFsUGF0aGAgc28gaXQgaXNuJ3QgbG9zdCB0byBjdXN0b21cclxuICAgIC8vIG1lc3NhZ2UgZnVuY3Rpb25zOyBlLmcuLCBvbmVzIHByb3ZpZGVkIGluIGBzZXRMb2NhbGUoKWAgY2FsbHMuXHJcbiAgICBwYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMsIHtcclxuICAgICAgcGF0aCxcclxuICAgICAgb3JpZ2luYWxQYXRoOiBwYXJhbXMucGF0aFxyXG4gICAgfSk7XHJcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSByZXR1cm4gbWVzc2FnZS5yZXBsYWNlKHN0clJlZywgKF8sIGtleSkgPT4gcHJpbnRWYWx1ZShwYXJhbXNba2V5XSkpO1xyXG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnZnVuY3Rpb24nKSByZXR1cm4gbWVzc2FnZShwYXJhbXMpO1xyXG4gICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgfVxyXG4gIHN0YXRpYyBpc0Vycm9yKGVycikge1xyXG4gICAgcmV0dXJuIGVyciAmJiBlcnIubmFtZSA9PT0gJ1ZhbGlkYXRpb25FcnJvcic7XHJcbiAgfVxyXG4gIGNvbnN0cnVjdG9yKGVycm9yT3JFcnJvcnMsIHZhbHVlLCBmaWVsZCwgdHlwZSwgZGlzYWJsZVN0YWNrKSB7XHJcbiAgICBjb25zdCBlcnJvck5vU3RhY2sgPSBuZXcgVmFsaWRhdGlvbkVycm9yTm9TdGFjayhlcnJvck9yRXJyb3JzLCB2YWx1ZSwgZmllbGQsIHR5cGUpO1xyXG4gICAgaWYgKGRpc2FibGVTdGFjaykge1xyXG4gICAgICByZXR1cm4gZXJyb3JOb1N0YWNrO1xyXG4gICAgfVxyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMudmFsdWUgPSB2b2lkIDA7XHJcbiAgICB0aGlzLnBhdGggPSB2b2lkIDA7XHJcbiAgICB0aGlzLnR5cGUgPSB2b2lkIDA7XHJcbiAgICB0aGlzLnBhcmFtcyA9IHZvaWQgMDtcclxuICAgIHRoaXMuZXJyb3JzID0gW107XHJcbiAgICB0aGlzLmlubmVyID0gW107XHJcbiAgICB0aGlzW19TeW1ib2wkdG9TdHJpbmdUYWcyXSA9ICdFcnJvcic7XHJcbiAgICB0aGlzLm5hbWUgPSBlcnJvck5vU3RhY2submFtZTtcclxuICAgIHRoaXMubWVzc2FnZSA9IGVycm9yTm9TdGFjay5tZXNzYWdlO1xyXG4gICAgdGhpcy50eXBlID0gZXJyb3JOb1N0YWNrLnR5cGU7XHJcbiAgICB0aGlzLnZhbHVlID0gZXJyb3JOb1N0YWNrLnZhbHVlO1xyXG4gICAgdGhpcy5wYXRoID0gZXJyb3JOb1N0YWNrLnBhdGg7XHJcbiAgICB0aGlzLmVycm9ycyA9IGVycm9yTm9TdGFjay5lcnJvcnM7XHJcbiAgICB0aGlzLmlubmVyID0gZXJyb3JOb1N0YWNrLmlubmVyO1xyXG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XHJcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFZhbGlkYXRpb25FcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHN0YXRpYyBbX1N5bWJvbCRoYXNJbnN0YW5jZV0oaW5zdCkge1xyXG4gICAgcmV0dXJuIFZhbGlkYXRpb25FcnJvck5vU3RhY2tbU3ltYm9sLmhhc0luc3RhbmNlXShpbnN0KSB8fCBzdXBlcltTeW1ib2wuaGFzSW5zdGFuY2VdKGluc3QpO1xyXG4gIH1cclxufVxyXG5cclxubGV0IG1peGVkID0ge1xyXG4gIGRlZmF1bHQ6ICcke3BhdGh9IGlzIGludmFsaWQnLFxyXG4gIHJlcXVpcmVkOiAnJHtwYXRofSBpcyBhIHJlcXVpcmVkIGZpZWxkJyxcclxuICBkZWZpbmVkOiAnJHtwYXRofSBtdXN0IGJlIGRlZmluZWQnLFxyXG4gIG5vdE51bGw6ICcke3BhdGh9IGNhbm5vdCBiZSBudWxsJyxcclxuICBvbmVPZjogJyR7cGF0aH0gbXVzdCBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZXM6ICR7dmFsdWVzfScsXHJcbiAgbm90T25lT2Y6ICcke3BhdGh9IG11c3Qgbm90IGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlczogJHt2YWx1ZXN9JyxcclxuICBub3RUeXBlOiAoe1xyXG4gICAgcGF0aCxcclxuICAgIHR5cGUsXHJcbiAgICB2YWx1ZSxcclxuICAgIG9yaWdpbmFsVmFsdWVcclxuICB9KSA9PiB7XHJcbiAgICBjb25zdCBjYXN0TXNnID0gb3JpZ2luYWxWYWx1ZSAhPSBudWxsICYmIG9yaWdpbmFsVmFsdWUgIT09IHZhbHVlID8gYCAoY2FzdCBmcm9tIHRoZSB2YWx1ZSBcXGAke3ByaW50VmFsdWUob3JpZ2luYWxWYWx1ZSwgdHJ1ZSl9XFxgKS5gIDogJy4nO1xyXG4gICAgcmV0dXJuIHR5cGUgIT09ICdtaXhlZCcgPyBgJHtwYXRofSBtdXN0IGJlIGEgXFxgJHt0eXBlfVxcYCB0eXBlLCBgICsgYGJ1dCB0aGUgZmluYWwgdmFsdWUgd2FzOiBcXGAke3ByaW50VmFsdWUodmFsdWUsIHRydWUpfVxcYGAgKyBjYXN0TXNnIDogYCR7cGF0aH0gbXVzdCBtYXRjaCB0aGUgY29uZmlndXJlZCB0eXBlLiBgICsgYFRoZSB2YWxpZGF0ZWQgdmFsdWUgd2FzOiBcXGAke3ByaW50VmFsdWUodmFsdWUsIHRydWUpfVxcYGAgKyBjYXN0TXNnO1xyXG4gIH1cclxufTtcclxubGV0IHN0cmluZyA9IHtcclxuICBsZW5ndGg6ICcke3BhdGh9IG11c3QgYmUgZXhhY3RseSAke2xlbmd0aH0gY2hhcmFjdGVycycsXHJcbiAgbWluOiAnJHtwYXRofSBtdXN0IGJlIGF0IGxlYXN0ICR7bWlufSBjaGFyYWN0ZXJzJyxcclxuICBtYXg6ICcke3BhdGh9IG11c3QgYmUgYXQgbW9zdCAke21heH0gY2hhcmFjdGVycycsXHJcbiAgbWF0Y2hlczogJyR7cGF0aH0gbXVzdCBtYXRjaCB0aGUgZm9sbG93aW5nOiBcIiR7cmVnZXh9XCInLFxyXG4gIGVtYWlsOiAnJHtwYXRofSBtdXN0IGJlIGEgdmFsaWQgZW1haWwnLFxyXG4gIHVybDogJyR7cGF0aH0gbXVzdCBiZSBhIHZhbGlkIFVSTCcsXHJcbiAgdXVpZDogJyR7cGF0aH0gbXVzdCBiZSBhIHZhbGlkIFVVSUQnLFxyXG4gIGRhdGV0aW1lOiAnJHtwYXRofSBtdXN0IGJlIGEgdmFsaWQgSVNPIGRhdGUtdGltZScsXHJcbiAgZGF0ZXRpbWVfcHJlY2lzaW9uOiAnJHtwYXRofSBtdXN0IGJlIGEgdmFsaWQgSVNPIGRhdGUtdGltZSB3aXRoIGEgc3ViLXNlY29uZCBwcmVjaXNpb24gb2YgZXhhY3RseSAke3ByZWNpc2lvbn0gZGlnaXRzJyxcclxuICBkYXRldGltZV9vZmZzZXQ6ICcke3BhdGh9IG11c3QgYmUgYSB2YWxpZCBJU08gZGF0ZS10aW1lIHdpdGggVVRDIFwiWlwiIHRpbWV6b25lJyxcclxuICB0cmltOiAnJHtwYXRofSBtdXN0IGJlIGEgdHJpbW1lZCBzdHJpbmcnLFxyXG4gIGxvd2VyY2FzZTogJyR7cGF0aH0gbXVzdCBiZSBhIGxvd2VyY2FzZSBzdHJpbmcnLFxyXG4gIHVwcGVyY2FzZTogJyR7cGF0aH0gbXVzdCBiZSBhIHVwcGVyIGNhc2Ugc3RyaW5nJ1xyXG59O1xyXG5sZXQgbnVtYmVyID0ge1xyXG4gIG1pbjogJyR7cGF0aH0gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJHttaW59JyxcclxuICBtYXg6ICcke3BhdGh9IG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICR7bWF4fScsXHJcbiAgbGVzc1RoYW46ICcke3BhdGh9IG11c3QgYmUgbGVzcyB0aGFuICR7bGVzc30nLFxyXG4gIG1vcmVUaGFuOiAnJHtwYXRofSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAke21vcmV9JyxcclxuICBwb3NpdGl2ZTogJyR7cGF0aH0gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicsXHJcbiAgbmVnYXRpdmU6ICcke3BhdGh9IG11c3QgYmUgYSBuZWdhdGl2ZSBudW1iZXInLFxyXG4gIGludGVnZXI6ICcke3BhdGh9IG11c3QgYmUgYW4gaW50ZWdlcidcclxufTtcclxubGV0IGRhdGUgPSB7XHJcbiAgbWluOiAnJHtwYXRofSBmaWVsZCBtdXN0IGJlIGxhdGVyIHRoYW4gJHttaW59JyxcclxuICBtYXg6ICcke3BhdGh9IGZpZWxkIG11c3QgYmUgYXQgZWFybGllciB0aGFuICR7bWF4fSdcclxufTtcclxubGV0IGJvb2xlYW4gPSB7XHJcbiAgaXNWYWx1ZTogJyR7cGF0aH0gZmllbGQgbXVzdCBiZSAke3ZhbHVlfSdcclxufTtcclxubGV0IG9iamVjdCA9IHtcclxuICBub1Vua25vd246ICcke3BhdGh9IGZpZWxkIGhhcyB1bnNwZWNpZmllZCBrZXlzOiAke3Vua25vd259JyxcclxuICBleGFjdDogJyR7cGF0aH0gb2JqZWN0IGNvbnRhaW5zIHVua25vd24gcHJvcGVydGllczogJHtwcm9wZXJ0aWVzfSdcclxufTtcclxubGV0IGFycmF5ID0ge1xyXG4gIG1pbjogJyR7cGF0aH0gZmllbGQgbXVzdCBoYXZlIGF0IGxlYXN0ICR7bWlufSBpdGVtcycsXHJcbiAgbWF4OiAnJHtwYXRofSBmaWVsZCBtdXN0IGhhdmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICR7bWF4fSBpdGVtcycsXHJcbiAgbGVuZ3RoOiAnJHtwYXRofSBtdXN0IGhhdmUgJHtsZW5ndGh9IGl0ZW1zJ1xyXG59O1xyXG5sZXQgdHVwbGUgPSB7XHJcbiAgbm90VHlwZTogcGFyYW1zID0+IHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgcGF0aCxcclxuICAgICAgdmFsdWUsXHJcbiAgICAgIHNwZWNcclxuICAgIH0gPSBwYXJhbXM7XHJcbiAgICBjb25zdCB0eXBlTGVuID0gc3BlYy50eXBlcy5sZW5ndGg7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8IHR5cGVMZW4pIHJldHVybiBgJHtwYXRofSB0dXBsZSB2YWx1ZSBoYXMgdG9vIGZldyBpdGVtcywgZXhwZWN0ZWQgYSBsZW5ndGggb2YgJHt0eXBlTGVufSBidXQgZ290ICR7dmFsdWUubGVuZ3RofSBmb3IgdmFsdWU6IFxcYCR7cHJpbnRWYWx1ZSh2YWx1ZSwgdHJ1ZSl9XFxgYDtcclxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IHR5cGVMZW4pIHJldHVybiBgJHtwYXRofSB0dXBsZSB2YWx1ZSBoYXMgdG9vIG1hbnkgaXRlbXMsIGV4cGVjdGVkIGEgbGVuZ3RoIG9mICR7dHlwZUxlbn0gYnV0IGdvdCAke3ZhbHVlLmxlbmd0aH0gZm9yIHZhbHVlOiBcXGAke3ByaW50VmFsdWUodmFsdWUsIHRydWUpfVxcYGA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gVmFsaWRhdGlvbkVycm9yLmZvcm1hdEVycm9yKG1peGVkLm5vdFR5cGUsIHBhcmFtcyk7XHJcbiAgfVxyXG59O1xyXG52YXIgbG9jYWxlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XHJcbiAgbWl4ZWQsXHJcbiAgc3RyaW5nLFxyXG4gIG51bWJlcixcclxuICBkYXRlLFxyXG4gIG9iamVjdCxcclxuICBhcnJheSxcclxuICBib29sZWFuLFxyXG4gIHR1cGxlXHJcbn0pO1xyXG5cclxuY29uc3QgaXNTY2hlbWEgPSBvYmogPT4gb2JqICYmIG9iai5fX2lzWXVwU2NoZW1hX187XHJcblxyXG5jbGFzcyBDb25kaXRpb24ge1xyXG4gIHN0YXRpYyBmcm9tT3B0aW9ucyhyZWZzLCBjb25maWcpIHtcclxuICAgIGlmICghY29uZmlnLnRoZW4gJiYgIWNvbmZpZy5vdGhlcndpc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VpdGhlciBgdGhlbjpgIG9yIGBvdGhlcndpc2U6YCBpcyByZXF1aXJlZCBmb3IgYHdoZW4oKWAgY29uZGl0aW9ucycpO1xyXG4gICAgbGV0IHtcclxuICAgICAgaXMsXHJcbiAgICAgIHRoZW4sXHJcbiAgICAgIG90aGVyd2lzZVxyXG4gICAgfSA9IGNvbmZpZztcclxuICAgIGxldCBjaGVjayA9IHR5cGVvZiBpcyA9PT0gJ2Z1bmN0aW9uJyA/IGlzIDogKC4uLnZhbHVlcykgPT4gdmFsdWVzLmV2ZXJ5KHZhbHVlID0+IHZhbHVlID09PSBpcyk7XHJcbiAgICByZXR1cm4gbmV3IENvbmRpdGlvbihyZWZzLCAodmFsdWVzLCBzY2hlbWEpID0+IHtcclxuICAgICAgdmFyIF9icmFuY2g7XHJcbiAgICAgIGxldCBicmFuY2ggPSBjaGVjayguLi52YWx1ZXMpID8gdGhlbiA6IG90aGVyd2lzZTtcclxuICAgICAgcmV0dXJuIChfYnJhbmNoID0gYnJhbmNoID09IG51bGwgPyB2b2lkIDAgOiBicmFuY2goc2NoZW1hKSkgIT0gbnVsbCA/IF9icmFuY2ggOiBzY2hlbWE7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgY29uc3RydWN0b3IocmVmcywgYnVpbGRlcikge1xyXG4gICAgdGhpcy5mbiA9IHZvaWQgMDtcclxuICAgIHRoaXMucmVmcyA9IHJlZnM7XHJcbiAgICB0aGlzLnJlZnMgPSByZWZzO1xyXG4gICAgdGhpcy5mbiA9IGJ1aWxkZXI7XHJcbiAgfVxyXG4gIHJlc29sdmUoYmFzZSwgb3B0aW9ucykge1xyXG4gICAgbGV0IHZhbHVlcyA9IHRoaXMucmVmcy5tYXAocmVmID0+XHJcbiAgICAvLyBUT0RPOiA/IG9wZXJhdG9yIGhlcmU/XHJcbiAgICByZWYuZ2V0VmFsdWUob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy52YWx1ZSwgb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5wYXJlbnQsIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuY29udGV4dCkpO1xyXG4gICAgbGV0IHNjaGVtYSA9IHRoaXMuZm4odmFsdWVzLCBiYXNlLCBvcHRpb25zKTtcclxuICAgIGlmIChzY2hlbWEgPT09IHVuZGVmaW5lZCB8fFxyXG4gICAgLy8gQHRzLWlnbm9yZSB0aGlzIGNhbiBiZSBiYXNlXHJcbiAgICBzY2hlbWEgPT09IGJhc2UpIHtcclxuICAgICAgcmV0dXJuIGJhc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzU2NoZW1hKHNjaGVtYSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NvbmRpdGlvbnMgbXVzdCByZXR1cm4gYSBzY2hlbWEgb2JqZWN0Jyk7XHJcbiAgICByZXR1cm4gc2NoZW1hLnJlc29sdmUob3B0aW9ucyk7XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBwcmVmaXhlcyA9IHtcclxuICBjb250ZXh0OiAnJCcsXHJcbiAgdmFsdWU6ICcuJ1xyXG59O1xyXG5mdW5jdGlvbiBjcmVhdGUkOShrZXksIG9wdGlvbnMpIHtcclxuICByZXR1cm4gbmV3IFJlZmVyZW5jZShrZXksIG9wdGlvbnMpO1xyXG59XHJcbmNsYXNzIFJlZmVyZW5jZSB7XHJcbiAgY29uc3RydWN0b3Ioa2V5LCBvcHRpb25zID0ge30pIHtcclxuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xyXG4gICAgdGhpcy5pc0NvbnRleHQgPSB2b2lkIDA7XHJcbiAgICB0aGlzLmlzVmFsdWUgPSB2b2lkIDA7XHJcbiAgICB0aGlzLmlzU2libGluZyA9IHZvaWQgMDtcclxuICAgIHRoaXMucGF0aCA9IHZvaWQgMDtcclxuICAgIHRoaXMuZ2V0dGVyID0gdm9pZCAwO1xyXG4gICAgdGhpcy5tYXAgPSB2b2lkIDA7XHJcbiAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JlZiBtdXN0IGJlIGEgc3RyaW5nLCBnb3Q6ICcgKyBrZXkpO1xyXG4gICAgdGhpcy5rZXkgPSBrZXkudHJpbSgpO1xyXG4gICAgaWYgKGtleSA9PT0gJycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JlZiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xyXG4gICAgdGhpcy5pc0NvbnRleHQgPSB0aGlzLmtleVswXSA9PT0gcHJlZml4ZXMuY29udGV4dDtcclxuICAgIHRoaXMuaXNWYWx1ZSA9IHRoaXMua2V5WzBdID09PSBwcmVmaXhlcy52YWx1ZTtcclxuICAgIHRoaXMuaXNTaWJsaW5nID0gIXRoaXMuaXNDb250ZXh0ICYmICF0aGlzLmlzVmFsdWU7XHJcbiAgICBsZXQgcHJlZml4ID0gdGhpcy5pc0NvbnRleHQgPyBwcmVmaXhlcy5jb250ZXh0IDogdGhpcy5pc1ZhbHVlID8gcHJlZml4ZXMudmFsdWUgOiAnJztcclxuICAgIHRoaXMucGF0aCA9IHRoaXMua2V5LnNsaWNlKHByZWZpeC5sZW5ndGgpO1xyXG4gICAgdGhpcy5nZXR0ZXIgPSB0aGlzLnBhdGggJiYgZ2V0dGVyKHRoaXMucGF0aCwgdHJ1ZSk7XHJcbiAgICB0aGlzLm1hcCA9IG9wdGlvbnMubWFwO1xyXG4gIH1cclxuICBnZXRWYWx1ZSh2YWx1ZSwgcGFyZW50LCBjb250ZXh0KSB7XHJcbiAgICBsZXQgcmVzdWx0ID0gdGhpcy5pc0NvbnRleHQgPyBjb250ZXh0IDogdGhpcy5pc1ZhbHVlID8gdmFsdWUgOiBwYXJlbnQ7XHJcbiAgICBpZiAodGhpcy5nZXR0ZXIpIHJlc3VsdCA9IHRoaXMuZ2V0dGVyKHJlc3VsdCB8fCB7fSk7XHJcbiAgICBpZiAodGhpcy5tYXApIHJlc3VsdCA9IHRoaXMubWFwKHJlc3VsdCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IHZhbHVlXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMuY29udGV4dFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucy5wYXJlbnRcclxuICAgKi9cclxuICBjYXN0KHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZSh2YWx1ZSwgb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5wYXJlbnQsIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuY29udGV4dCk7XHJcbiAgfVxyXG4gIHJlc29sdmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbiAgZGVzY3JpYmUoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0eXBlOiAncmVmJyxcclxuICAgICAga2V5OiB0aGlzLmtleVxyXG4gICAgfTtcclxuICB9XHJcbiAgdG9TdHJpbmcoKSB7XHJcbiAgICByZXR1cm4gYFJlZigke3RoaXMua2V5fSlgO1xyXG4gIH1cclxuICBzdGF0aWMgaXNSZWYodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5fX2lzWXVwUmVmO1xyXG4gIH1cclxufVxyXG5cclxuLy8gQHRzLWlnbm9yZVxyXG5SZWZlcmVuY2UucHJvdG90eXBlLl9faXNZdXBSZWYgPSB0cnVlO1xyXG5cclxuY29uc3QgaXNBYnNlbnQgPSB2YWx1ZSA9PiB2YWx1ZSA9PSBudWxsO1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlVmFsaWRhdGlvbihjb25maWcpIHtcclxuICBmdW5jdGlvbiB2YWxpZGF0ZSh7XHJcbiAgICB2YWx1ZSxcclxuICAgIHBhdGggPSAnJyxcclxuICAgIG9wdGlvbnMsXHJcbiAgICBvcmlnaW5hbFZhbHVlLFxyXG4gICAgc2NoZW1hXHJcbiAgfSwgcGFuaWMsIG5leHQpIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgbmFtZSxcclxuICAgICAgdGVzdCxcclxuICAgICAgcGFyYW1zLFxyXG4gICAgICBtZXNzYWdlLFxyXG4gICAgICBza2lwQWJzZW50XHJcbiAgICB9ID0gY29uZmlnO1xyXG4gICAgbGV0IHtcclxuICAgICAgcGFyZW50LFxyXG4gICAgICBjb250ZXh0LFxyXG4gICAgICBhYm9ydEVhcmx5ID0gc2NoZW1hLnNwZWMuYWJvcnRFYXJseSxcclxuICAgICAgZGlzYWJsZVN0YWNrVHJhY2UgPSBzY2hlbWEuc3BlYy5kaXNhYmxlU3RhY2tUcmFjZVxyXG4gICAgfSA9IG9wdGlvbnM7XHJcbiAgICBmdW5jdGlvbiByZXNvbHZlKGl0ZW0pIHtcclxuICAgICAgcmV0dXJuIFJlZmVyZW5jZS5pc1JlZihpdGVtKSA/IGl0ZW0uZ2V0VmFsdWUodmFsdWUsIHBhcmVudCwgY29udGV4dCkgOiBpdGVtO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlRXJyb3Iob3ZlcnJpZGVzID0ge30pIHtcclxuICAgICAgY29uc3QgbmV4dFBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe1xyXG4gICAgICAgIHZhbHVlLFxyXG4gICAgICAgIG9yaWdpbmFsVmFsdWUsXHJcbiAgICAgICAgbGFiZWw6IHNjaGVtYS5zcGVjLmxhYmVsLFxyXG4gICAgICAgIHBhdGg6IG92ZXJyaWRlcy5wYXRoIHx8IHBhdGgsXHJcbiAgICAgICAgc3BlYzogc2NoZW1hLnNwZWMsXHJcbiAgICAgICAgZGlzYWJsZVN0YWNrVHJhY2U6IG92ZXJyaWRlcy5kaXNhYmxlU3RhY2tUcmFjZSB8fCBkaXNhYmxlU3RhY2tUcmFjZVxyXG4gICAgICB9LCBwYXJhbXMsIG92ZXJyaWRlcy5wYXJhbXMpO1xyXG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhuZXh0UGFyYW1zKSkgbmV4dFBhcmFtc1trZXldID0gcmVzb2x2ZShuZXh0UGFyYW1zW2tleV0pO1xyXG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBWYWxpZGF0aW9uRXJyb3IoVmFsaWRhdGlvbkVycm9yLmZvcm1hdEVycm9yKG92ZXJyaWRlcy5tZXNzYWdlIHx8IG1lc3NhZ2UsIG5leHRQYXJhbXMpLCB2YWx1ZSwgbmV4dFBhcmFtcy5wYXRoLCBvdmVycmlkZXMudHlwZSB8fCBuYW1lLCBuZXh0UGFyYW1zLmRpc2FibGVTdGFja1RyYWNlKTtcclxuICAgICAgZXJyb3IucGFyYW1zID0gbmV4dFBhcmFtcztcclxuICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaW52YWxpZCA9IGFib3J0RWFybHkgPyBwYW5pYyA6IG5leHQ7XHJcbiAgICBsZXQgY3R4ID0ge1xyXG4gICAgICBwYXRoLFxyXG4gICAgICBwYXJlbnQsXHJcbiAgICAgIHR5cGU6IG5hbWUsXHJcbiAgICAgIGZyb206IG9wdGlvbnMuZnJvbSxcclxuICAgICAgY3JlYXRlRXJyb3IsXHJcbiAgICAgIHJlc29sdmUsXHJcbiAgICAgIG9wdGlvbnMsXHJcbiAgICAgIG9yaWdpbmFsVmFsdWUsXHJcbiAgICAgIHNjaGVtYVxyXG4gICAgfTtcclxuICAgIGNvbnN0IGhhbmRsZVJlc3VsdCA9IHZhbGlkT3JFcnJvciA9PiB7XHJcbiAgICAgIGlmIChWYWxpZGF0aW9uRXJyb3IuaXNFcnJvcih2YWxpZE9yRXJyb3IpKSBpbnZhbGlkKHZhbGlkT3JFcnJvcik7ZWxzZSBpZiAoIXZhbGlkT3JFcnJvcikgaW52YWxpZChjcmVhdGVFcnJvcigpKTtlbHNlIG5leHQobnVsbCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaGFuZGxlRXJyb3IgPSBlcnIgPT4ge1xyXG4gICAgICBpZiAoVmFsaWRhdGlvbkVycm9yLmlzRXJyb3IoZXJyKSkgaW52YWxpZChlcnIpO2Vsc2UgcGFuaWMoZXJyKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBzaG91bGRTa2lwID0gc2tpcEFic2VudCAmJiBpc0Fic2VudCh2YWx1ZSk7XHJcbiAgICBpZiAoc2hvdWxkU2tpcCkge1xyXG4gICAgICByZXR1cm4gaGFuZGxlUmVzdWx0KHRydWUpO1xyXG4gICAgfVxyXG4gICAgbGV0IHJlc3VsdDtcclxuICAgIHRyeSB7XHJcbiAgICAgIHZhciBfcmVzdWx0O1xyXG4gICAgICByZXN1bHQgPSB0ZXN0LmNhbGwoY3R4LCB2YWx1ZSwgY3R4KTtcclxuICAgICAgaWYgKHR5cGVvZiAoKF9yZXN1bHQgPSByZXN1bHQpID09IG51bGwgPyB2b2lkIDAgOiBfcmVzdWx0LnRoZW4pID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc3luYykge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYWxpZGF0aW9uIHRlc3Qgb2YgdHlwZTogXCIke2N0eC50eXBlfVwiIHJldHVybmVkIGEgUHJvbWlzZSBkdXJpbmcgYSBzeW5jaHJvbm91cyB2YWxpZGF0ZS4gYCArIGBUaGlzIHRlc3Qgd2lsbCBmaW5pc2ggYWZ0ZXIgdGhlIHZhbGlkYXRlIGNhbGwgaGFzIHJldHVybmVkYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KS50aGVuKGhhbmRsZVJlc3VsdCwgaGFuZGxlRXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgaGFuZGxlRXJyb3IoZXJyKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaGFuZGxlUmVzdWx0KHJlc3VsdCk7XHJcbiAgfVxyXG4gIHZhbGlkYXRlLk9QVElPTlMgPSBjb25maWc7XHJcbiAgcmV0dXJuIHZhbGlkYXRlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRJbihzY2hlbWEsIHBhdGgsIHZhbHVlLCBjb250ZXh0ID0gdmFsdWUpIHtcclxuICBsZXQgcGFyZW50LCBsYXN0UGFydCwgbGFzdFBhcnREZWJ1ZztcclxuXHJcbiAgLy8gcm9vdCBwYXRoOiAnJ1xyXG4gIGlmICghcGF0aCkgcmV0dXJuIHtcclxuICAgIHBhcmVudCxcclxuICAgIHBhcmVudFBhdGg6IHBhdGgsXHJcbiAgICBzY2hlbWFcclxuICB9O1xyXG4gIGZvckVhY2gocGF0aCwgKF9wYXJ0LCBpc0JyYWNrZXQsIGlzQXJyYXkpID0+IHtcclxuICAgIGxldCBwYXJ0ID0gaXNCcmFja2V0ID8gX3BhcnQuc2xpY2UoMSwgX3BhcnQubGVuZ3RoIC0gMSkgOiBfcGFydDtcclxuICAgIHNjaGVtYSA9IHNjaGVtYS5yZXNvbHZlKHtcclxuICAgICAgY29udGV4dCxcclxuICAgICAgcGFyZW50LFxyXG4gICAgICB2YWx1ZVxyXG4gICAgfSk7XHJcbiAgICBsZXQgaXNUdXBsZSA9IHNjaGVtYS50eXBlID09PSAndHVwbGUnO1xyXG4gICAgbGV0IGlkeCA9IGlzQXJyYXkgPyBwYXJzZUludChwYXJ0LCAxMCkgOiAwO1xyXG4gICAgaWYgKHNjaGVtYS5pbm5lclR5cGUgfHwgaXNUdXBsZSkge1xyXG4gICAgICBpZiAoaXNUdXBsZSAmJiAhaXNBcnJheSkgdGhyb3cgbmV3IEVycm9yKGBZdXAucmVhY2ggY2Fubm90IGltcGxpY2l0bHkgaW5kZXggaW50byBhIHR1cGxlIHR5cGUuIHRoZSBwYXRoIHBhcnQgXCIke2xhc3RQYXJ0RGVidWd9XCIgbXVzdCBjb250YWluIGFuIGluZGV4IHRvIHRoZSB0dXBsZSBlbGVtZW50LCBlLmcuIFwiJHtsYXN0UGFydERlYnVnfVswXVwiYCk7XHJcbiAgICAgIGlmICh2YWx1ZSAmJiBpZHggPj0gdmFsdWUubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZdXAucmVhY2ggY2Fubm90IHJlc29sdmUgYW4gYXJyYXkgaXRlbSBhdCBpbmRleDogJHtfcGFydH0sIGluIHRoZSBwYXRoOiAke3BhdGh9LiBgICsgYGJlY2F1c2UgdGhlcmUgaXMgbm8gdmFsdWUgYXQgdGhhdCBpbmRleC4gYCk7XHJcbiAgICAgIH1cclxuICAgICAgcGFyZW50ID0gdmFsdWU7XHJcbiAgICAgIHZhbHVlID0gdmFsdWUgJiYgdmFsdWVbaWR4XTtcclxuICAgICAgc2NoZW1hID0gaXNUdXBsZSA/IHNjaGVtYS5zcGVjLnR5cGVzW2lkeF0gOiBzY2hlbWEuaW5uZXJUeXBlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNvbWV0aW1lcyB0aGUgYXJyYXkgaW5kZXggcGFydCBvZiBhIHBhdGggZG9lc24ndCBleGlzdDogXCJuZXN0ZWQuYXJyLmNoaWxkXCJcclxuICAgIC8vIGluIHRoZXNlIGNhc2VzIHRoZSBjdXJyZW50IHBhcnQgaXMgdGhlIG5leHQgc2NoZW1hIGFuZCBzaG91bGQgYmUgcHJvY2Vzc2VkXHJcbiAgICAvLyBpbiB0aGlzIGl0ZXJhdGlvbi4gRm9yIGNhc2VzIHdoZXJlIHRoZSBpbmRleCBzaWduYXR1cmUgaXMgaW5jbHVkZWQgdGhpc1xyXG4gICAgLy8gY2hlY2sgd2lsbCBmYWlsIGFuZCB3ZSdsbCBoYW5kbGUgdGhlIGBjaGlsZGAgcGFydCBvbiB0aGUgbmV4dCBpdGVyYXRpb24gbGlrZSBub3JtYWxcclxuICAgIGlmICghaXNBcnJheSkge1xyXG4gICAgICBpZiAoIXNjaGVtYS5maWVsZHMgfHwgIXNjaGVtYS5maWVsZHNbcGFydF0pIHRocm93IG5ldyBFcnJvcihgVGhlIHNjaGVtYSBkb2VzIG5vdCBjb250YWluIHRoZSBwYXRoOiAke3BhdGh9LiBgICsgYChmYWlsZWQgYXQ6ICR7bGFzdFBhcnREZWJ1Z30gd2hpY2ggaXMgYSB0eXBlOiBcIiR7c2NoZW1hLnR5cGV9XCIpYCk7XHJcbiAgICAgIHBhcmVudCA9IHZhbHVlO1xyXG4gICAgICB2YWx1ZSA9IHZhbHVlICYmIHZhbHVlW3BhcnRdO1xyXG4gICAgICBzY2hlbWEgPSBzY2hlbWEuZmllbGRzW3BhcnRdO1xyXG4gICAgfVxyXG4gICAgbGFzdFBhcnQgPSBwYXJ0O1xyXG4gICAgbGFzdFBhcnREZWJ1ZyA9IGlzQnJhY2tldCA/ICdbJyArIF9wYXJ0ICsgJ10nIDogJy4nICsgX3BhcnQ7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHtcclxuICAgIHNjaGVtYSxcclxuICAgIHBhcmVudCxcclxuICAgIHBhcmVudFBhdGg6IGxhc3RQYXJ0XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiByZWFjaChvYmosIHBhdGgsIHZhbHVlLCBjb250ZXh0KSB7XHJcbiAgcmV0dXJuIGdldEluKG9iaiwgcGF0aCwgdmFsdWUsIGNvbnRleHQpLnNjaGVtYTtcclxufVxyXG5cclxuY2xhc3MgUmVmZXJlbmNlU2V0IGV4dGVuZHMgU2V0IHtcclxuICBkZXNjcmliZSgpIHtcclxuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gW107XHJcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy52YWx1ZXMoKSkge1xyXG4gICAgICBkZXNjcmlwdGlvbi5wdXNoKFJlZmVyZW5jZS5pc1JlZihpdGVtKSA/IGl0ZW0uZGVzY3JpYmUoKSA6IGl0ZW0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xyXG4gIH1cclxuICByZXNvbHZlQWxsKHJlc29sdmUpIHtcclxuICAgIGxldCByZXN1bHQgPSBbXTtcclxuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLnZhbHVlcygpKSB7XHJcbiAgICAgIHJlc3VsdC5wdXNoKHJlc29sdmUoaXRlbSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcbiAgY2xvbmUoKSB7XHJcbiAgICByZXR1cm4gbmV3IFJlZmVyZW5jZVNldCh0aGlzLnZhbHVlcygpKTtcclxuICB9XHJcbiAgbWVyZ2UobmV3SXRlbXMsIHJlbW92ZUl0ZW1zKSB7XHJcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xyXG4gICAgbmV3SXRlbXMuZm9yRWFjaCh2YWx1ZSA9PiBuZXh0LmFkZCh2YWx1ZSkpO1xyXG4gICAgcmVtb3ZlSXRlbXMuZm9yRWFjaCh2YWx1ZSA9PiBuZXh0LmRlbGV0ZSh2YWx1ZSkpO1xyXG4gICAgcmV0dXJuIG5leHQ7XHJcbiAgfVxyXG59XHJcblxyXG4vLyB0d2Vha2VkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL0tlbGluMjAyNS9uYW5vY2xvbmUvYmxvYi8wYWJlYjc2MzViZGE5YjY4ZWYyMjc3MDkzZjc2ZGJlM2JmMzk0OGUxL3NyYy9pbmRleC5qc1xyXG5mdW5jdGlvbiBjbG9uZShzcmMsIHNlZW4gPSBuZXcgTWFwKCkpIHtcclxuICBpZiAoaXNTY2hlbWEoc3JjKSB8fCAhc3JjIHx8IHR5cGVvZiBzcmMgIT09ICdvYmplY3QnKSByZXR1cm4gc3JjO1xyXG4gIGlmIChzZWVuLmhhcyhzcmMpKSByZXR1cm4gc2Vlbi5nZXQoc3JjKTtcclxuICBsZXQgY29weTtcclxuICBpZiAoc3JjIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgLy8gRGF0ZVxyXG4gICAgY29weSA9IG5ldyBEYXRlKHNyYy5nZXRUaW1lKCkpO1xyXG4gICAgc2Vlbi5zZXQoc3JjLCBjb3B5KTtcclxuICB9IGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIFJlZ0V4cCkge1xyXG4gICAgLy8gUmVnRXhwXHJcbiAgICBjb3B5ID0gbmV3IFJlZ0V4cChzcmMpO1xyXG4gICAgc2Vlbi5zZXQoc3JjLCBjb3B5KTtcclxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc3JjKSkge1xyXG4gICAgLy8gQXJyYXlcclxuICAgIGNvcHkgPSBuZXcgQXJyYXkoc3JjLmxlbmd0aCk7XHJcbiAgICBzZWVuLnNldChzcmMsIGNvcHkpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcmMubGVuZ3RoOyBpKyspIGNvcHlbaV0gPSBjbG9uZShzcmNbaV0sIHNlZW4pO1xyXG4gIH0gZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgTWFwKSB7XHJcbiAgICAvLyBNYXBcclxuICAgIGNvcHkgPSBuZXcgTWFwKCk7XHJcbiAgICBzZWVuLnNldChzcmMsIGNvcHkpO1xyXG4gICAgZm9yIChjb25zdCBbaywgdl0gb2Ygc3JjLmVudHJpZXMoKSkgY29weS5zZXQoaywgY2xvbmUodiwgc2VlbikpO1xyXG4gIH0gZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgU2V0KSB7XHJcbiAgICAvLyBTZXRcclxuICAgIGNvcHkgPSBuZXcgU2V0KCk7XHJcbiAgICBzZWVuLnNldChzcmMsIGNvcHkpO1xyXG4gICAgZm9yIChjb25zdCB2IG9mIHNyYykgY29weS5hZGQoY2xvbmUodiwgc2VlbikpO1xyXG4gIH0gZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgT2JqZWN0KSB7XHJcbiAgICAvLyBPYmplY3RcclxuICAgIGNvcHkgPSB7fTtcclxuICAgIHNlZW4uc2V0KHNyYywgY29weSk7XHJcbiAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhzcmMpKSBjb3B5W2tdID0gY2xvbmUodiwgc2Vlbik7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRocm93IEVycm9yKGBVbmFibGUgdG8gY2xvbmUgJHtzcmN9YCk7XHJcbiAgfVxyXG4gIHJldHVybiBjb3B5O1xyXG59XHJcblxyXG4vLyBJZiBgQ3VzdG9tU2NoZW1hTWV0YWAgaXNuJ3QgZXh0ZW5kZWQgd2l0aCBhbnkga2V5cywgd2UnbGwgZmFsbCBiYWNrIHRvIGFcclxuLy8gbG9vc2UgUmVjb3JkIGRlZmluaXRpb24gYWxsb3dpbmcgZnJlZSBmb3JtIHVzYWdlLlxyXG5jbGFzcyBTY2hlbWEge1xyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgIHRoaXMudHlwZSA9IHZvaWQgMDtcclxuICAgIHRoaXMuZGVwcyA9IFtdO1xyXG4gICAgdGhpcy50ZXN0cyA9IHZvaWQgMDtcclxuICAgIHRoaXMudHJhbnNmb3JtcyA9IHZvaWQgMDtcclxuICAgIHRoaXMuY29uZGl0aW9ucyA9IFtdO1xyXG4gICAgdGhpcy5fbXV0YXRlID0gdm9pZCAwO1xyXG4gICAgdGhpcy5pbnRlcm5hbFRlc3RzID0ge307XHJcbiAgICB0aGlzLl93aGl0ZWxpc3QgPSBuZXcgUmVmZXJlbmNlU2V0KCk7XHJcbiAgICB0aGlzLl9ibGFja2xpc3QgPSBuZXcgUmVmZXJlbmNlU2V0KCk7XHJcbiAgICB0aGlzLmV4Y2x1c2l2ZVRlc3RzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIHRoaXMuX3R5cGVDaGVjayA9IHZvaWQgMDtcclxuICAgIHRoaXMuc3BlYyA9IHZvaWQgMDtcclxuICAgIHRoaXMudGVzdHMgPSBbXTtcclxuICAgIHRoaXMudHJhbnNmb3JtcyA9IFtdO1xyXG4gICAgdGhpcy53aXRoTXV0YXRpb24oKCkgPT4ge1xyXG4gICAgICB0aGlzLnR5cGVFcnJvcihtaXhlZC5ub3RUeXBlKTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlO1xyXG4gICAgdGhpcy5fdHlwZUNoZWNrID0gb3B0aW9ucy5jaGVjaztcclxuICAgIHRoaXMuc3BlYyA9IE9iamVjdC5hc3NpZ24oe1xyXG4gICAgICBzdHJpcDogZmFsc2UsXHJcbiAgICAgIHN0cmljdDogZmFsc2UsXHJcbiAgICAgIGFib3J0RWFybHk6IHRydWUsXHJcbiAgICAgIHJlY3Vyc2l2ZTogdHJ1ZSxcclxuICAgICAgZGlzYWJsZVN0YWNrVHJhY2U6IGZhbHNlLFxyXG4gICAgICBudWxsYWJsZTogZmFsc2UsXHJcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxyXG4gICAgICBjb2VyY2U6IHRydWVcclxuICAgIH0sIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc3BlYyk7XHJcbiAgICB0aGlzLndpdGhNdXRhdGlvbihzID0+IHtcclxuICAgICAgcy5ub25OdWxsYWJsZSgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBUT0RPOiByZW1vdmVcclxuICBnZXQgX3R5cGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy50eXBlO1xyXG4gIH1cclxuICBjbG9uZShzcGVjKSB7XHJcbiAgICBpZiAodGhpcy5fbXV0YXRlKSB7XHJcbiAgICAgIGlmIChzcGVjKSBPYmplY3QuYXNzaWduKHRoaXMuc3BlYywgc3BlYyk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIHRoZSBuZXN0ZWQgdmFsdWUgaXMgYSBzY2hlbWEgd2UgY2FuIHNraXAgY2xvbmluZywgc2luY2VcclxuICAgIC8vIHRoZXkgYXJlIGFscmVhZHkgaW1tdXRhYmxlXHJcbiAgICBjb25zdCBuZXh0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykpO1xyXG5cclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdGhpcyBpcyByZWFkb25seVxyXG4gICAgbmV4dC50eXBlID0gdGhpcy50eXBlO1xyXG4gICAgbmV4dC5fdHlwZUNoZWNrID0gdGhpcy5fdHlwZUNoZWNrO1xyXG4gICAgbmV4dC5fd2hpdGVsaXN0ID0gdGhpcy5fd2hpdGVsaXN0LmNsb25lKCk7XHJcbiAgICBuZXh0Ll9ibGFja2xpc3QgPSB0aGlzLl9ibGFja2xpc3QuY2xvbmUoKTtcclxuICAgIG5leHQuaW50ZXJuYWxUZXN0cyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaW50ZXJuYWxUZXN0cyk7XHJcbiAgICBuZXh0LmV4Y2x1c2l2ZVRlc3RzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5leGNsdXNpdmVUZXN0cyk7XHJcblxyXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0aGlzIGlzIHJlYWRvbmx5XHJcbiAgICBuZXh0LmRlcHMgPSBbLi4udGhpcy5kZXBzXTtcclxuICAgIG5leHQuY29uZGl0aW9ucyA9IFsuLi50aGlzLmNvbmRpdGlvbnNdO1xyXG4gICAgbmV4dC50ZXN0cyA9IFsuLi50aGlzLnRlc3RzXTtcclxuICAgIG5leHQudHJhbnNmb3JtcyA9IFsuLi50aGlzLnRyYW5zZm9ybXNdO1xyXG4gICAgbmV4dC5zcGVjID0gY2xvbmUoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zcGVjLCBzcGVjKSk7XHJcbiAgICByZXR1cm4gbmV4dDtcclxuICB9XHJcbiAgbGFiZWwobGFiZWwpIHtcclxuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xyXG4gICAgbmV4dC5zcGVjLmxhYmVsID0gbGFiZWw7XHJcbiAgICByZXR1cm4gbmV4dDtcclxuICB9XHJcbiAgbWV0YSguLi5hcmdzKSB7XHJcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLnNwZWMubWV0YTtcclxuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xyXG4gICAgbmV4dC5zcGVjLm1ldGEgPSBPYmplY3QuYXNzaWduKG5leHQuc3BlYy5tZXRhIHx8IHt9LCBhcmdzWzBdKTtcclxuICAgIHJldHVybiBuZXh0O1xyXG4gIH1cclxuICB3aXRoTXV0YXRpb24oZm4pIHtcclxuICAgIGxldCBiZWZvcmUgPSB0aGlzLl9tdXRhdGU7XHJcbiAgICB0aGlzLl9tdXRhdGUgPSB0cnVlO1xyXG4gICAgbGV0IHJlc3VsdCA9IGZuKHRoaXMpO1xyXG4gICAgdGhpcy5fbXV0YXRlID0gYmVmb3JlO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcbiAgY29uY2F0KHNjaGVtYSkge1xyXG4gICAgaWYgKCFzY2hlbWEgfHwgc2NoZW1hID09PSB0aGlzKSByZXR1cm4gdGhpcztcclxuICAgIGlmIChzY2hlbWEudHlwZSAhPT0gdGhpcy50eXBlICYmIHRoaXMudHlwZSAhPT0gJ21peGVkJykgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IGNhbm5vdCBcXGBjb25jYXQoKVxcYCBzY2hlbWEncyBvZiBkaWZmZXJlbnQgdHlwZXM6ICR7dGhpcy50eXBlfSBhbmQgJHtzY2hlbWEudHlwZX1gKTtcclxuICAgIGxldCBiYXNlID0gdGhpcztcclxuICAgIGxldCBjb21iaW5lZCA9IHNjaGVtYS5jbG9uZSgpO1xyXG4gICAgY29uc3QgbWVyZ2VkU3BlYyA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2Uuc3BlYywgY29tYmluZWQuc3BlYyk7XHJcbiAgICBjb21iaW5lZC5zcGVjID0gbWVyZ2VkU3BlYztcclxuICAgIGNvbWJpbmVkLmludGVybmFsVGVzdHMgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlLmludGVybmFsVGVzdHMsIGNvbWJpbmVkLmludGVybmFsVGVzdHMpO1xyXG5cclxuICAgIC8vIG1hbnVhbGx5IG1lcmdlIHRoZSBibGFja2xpc3Qvd2hpdGVsaXN0ICh0aGUgb3RoZXIgYHNjaGVtYWAgdGFrZXNcclxuICAgIC8vIHByZWNlZGVuY2UgaW4gY2FzZSBvZiBjb25mbGljdHMpXHJcbiAgICBjb21iaW5lZC5fd2hpdGVsaXN0ID0gYmFzZS5fd2hpdGVsaXN0Lm1lcmdlKHNjaGVtYS5fd2hpdGVsaXN0LCBzY2hlbWEuX2JsYWNrbGlzdCk7XHJcbiAgICBjb21iaW5lZC5fYmxhY2tsaXN0ID0gYmFzZS5fYmxhY2tsaXN0Lm1lcmdlKHNjaGVtYS5fYmxhY2tsaXN0LCBzY2hlbWEuX3doaXRlbGlzdCk7XHJcblxyXG4gICAgLy8gc3RhcnQgd2l0aCB0aGUgY3VycmVudCB0ZXN0c1xyXG4gICAgY29tYmluZWQudGVzdHMgPSBiYXNlLnRlc3RzO1xyXG4gICAgY29tYmluZWQuZXhjbHVzaXZlVGVzdHMgPSBiYXNlLmV4Y2x1c2l2ZVRlc3RzO1xyXG5cclxuICAgIC8vIG1hbnVhbGx5IGFkZCB0aGUgbmV3IHRlc3RzIHRvIGVuc3VyZVxyXG4gICAgLy8gdGhlIGRlZHVwaW5nIGxvZ2ljIGlzIGNvbnNpc3RlbnRcclxuICAgIGNvbWJpbmVkLndpdGhNdXRhdGlvbihuZXh0ID0+IHtcclxuICAgICAgc2NoZW1hLnRlc3RzLmZvckVhY2goZm4gPT4ge1xyXG4gICAgICAgIG5leHQudGVzdChmbi5PUFRJT05TKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIGNvbWJpbmVkLnRyYW5zZm9ybXMgPSBbLi4uYmFzZS50cmFuc2Zvcm1zLCAuLi5jb21iaW5lZC50cmFuc2Zvcm1zXTtcclxuICAgIHJldHVybiBjb21iaW5lZDtcclxuICB9XHJcbiAgaXNUeXBlKHYpIHtcclxuICAgIGlmICh2ID09IG51bGwpIHtcclxuICAgICAgaWYgKHRoaXMuc3BlYy5udWxsYWJsZSAmJiB2ID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgaWYgKHRoaXMuc3BlYy5vcHRpb25hbCAmJiB2ID09PSB1bmRlZmluZWQpIHJldHVybiB0cnVlO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5fdHlwZUNoZWNrKHYpO1xyXG4gIH1cclxuICByZXNvbHZlKG9wdGlvbnMpIHtcclxuICAgIGxldCBzY2hlbWEgPSB0aGlzO1xyXG4gICAgaWYgKHNjaGVtYS5jb25kaXRpb25zLmxlbmd0aCkge1xyXG4gICAgICBsZXQgY29uZGl0aW9ucyA9IHNjaGVtYS5jb25kaXRpb25zO1xyXG4gICAgICBzY2hlbWEgPSBzY2hlbWEuY2xvbmUoKTtcclxuICAgICAgc2NoZW1hLmNvbmRpdGlvbnMgPSBbXTtcclxuICAgICAgc2NoZW1hID0gY29uZGl0aW9ucy5yZWR1Y2UoKHByZXZTY2hlbWEsIGNvbmRpdGlvbikgPT4gY29uZGl0aW9uLnJlc29sdmUocHJldlNjaGVtYSwgb3B0aW9ucyksIHNjaGVtYSk7XHJcbiAgICAgIHNjaGVtYSA9IHNjaGVtYS5yZXNvbHZlKG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNjaGVtYTtcclxuICB9XHJcbiAgcmVzb2x2ZU9wdGlvbnMob3B0aW9ucykge1xyXG4gICAgdmFyIF9vcHRpb25zJHN0cmljdCwgX29wdGlvbnMkYWJvcnRFYXJseSwgX29wdGlvbnMkcmVjdXJzaXZlLCBfb3B0aW9ucyRkaXNhYmxlU3RhY2s7XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xyXG4gICAgICBmcm9tOiBvcHRpb25zLmZyb20gfHwgW10sXHJcbiAgICAgIHN0cmljdDogKF9vcHRpb25zJHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0KSAhPSBudWxsID8gX29wdGlvbnMkc3RyaWN0IDogdGhpcy5zcGVjLnN0cmljdCxcclxuICAgICAgYWJvcnRFYXJseTogKF9vcHRpb25zJGFib3J0RWFybHkgPSBvcHRpb25zLmFib3J0RWFybHkpICE9IG51bGwgPyBfb3B0aW9ucyRhYm9ydEVhcmx5IDogdGhpcy5zcGVjLmFib3J0RWFybHksXHJcbiAgICAgIHJlY3Vyc2l2ZTogKF9vcHRpb25zJHJlY3Vyc2l2ZSA9IG9wdGlvbnMucmVjdXJzaXZlKSAhPSBudWxsID8gX29wdGlvbnMkcmVjdXJzaXZlIDogdGhpcy5zcGVjLnJlY3Vyc2l2ZSxcclxuICAgICAgZGlzYWJsZVN0YWNrVHJhY2U6IChfb3B0aW9ucyRkaXNhYmxlU3RhY2sgPSBvcHRpb25zLmRpc2FibGVTdGFja1RyYWNlKSAhPSBudWxsID8gX29wdGlvbnMkZGlzYWJsZVN0YWNrIDogdGhpcy5zcGVjLmRpc2FibGVTdGFja1RyYWNlXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJ1biB0aGUgY29uZmlndXJlZCB0cmFuc2Zvcm0gcGlwZWxpbmUgb3ZlciBhbiBpbnB1dCB2YWx1ZS5cclxuICAgKi9cclxuXHJcbiAgY2FzdCh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBsZXQgcmVzb2x2ZWRTY2hlbWEgPSB0aGlzLnJlc29sdmUoT2JqZWN0LmFzc2lnbih7XHJcbiAgICAgIHZhbHVlXHJcbiAgICB9LCBvcHRpb25zKSk7XHJcbiAgICBsZXQgYWxsb3dPcHRpb25hbGl0eSA9IG9wdGlvbnMuYXNzZXJ0ID09PSAnaWdub3JlLW9wdGlvbmFsaXR5JztcclxuICAgIGxldCByZXN1bHQgPSByZXNvbHZlZFNjaGVtYS5fY2FzdCh2YWx1ZSwgb3B0aW9ucyk7XHJcbiAgICBpZiAob3B0aW9ucy5hc3NlcnQgIT09IGZhbHNlICYmICFyZXNvbHZlZFNjaGVtYS5pc1R5cGUocmVzdWx0KSkge1xyXG4gICAgICBpZiAoYWxsb3dPcHRpb25hbGl0eSAmJiBpc0Fic2VudChyZXN1bHQpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG4gICAgICBsZXQgZm9ybWF0dGVkVmFsdWUgPSBwcmludFZhbHVlKHZhbHVlKTtcclxuICAgICAgbGV0IGZvcm1hdHRlZFJlc3VsdCA9IHByaW50VmFsdWUocmVzdWx0KTtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIHZhbHVlIG9mICR7b3B0aW9ucy5wYXRoIHx8ICdmaWVsZCd9IGNvdWxkIG5vdCBiZSBjYXN0IHRvIGEgdmFsdWUgYCArIGB0aGF0IHNhdGlzZmllcyB0aGUgc2NoZW1hIHR5cGU6IFwiJHtyZXNvbHZlZFNjaGVtYS50eXBlfVwiLiBcXG5cXG5gICsgYGF0dGVtcHRlZCB2YWx1ZTogJHtmb3JtYXR0ZWRWYWx1ZX0gXFxuYCArIChmb3JtYXR0ZWRSZXN1bHQgIT09IGZvcm1hdHRlZFZhbHVlID8gYHJlc3VsdCBvZiBjYXN0OiAke2Zvcm1hdHRlZFJlc3VsdH1gIDogJycpKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG4gIF9jYXN0KHJhd1ZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICBsZXQgdmFsdWUgPSByYXdWYWx1ZSA9PT0gdW5kZWZpbmVkID8gcmF3VmFsdWUgOiB0aGlzLnRyYW5zZm9ybXMucmVkdWNlKChwcmV2VmFsdWUsIGZuKSA9PiBmbi5jYWxsKHRoaXMsIHByZXZWYWx1ZSwgcmF3VmFsdWUsIHRoaXMpLCByYXdWYWx1ZSk7XHJcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB2YWx1ZSA9IHRoaXMuZ2V0RGVmYXVsdChvcHRpb25zKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcbiAgX3ZhbGlkYXRlKF92YWx1ZSwgb3B0aW9ucyA9IHt9LCBwYW5pYywgbmV4dCkge1xyXG4gICAgbGV0IHtcclxuICAgICAgcGF0aCxcclxuICAgICAgb3JpZ2luYWxWYWx1ZSA9IF92YWx1ZSxcclxuICAgICAgc3RyaWN0ID0gdGhpcy5zcGVjLnN0cmljdFxyXG4gICAgfSA9IG9wdGlvbnM7XHJcbiAgICBsZXQgdmFsdWUgPSBfdmFsdWU7XHJcbiAgICBpZiAoIXN0cmljdCkge1xyXG4gICAgICB2YWx1ZSA9IHRoaXMuX2Nhc3QodmFsdWUsIE9iamVjdC5hc3NpZ24oe1xyXG4gICAgICAgIGFzc2VydDogZmFsc2VcclxuICAgICAgfSwgb3B0aW9ucykpO1xyXG4gICAgfVxyXG4gICAgbGV0IGluaXRpYWxUZXN0cyA9IFtdO1xyXG4gICAgZm9yIChsZXQgdGVzdCBvZiBPYmplY3QudmFsdWVzKHRoaXMuaW50ZXJuYWxUZXN0cykpIHtcclxuICAgICAgaWYgKHRlc3QpIGluaXRpYWxUZXN0cy5wdXNoKHRlc3QpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5ydW5UZXN0cyh7XHJcbiAgICAgIHBhdGgsXHJcbiAgICAgIHZhbHVlLFxyXG4gICAgICBvcmlnaW5hbFZhbHVlLFxyXG4gICAgICBvcHRpb25zLFxyXG4gICAgICB0ZXN0czogaW5pdGlhbFRlc3RzXHJcbiAgICB9LCBwYW5pYywgaW5pdGlhbEVycm9ycyA9PiB7XHJcbiAgICAgIC8vIGV2ZW4gaWYgd2UgYXJlbid0IGVuZGluZyBlYXJseSB3ZSBjYW4ndCBwcm9jZWVkIGZ1cnRoZXIgaWYgdGhlIHR5cGVzIGFyZW4ndCBjb3JyZWN0XHJcbiAgICAgIGlmIChpbml0aWFsRXJyb3JzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBuZXh0KGluaXRpYWxFcnJvcnMsIHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnJ1blRlc3RzKHtcclxuICAgICAgICBwYXRoLFxyXG4gICAgICAgIHZhbHVlLFxyXG4gICAgICAgIG9yaWdpbmFsVmFsdWUsXHJcbiAgICAgICAgb3B0aW9ucyxcclxuICAgICAgICB0ZXN0czogdGhpcy50ZXN0c1xyXG4gICAgICB9LCBwYW5pYywgbmV4dCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEV4ZWN1dGVzIGEgc2V0IG9mIHZhbGlkYXRpb25zLCBlaXRoZXIgc2NoZW1hLCBwcm9kdWNlZCBUZXN0cyBvciBhIG5lc3RlZFxyXG4gICAqIHNjaGVtYSB2YWxpZGF0ZSByZXN1bHQuXHJcbiAgICovXHJcbiAgcnVuVGVzdHMocnVuT3B0aW9ucywgcGFuaWMsIG5leHQpIHtcclxuICAgIGxldCBmaXJlZCA9IGZhbHNlO1xyXG4gICAgbGV0IHtcclxuICAgICAgdGVzdHMsXHJcbiAgICAgIHZhbHVlLFxyXG4gICAgICBvcmlnaW5hbFZhbHVlLFxyXG4gICAgICBwYXRoLFxyXG4gICAgICBvcHRpb25zXHJcbiAgICB9ID0gcnVuT3B0aW9ucztcclxuICAgIGxldCBwYW5pY09uY2UgPSBhcmcgPT4ge1xyXG4gICAgICBpZiAoZmlyZWQpIHJldHVybjtcclxuICAgICAgZmlyZWQgPSB0cnVlO1xyXG4gICAgICBwYW5pYyhhcmcsIHZhbHVlKTtcclxuICAgIH07XHJcbiAgICBsZXQgbmV4dE9uY2UgPSBhcmcgPT4ge1xyXG4gICAgICBpZiAoZmlyZWQpIHJldHVybjtcclxuICAgICAgZmlyZWQgPSB0cnVlO1xyXG4gICAgICBuZXh0KGFyZywgdmFsdWUpO1xyXG4gICAgfTtcclxuICAgIGxldCBjb3VudCA9IHRlc3RzLmxlbmd0aDtcclxuICAgIGxldCBuZXN0ZWRFcnJvcnMgPSBbXTtcclxuICAgIGlmICghY291bnQpIHJldHVybiBuZXh0T25jZShbXSk7XHJcbiAgICBsZXQgYXJncyA9IHtcclxuICAgICAgdmFsdWUsXHJcbiAgICAgIG9yaWdpbmFsVmFsdWUsXHJcbiAgICAgIHBhdGgsXHJcbiAgICAgIG9wdGlvbnMsXHJcbiAgICAgIHNjaGVtYTogdGhpc1xyXG4gICAgfTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVzdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgdGVzdCA9IHRlc3RzW2ldO1xyXG4gICAgICB0ZXN0KGFyZ3MsIHBhbmljT25jZSwgZnVuY3Rpb24gZmluaXNoVGVzdFJ1bihlcnIpIHtcclxuICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICBBcnJheS5pc0FycmF5KGVycikgPyBuZXN0ZWRFcnJvcnMucHVzaCguLi5lcnIpIDogbmVzdGVkRXJyb3JzLnB1c2goZXJyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKC0tY291bnQgPD0gMCkge1xyXG4gICAgICAgICAgbmV4dE9uY2UobmVzdGVkRXJyb3JzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuICBhc05lc3RlZFRlc3Qoe1xyXG4gICAga2V5LFxyXG4gICAgaW5kZXgsXHJcbiAgICBwYXJlbnQsXHJcbiAgICBwYXJlbnRQYXRoLFxyXG4gICAgb3JpZ2luYWxQYXJlbnQsXHJcbiAgICBvcHRpb25zXHJcbiAgfSkge1xyXG4gICAgY29uc3QgayA9IGtleSAhPSBudWxsID8ga2V5IDogaW5kZXg7XHJcbiAgICBpZiAoayA9PSBudWxsKSB7XHJcbiAgICAgIHRocm93IFR5cGVFcnJvcignTXVzdCBpbmNsdWRlIGBrZXlgIG9yIGBpbmRleGAgZm9yIG5lc3RlZCB2YWxpZGF0aW9ucycpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaXNJbmRleCA9IHR5cGVvZiBrID09PSAnbnVtYmVyJztcclxuICAgIGxldCB2YWx1ZSA9IHBhcmVudFtrXTtcclxuICAgIGNvbnN0IHRlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xyXG4gICAgICAvLyBOZXN0ZWQgdmFsaWRhdGlvbnMgZmllbGRzIGFyZSBhbHdheXMgc3RyaWN0OlxyXG4gICAgICAvLyAgICAxLiBwYXJlbnQgaXNuJ3Qgc3RyaWN0IHNvIHRoZSBjYXN0aW5nIHdpbGwgYWxzbyBoYXZlIGNhc3QgaW5uZXIgdmFsdWVzXHJcbiAgICAgIC8vICAgIDIuIHBhcmVudCBpcyBzdHJpY3QgaW4gd2hpY2ggY2FzZSB0aGUgbmVzdGVkIHZhbHVlcyB3ZXJlbid0IGNhc3QgZWl0aGVyXHJcbiAgICAgIHN0cmljdDogdHJ1ZSxcclxuICAgICAgcGFyZW50LFxyXG4gICAgICB2YWx1ZSxcclxuICAgICAgb3JpZ2luYWxWYWx1ZTogb3JpZ2luYWxQYXJlbnRba10sXHJcbiAgICAgIC8vIEZJWE1FOiB0ZXN0cyBkZXBlbmQgb24gYGluZGV4YCBiZWluZyBwYXNzZWQgYXJvdW5kIGRlZXBseSxcclxuICAgICAgLy8gICB3ZSBzaG91bGQgbm90IGxldCB0aGUgb3B0aW9ucy5rZXkvaW5kZXggYmxlZWQgdGhyb3VnaFxyXG4gICAgICBrZXk6IHVuZGVmaW5lZCxcclxuICAgICAgLy8gaW5kZXg6IHVuZGVmaW5lZCxcclxuICAgICAgW2lzSW5kZXggPyAnaW5kZXgnIDogJ2tleSddOiBrLFxyXG4gICAgICBwYXRoOiBpc0luZGV4IHx8IGsuaW5jbHVkZXMoJy4nKSA/IGAke3BhcmVudFBhdGggfHwgJyd9WyR7aXNJbmRleCA/IGsgOiBgXCIke2t9XCJgfV1gIDogKHBhcmVudFBhdGggPyBgJHtwYXJlbnRQYXRofS5gIDogJycpICsga2V5XHJcbiAgICB9KTtcclxuICAgIHJldHVybiAoXywgcGFuaWMsIG5leHQpID0+IHRoaXMucmVzb2x2ZSh0ZXN0T3B0aW9ucykuX3ZhbGlkYXRlKHZhbHVlLCB0ZXN0T3B0aW9ucywgcGFuaWMsIG5leHQpO1xyXG4gIH1cclxuICB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIF9vcHRpb25zJGRpc2FibGVTdGFjazI7XHJcbiAgICBsZXQgc2NoZW1hID0gdGhpcy5yZXNvbHZlKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcclxuICAgICAgdmFsdWVcclxuICAgIH0pKTtcclxuICAgIGxldCBkaXNhYmxlU3RhY2tUcmFjZSA9IChfb3B0aW9ucyRkaXNhYmxlU3RhY2syID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kaXNhYmxlU3RhY2tUcmFjZSkgIT0gbnVsbCA/IF9vcHRpb25zJGRpc2FibGVTdGFjazIgOiBzY2hlbWEuc3BlYy5kaXNhYmxlU3RhY2tUcmFjZTtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBzY2hlbWEuX3ZhbGlkYXRlKHZhbHVlLCBvcHRpb25zLCAoZXJyb3IsIHBhcnNlZCkgPT4ge1xyXG4gICAgICBpZiAoVmFsaWRhdGlvbkVycm9yLmlzRXJyb3IoZXJyb3IpKSBlcnJvci52YWx1ZSA9IHBhcnNlZDtcclxuICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgIH0sIChlcnJvcnMsIHZhbGlkYXRlZCkgPT4ge1xyXG4gICAgICBpZiAoZXJyb3JzLmxlbmd0aCkgcmVqZWN0KG5ldyBWYWxpZGF0aW9uRXJyb3IoZXJyb3JzLCB2YWxpZGF0ZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkaXNhYmxlU3RhY2tUcmFjZSkpO2Vsc2UgcmVzb2x2ZSh2YWxpZGF0ZWQpO1xyXG4gICAgfSkpO1xyXG4gIH1cclxuICB2YWxpZGF0ZVN5bmModmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIHZhciBfb3B0aW9ucyRkaXNhYmxlU3RhY2szO1xyXG4gICAgbGV0IHNjaGVtYSA9IHRoaXMucmVzb2x2ZShPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XHJcbiAgICAgIHZhbHVlXHJcbiAgICB9KSk7XHJcbiAgICBsZXQgcmVzdWx0O1xyXG4gICAgbGV0IGRpc2FibGVTdGFja1RyYWNlID0gKF9vcHRpb25zJGRpc2FibGVTdGFjazMgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmRpc2FibGVTdGFja1RyYWNlKSAhPSBudWxsID8gX29wdGlvbnMkZGlzYWJsZVN0YWNrMyA6IHNjaGVtYS5zcGVjLmRpc2FibGVTdGFja1RyYWNlO1xyXG4gICAgc2NoZW1hLl92YWxpZGF0ZSh2YWx1ZSwgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xyXG4gICAgICBzeW5jOiB0cnVlXHJcbiAgICB9KSwgKGVycm9yLCBwYXJzZWQpID0+IHtcclxuICAgICAgaWYgKFZhbGlkYXRpb25FcnJvci5pc0Vycm9yKGVycm9yKSkgZXJyb3IudmFsdWUgPSBwYXJzZWQ7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfSwgKGVycm9ycywgdmFsaWRhdGVkKSA9PiB7XHJcbiAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGVycm9ycywgdmFsdWUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkaXNhYmxlU3RhY2tUcmFjZSk7XHJcbiAgICAgIHJlc3VsdCA9IHZhbGlkYXRlZDtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcbiAgaXNWYWxpZCh2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdGUodmFsdWUsIG9wdGlvbnMpLnRoZW4oKCkgPT4gdHJ1ZSwgZXJyID0+IHtcclxuICAgICAgaWYgKFZhbGlkYXRpb25FcnJvci5pc0Vycm9yKGVycikpIHJldHVybiBmYWxzZTtcclxuICAgICAgdGhyb3cgZXJyO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGlzVmFsaWRTeW5jKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICB0aGlzLnZhbGlkYXRlU3luYyh2YWx1ZSwgb3B0aW9ucyk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGlmIChWYWxpZGF0aW9uRXJyb3IuaXNFcnJvcihlcnIpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIHRocm93IGVycjtcclxuICAgIH1cclxuICB9XHJcbiAgX2dldERlZmF1bHQob3B0aW9ucykge1xyXG4gICAgbGV0IGRlZmF1bHRWYWx1ZSA9IHRoaXMuc3BlYy5kZWZhdWx0O1xyXG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IGRlZmF1bHRWYWx1ZS5jYWxsKHRoaXMsIG9wdGlvbnMpIDogY2xvbmUoZGVmYXVsdFZhbHVlKTtcclxuICB9XHJcbiAgZ2V0RGVmYXVsdChvcHRpb25zXHJcbiAgLy8gSWYgc2NoZW1hIGlzIGRlZmF1bHRlZCB3ZSBrbm93IGl0J3MgYXQgbGVhc3Qgbm90IHVuZGVmaW5lZFxyXG4gICkge1xyXG4gICAgbGV0IHNjaGVtYSA9IHRoaXMucmVzb2x2ZShvcHRpb25zIHx8IHt9KTtcclxuICAgIHJldHVybiBzY2hlbWEuX2dldERlZmF1bHQob3B0aW9ucyk7XHJcbiAgfVxyXG4gIGRlZmF1bHQoZGVmKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fZ2V0RGVmYXVsdCgpO1xyXG4gICAgfVxyXG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKHtcclxuICAgICAgZGVmYXVsdDogZGVmXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBuZXh0O1xyXG4gIH1cclxuICBzdHJpY3QoaXNTdHJpY3QgPSB0cnVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jbG9uZSh7XHJcbiAgICAgIHN0cmljdDogaXNTdHJpY3RcclxuICAgIH0pO1xyXG4gIH1cclxuICBudWxsYWJpbGl0eShudWxsYWJsZSwgbWVzc2FnZSkge1xyXG4gICAgY29uc3QgbmV4dCA9IHRoaXMuY2xvbmUoe1xyXG4gICAgICBudWxsYWJsZVxyXG4gICAgfSk7XHJcbiAgICBuZXh0LmludGVybmFsVGVzdHMubnVsbGFibGUgPSBjcmVhdGVWYWxpZGF0aW9uKHtcclxuICAgICAgbWVzc2FnZSxcclxuICAgICAgbmFtZTogJ251bGxhYmxlJyxcclxuICAgICAgdGVzdCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IHRoaXMuc2NoZW1hLnNwZWMubnVsbGFibGUgOiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBuZXh0O1xyXG4gIH1cclxuICBvcHRpb25hbGl0eShvcHRpb25hbCwgbWVzc2FnZSkge1xyXG4gICAgY29uc3QgbmV4dCA9IHRoaXMuY2xvbmUoe1xyXG4gICAgICBvcHRpb25hbFxyXG4gICAgfSk7XHJcbiAgICBuZXh0LmludGVybmFsVGVzdHMub3B0aW9uYWxpdHkgPSBjcmVhdGVWYWxpZGF0aW9uKHtcclxuICAgICAgbWVzc2FnZSxcclxuICAgICAgbmFtZTogJ29wdGlvbmFsaXR5JyxcclxuICAgICAgdGVzdCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdGhpcy5zY2hlbWEuc3BlYy5vcHRpb25hbCA6IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG5leHQ7XHJcbiAgfVxyXG4gIG9wdGlvbmFsKCkge1xyXG4gICAgcmV0dXJuIHRoaXMub3B0aW9uYWxpdHkodHJ1ZSk7XHJcbiAgfVxyXG4gIGRlZmluZWQobWVzc2FnZSA9IG1peGVkLmRlZmluZWQpIHtcclxuICAgIHJldHVybiB0aGlzLm9wdGlvbmFsaXR5KGZhbHNlLCBtZXNzYWdlKTtcclxuICB9XHJcbiAgbnVsbGFibGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5udWxsYWJpbGl0eSh0cnVlKTtcclxuICB9XHJcbiAgbm9uTnVsbGFibGUobWVzc2FnZSA9IG1peGVkLm5vdE51bGwpIHtcclxuICAgIHJldHVybiB0aGlzLm51bGxhYmlsaXR5KGZhbHNlLCBtZXNzYWdlKTtcclxuICB9XHJcbiAgcmVxdWlyZWQobWVzc2FnZSA9IG1peGVkLnJlcXVpcmVkKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLndpdGhNdXRhdGlvbihuZXh0ID0+IG5leHQubm9uTnVsbGFibGUobWVzc2FnZSkuZGVmaW5lZChtZXNzYWdlKSk7XHJcbiAgfVxyXG4gIG5vdFJlcXVpcmVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS53aXRoTXV0YXRpb24obmV4dCA9PiBuZXh0Lm51bGxhYmxlKCkub3B0aW9uYWwoKSk7XHJcbiAgfVxyXG4gIHRyYW5zZm9ybShmbikge1xyXG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKCk7XHJcbiAgICBuZXh0LnRyYW5zZm9ybXMucHVzaChmbik7XHJcbiAgICByZXR1cm4gbmV4dDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgYSB0ZXN0IGZ1bmN0aW9uIHRvIHRoZSBzY2hlbWEncyBxdWV1ZSBvZiB0ZXN0cy5cclxuICAgKiB0ZXN0cyBjYW4gYmUgZXhjbHVzaXZlIG9yIG5vbi1leGNsdXNpdmUuXHJcbiAgICpcclxuICAgKiAtIGV4Y2x1c2l2ZSB0ZXN0cywgd2lsbCByZXBsYWNlIGFueSBleGlzdGluZyB0ZXN0cyBvZiB0aGUgc2FtZSBuYW1lLlxyXG4gICAqIC0gbm9uLWV4Y2x1c2l2ZTogY2FuIGJlIHN0YWNrZWRcclxuICAgKlxyXG4gICAqIElmIGEgbm9uLWV4Y2x1c2l2ZSB0ZXN0IGlzIGFkZGVkIHRvIGEgc2NoZW1hIHdpdGggYW4gZXhjbHVzaXZlIHRlc3Qgb2YgdGhlIHNhbWUgbmFtZVxyXG4gICAqIHRoZSBleGNsdXNpdmUgdGVzdCBpcyByZW1vdmVkIGFuZCBmdXJ0aGVyIHRlc3RzIG9mIHRoZSBzYW1lIG5hbWUgd2lsbCBiZSBzdGFja2VkLlxyXG4gICAqXHJcbiAgICogSWYgYW4gZXhjbHVzaXZlIHRlc3QgaXMgYWRkZWQgdG8gYSBzY2hlbWEgd2l0aCBub24tZXhjbHVzaXZlIHRlc3RzIG9mIHRoZSBzYW1lIG5hbWVcclxuICAgKiB0aGUgcHJldmlvdXMgdGVzdHMgYXJlIHJlbW92ZWQgYW5kIGZ1cnRoZXIgdGVzdHMgb2YgdGhlIHNhbWUgbmFtZSB3aWxsIHJlcGxhY2UgZWFjaCBvdGhlci5cclxuICAgKi9cclxuXHJcbiAgdGVzdCguLi5hcmdzKSB7XHJcbiAgICBsZXQgb3B0cztcclxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBvcHRzID0ge1xyXG4gICAgICAgICAgdGVzdDogYXJnc1swXVxyXG4gICAgICAgIH07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgb3B0cyA9IGFyZ3NbMF07XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcclxuICAgICAgb3B0cyA9IHtcclxuICAgICAgICBuYW1lOiBhcmdzWzBdLFxyXG4gICAgICAgIHRlc3Q6IGFyZ3NbMV1cclxuICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG9wdHMgPSB7XHJcbiAgICAgICAgbmFtZTogYXJnc1swXSxcclxuICAgICAgICBtZXNzYWdlOiBhcmdzWzFdLFxyXG4gICAgICAgIHRlc3Q6IGFyZ3NbMl1cclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmIChvcHRzLm1lc3NhZ2UgPT09IHVuZGVmaW5lZCkgb3B0cy5tZXNzYWdlID0gbWl4ZWQuZGVmYXVsdDtcclxuICAgIGlmICh0eXBlb2Ygb3B0cy50ZXN0ICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdgdGVzdGAgaXMgYSByZXF1aXJlZCBwYXJhbWV0ZXJzJyk7XHJcbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcclxuICAgIGxldCB2YWxpZGF0ZSA9IGNyZWF0ZVZhbGlkYXRpb24ob3B0cyk7XHJcbiAgICBsZXQgaXNFeGNsdXNpdmUgPSBvcHRzLmV4Y2x1c2l2ZSB8fCBvcHRzLm5hbWUgJiYgbmV4dC5leGNsdXNpdmVUZXN0c1tvcHRzLm5hbWVdID09PSB0cnVlO1xyXG4gICAgaWYgKG9wdHMuZXhjbHVzaXZlKSB7XHJcbiAgICAgIGlmICghb3B0cy5uYW1lKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeGNsdXNpdmUgdGVzdHMgbXVzdCBwcm92aWRlIGEgdW5pcXVlIGBuYW1lYCBpZGVudGlmeWluZyB0aGUgdGVzdCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdHMubmFtZSkgbmV4dC5leGNsdXNpdmVUZXN0c1tvcHRzLm5hbWVdID0gISFvcHRzLmV4Y2x1c2l2ZTtcclxuICAgIG5leHQudGVzdHMgPSBuZXh0LnRlc3RzLmZpbHRlcihmbiA9PiB7XHJcbiAgICAgIGlmIChmbi5PUFRJT05TLm5hbWUgPT09IG9wdHMubmFtZSkge1xyXG4gICAgICAgIGlmIChpc0V4Y2x1c2l2ZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmIChmbi5PUFRJT05TLnRlc3QgPT09IHZhbGlkYXRlLk9QVElPTlMudGVzdCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSk7XHJcbiAgICBuZXh0LnRlc3RzLnB1c2godmFsaWRhdGUpO1xyXG4gICAgcmV0dXJuIG5leHQ7XHJcbiAgfVxyXG4gIHdoZW4oa2V5cywgb3B0aW9ucykge1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGtleXMpICYmIHR5cGVvZiBrZXlzICE9PSAnc3RyaW5nJykge1xyXG4gICAgICBvcHRpb25zID0ga2V5cztcclxuICAgICAga2V5cyA9ICcuJztcclxuICAgIH1cclxuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xyXG4gICAgbGV0IGRlcHMgPSB0b0FycmF5KGtleXMpLm1hcChrZXkgPT4gbmV3IFJlZmVyZW5jZShrZXkpKTtcclxuICAgIGRlcHMuZm9yRWFjaChkZXAgPT4ge1xyXG4gICAgICAvLyBAdHMtaWdub3JlIHJlYWRvbmx5IGFycmF5XHJcbiAgICAgIGlmIChkZXAuaXNTaWJsaW5nKSBuZXh0LmRlcHMucHVzaChkZXAua2V5KTtcclxuICAgIH0pO1xyXG4gICAgbmV4dC5jb25kaXRpb25zLnB1c2godHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgPyBuZXcgQ29uZGl0aW9uKGRlcHMsIG9wdGlvbnMpIDogQ29uZGl0aW9uLmZyb21PcHRpb25zKGRlcHMsIG9wdGlvbnMpKTtcclxuICAgIHJldHVybiBuZXh0O1xyXG4gIH1cclxuICB0eXBlRXJyb3IobWVzc2FnZSkge1xyXG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKCk7XHJcbiAgICBuZXh0LmludGVybmFsVGVzdHMudHlwZUVycm9yID0gY3JlYXRlVmFsaWRhdGlvbih7XHJcbiAgICAgIG1lc3NhZ2UsXHJcbiAgICAgIG5hbWU6ICd0eXBlRXJyb3InLFxyXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxyXG4gICAgICB0ZXN0KHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnNjaGVtYS5fdHlwZUNoZWNrKHZhbHVlKSkgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3Ioe1xyXG4gICAgICAgICAgcGFyYW1zOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuc2NoZW1hLnR5cGVcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbmV4dDtcclxuICB9XHJcbiAgb25lT2YoZW51bXMsIG1lc3NhZ2UgPSBtaXhlZC5vbmVPZikge1xyXG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKCk7XHJcbiAgICBlbnVtcy5mb3JFYWNoKHZhbCA9PiB7XHJcbiAgICAgIG5leHQuX3doaXRlbGlzdC5hZGQodmFsKTtcclxuICAgICAgbmV4dC5fYmxhY2tsaXN0LmRlbGV0ZSh2YWwpO1xyXG4gICAgfSk7XHJcbiAgICBuZXh0LmludGVybmFsVGVzdHMud2hpdGVMaXN0ID0gY3JlYXRlVmFsaWRhdGlvbih7XHJcbiAgICAgIG1lc3NhZ2UsXHJcbiAgICAgIG5hbWU6ICdvbmVPZicsXHJcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXHJcbiAgICAgIHRlc3QodmFsdWUpIHtcclxuICAgICAgICBsZXQgdmFsaWRzID0gdGhpcy5zY2hlbWEuX3doaXRlbGlzdDtcclxuICAgICAgICBsZXQgcmVzb2x2ZWQgPSB2YWxpZHMucmVzb2x2ZUFsbCh0aGlzLnJlc29sdmUpO1xyXG4gICAgICAgIHJldHVybiByZXNvbHZlZC5pbmNsdWRlcyh2YWx1ZSkgPyB0cnVlIDogdGhpcy5jcmVhdGVFcnJvcih7XHJcbiAgICAgICAgICBwYXJhbXM6IHtcclxuICAgICAgICAgICAgdmFsdWVzOiBBcnJheS5mcm9tKHZhbGlkcykuam9pbignLCAnKSxcclxuICAgICAgICAgICAgcmVzb2x2ZWRcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbmV4dDtcclxuICB9XHJcbiAgbm90T25lT2YoZW51bXMsIG1lc3NhZ2UgPSBtaXhlZC5ub3RPbmVPZikge1xyXG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKCk7XHJcbiAgICBlbnVtcy5mb3JFYWNoKHZhbCA9PiB7XHJcbiAgICAgIG5leHQuX2JsYWNrbGlzdC5hZGQodmFsKTtcclxuICAgICAgbmV4dC5fd2hpdGVsaXN0LmRlbGV0ZSh2YWwpO1xyXG4gICAgfSk7XHJcbiAgICBuZXh0LmludGVybmFsVGVzdHMuYmxhY2tsaXN0ID0gY3JlYXRlVmFsaWRhdGlvbih7XHJcbiAgICAgIG1lc3NhZ2UsXHJcbiAgICAgIG5hbWU6ICdub3RPbmVPZicsXHJcbiAgICAgIHRlc3QodmFsdWUpIHtcclxuICAgICAgICBsZXQgaW52YWxpZHMgPSB0aGlzLnNjaGVtYS5fYmxhY2tsaXN0O1xyXG4gICAgICAgIGxldCByZXNvbHZlZCA9IGludmFsaWRzLnJlc29sdmVBbGwodGhpcy5yZXNvbHZlKTtcclxuICAgICAgICBpZiAocmVzb2x2ZWQuaW5jbHVkZXModmFsdWUpKSByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcih7XHJcbiAgICAgICAgICBwYXJhbXM6IHtcclxuICAgICAgICAgICAgdmFsdWVzOiBBcnJheS5mcm9tKGludmFsaWRzKS5qb2luKCcsICcpLFxyXG4gICAgICAgICAgICByZXNvbHZlZFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBuZXh0O1xyXG4gIH1cclxuICBzdHJpcChzdHJpcCA9IHRydWUpIHtcclxuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xyXG4gICAgbmV4dC5zcGVjLnN0cmlwID0gc3RyaXA7XHJcbiAgICByZXR1cm4gbmV4dDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiBhIHNlcmlhbGl6ZWQgZGVzY3JpcHRpb24gb2YgdGhlIHNjaGVtYSBpbmNsdWRpbmcgdmFsaWRhdGlvbnMsIGZsYWdzLCB0eXBlcyBldGMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gb3B0aW9ucyBQcm92aWRlIGFueSBuZWVkZWQgY29udGV4dCBmb3IgcmVzb2x2aW5nIHJ1bnRpbWUgc2NoZW1hIGFsdGVyYXRpb25zIChsYXp5LCB3aGVuIGNvbmRpdGlvbnMsIGV0YykuXHJcbiAgICovXHJcbiAgZGVzY3JpYmUob3B0aW9ucykge1xyXG4gICAgY29uc3QgbmV4dCA9IChvcHRpb25zID8gdGhpcy5yZXNvbHZlKG9wdGlvbnMpIDogdGhpcykuY2xvbmUoKTtcclxuICAgIGNvbnN0IHtcclxuICAgICAgbGFiZWwsXHJcbiAgICAgIG1ldGEsXHJcbiAgICAgIG9wdGlvbmFsLFxyXG4gICAgICBudWxsYWJsZVxyXG4gICAgfSA9IG5leHQuc3BlYztcclxuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0ge1xyXG4gICAgICBtZXRhLFxyXG4gICAgICBsYWJlbCxcclxuICAgICAgb3B0aW9uYWwsXHJcbiAgICAgIG51bGxhYmxlLFxyXG4gICAgICBkZWZhdWx0OiBuZXh0LmdldERlZmF1bHQob3B0aW9ucyksXHJcbiAgICAgIHR5cGU6IG5leHQudHlwZSxcclxuICAgICAgb25lT2Y6IG5leHQuX3doaXRlbGlzdC5kZXNjcmliZSgpLFxyXG4gICAgICBub3RPbmVPZjogbmV4dC5fYmxhY2tsaXN0LmRlc2NyaWJlKCksXHJcbiAgICAgIHRlc3RzOiBuZXh0LnRlc3RzLm1hcChmbiA9PiAoe1xyXG4gICAgICAgIG5hbWU6IGZuLk9QVElPTlMubmFtZSxcclxuICAgICAgICBwYXJhbXM6IGZuLk9QVElPTlMucGFyYW1zXHJcbiAgICAgIH0pKS5maWx0ZXIoKG4sIGlkeCwgbGlzdCkgPT4gbGlzdC5maW5kSW5kZXgoYyA9PiBjLm5hbWUgPT09IG4ubmFtZSkgPT09IGlkeClcclxuICAgIH07XHJcbiAgICByZXR1cm4gZGVzY3JpcHRpb247XHJcbiAgfVxyXG59XHJcbi8vIEB0cy1leHBlY3QtZXJyb3JcclxuU2NoZW1hLnByb3RvdHlwZS5fX2lzWXVwU2NoZW1hX18gPSB0cnVlO1xyXG5mb3IgKGNvbnN0IG1ldGhvZCBvZiBbJ3ZhbGlkYXRlJywgJ3ZhbGlkYXRlU3luYyddKSBTY2hlbWEucHJvdG90eXBlW2Ake21ldGhvZH1BdGBdID0gZnVuY3Rpb24gKHBhdGgsIHZhbHVlLCBvcHRpb25zID0ge30pIHtcclxuICBjb25zdCB7XHJcbiAgICBwYXJlbnQsXHJcbiAgICBwYXJlbnRQYXRoLFxyXG4gICAgc2NoZW1hXHJcbiAgfSA9IGdldEluKHRoaXMsIHBhdGgsIHZhbHVlLCBvcHRpb25zLmNvbnRleHQpO1xyXG4gIHJldHVybiBzY2hlbWFbbWV0aG9kXShwYXJlbnQgJiYgcGFyZW50W3BhcmVudFBhdGhdLCBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XHJcbiAgICBwYXJlbnQsXHJcbiAgICBwYXRoXHJcbiAgfSkpO1xyXG59O1xyXG5mb3IgKGNvbnN0IGFsaWFzIG9mIFsnZXF1YWxzJywgJ2lzJ10pIFNjaGVtYS5wcm90b3R5cGVbYWxpYXNdID0gU2NoZW1hLnByb3RvdHlwZS5vbmVPZjtcclxuZm9yIChjb25zdCBhbGlhcyBvZiBbJ25vdCcsICdub3BlJ10pIFNjaGVtYS5wcm90b3R5cGVbYWxpYXNdID0gU2NoZW1hLnByb3RvdHlwZS5ub3RPbmVPZjtcclxuXHJcbmNvbnN0IHJldHVybnNUcnVlID0gKCkgPT4gdHJ1ZTtcclxuZnVuY3Rpb24gY3JlYXRlJDgoc3BlYykge1xyXG4gIHJldHVybiBuZXcgTWl4ZWRTY2hlbWEoc3BlYyk7XHJcbn1cclxuY2xhc3MgTWl4ZWRTY2hlbWEgZXh0ZW5kcyBTY2hlbWEge1xyXG4gIGNvbnN0cnVjdG9yKHNwZWMpIHtcclxuICAgIHN1cGVyKHR5cGVvZiBzcGVjID09PSAnZnVuY3Rpb24nID8ge1xyXG4gICAgICB0eXBlOiAnbWl4ZWQnLFxyXG4gICAgICBjaGVjazogc3BlY1xyXG4gICAgfSA6IE9iamVjdC5hc3NpZ24oe1xyXG4gICAgICB0eXBlOiAnbWl4ZWQnLFxyXG4gICAgICBjaGVjazogcmV0dXJuc1RydWVcclxuICAgIH0sIHNwZWMpKTtcclxuICB9XHJcbn1cclxuY3JlYXRlJDgucHJvdG90eXBlID0gTWl4ZWRTY2hlbWEucHJvdG90eXBlO1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlJDcoKSB7XHJcbiAgcmV0dXJuIG5ldyBCb29sZWFuU2NoZW1hKCk7XHJcbn1cclxuY2xhc3MgQm9vbGVhblNjaGVtYSBleHRlbmRzIFNjaGVtYSB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcih7XHJcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcclxuICAgICAgY2hlY2sodikge1xyXG4gICAgICAgIGlmICh2IGluc3RhbmNlb2YgQm9vbGVhbikgdiA9IHYudmFsdWVPZigpO1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgdiA9PT0gJ2Jvb2xlYW4nO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHRoaXMud2l0aE11dGF0aW9uKCgpID0+IHtcclxuICAgICAgdGhpcy50cmFuc2Zvcm0oKHZhbHVlLCBfcmF3LCBjdHgpID0+IHtcclxuICAgICAgICBpZiAoY3R4LnNwZWMuY29lcmNlICYmICFjdHguaXNUeXBlKHZhbHVlKSkge1xyXG4gICAgICAgICAgaWYgKC9eKHRydWV8MSkkL2kudGVzdChTdHJpbmcodmFsdWUpKSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICBpZiAoL14oZmFsc2V8MCkkL2kudGVzdChTdHJpbmcodmFsdWUpKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGlzVHJ1ZShtZXNzYWdlID0gYm9vbGVhbi5pc1ZhbHVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcclxuICAgICAgbWVzc2FnZSxcclxuICAgICAgbmFtZTogJ2lzLXZhbHVlJyxcclxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxyXG4gICAgICBwYXJhbXM6IHtcclxuICAgICAgICB2YWx1ZTogJ3RydWUnXHJcbiAgICAgIH0sXHJcbiAgICAgIHRlc3QodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gaXNBYnNlbnQodmFsdWUpIHx8IHZhbHVlID09PSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgaXNGYWxzZShtZXNzYWdlID0gYm9vbGVhbi5pc1ZhbHVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcclxuICAgICAgbWVzc2FnZSxcclxuICAgICAgbmFtZTogJ2lzLXZhbHVlJyxcclxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxyXG4gICAgICBwYXJhbXM6IHtcclxuICAgICAgICB2YWx1ZTogJ2ZhbHNlJ1xyXG4gICAgICB9LFxyXG4gICAgICB0ZXN0KHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzQWJzZW50KHZhbHVlKSB8fCB2YWx1ZSA9PT0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICBkZWZhdWx0KGRlZikge1xyXG4gICAgcmV0dXJuIHN1cGVyLmRlZmF1bHQoZGVmKTtcclxuICB9XHJcbiAgZGVmaW5lZChtc2cpIHtcclxuICAgIHJldHVybiBzdXBlci5kZWZpbmVkKG1zZyk7XHJcbiAgfVxyXG4gIG9wdGlvbmFsKCkge1xyXG4gICAgcmV0dXJuIHN1cGVyLm9wdGlvbmFsKCk7XHJcbiAgfVxyXG4gIHJlcXVpcmVkKG1zZykge1xyXG4gICAgcmV0dXJuIHN1cGVyLnJlcXVpcmVkKG1zZyk7XHJcbiAgfVxyXG4gIG5vdFJlcXVpcmVkKCkge1xyXG4gICAgcmV0dXJuIHN1cGVyLm5vdFJlcXVpcmVkKCk7XHJcbiAgfVxyXG4gIG51bGxhYmxlKCkge1xyXG4gICAgcmV0dXJuIHN1cGVyLm51bGxhYmxlKCk7XHJcbiAgfVxyXG4gIG5vbk51bGxhYmxlKG1zZykge1xyXG4gICAgcmV0dXJuIHN1cGVyLm5vbk51bGxhYmxlKG1zZyk7XHJcbiAgfVxyXG4gIHN0cmlwKHYpIHtcclxuICAgIHJldHVybiBzdXBlci5zdHJpcCh2KTtcclxuICB9XHJcbn1cclxuY3JlYXRlJDcucHJvdG90eXBlID0gQm9vbGVhblNjaGVtYS5wcm90b3R5cGU7XHJcblxyXG4vKipcclxuICogVGhpcyBmaWxlIGlzIGEgbW9kaWZpZWQgdmVyc2lvbiBvZiB0aGUgZmlsZSBmcm9tIHRoZSBmb2xsb3dpbmcgcmVwb3NpdG9yeTpcclxuICogRGF0ZS5wYXJzZSB3aXRoIHByb2dyZXNzaXZlIGVuaGFuY2VtZW50IGZvciBJU08gODYwMSA8aHR0cHM6Ly9naXRodWIuY29tL2Nzbm92ZXIvanMtaXNvODYwMT5cclxuICogTk9OLUNPTkZPUk1BTlQgRURJVElPTi5cclxuICogwqkgMjAxMSBDb2xpbiBTbm92ZXIgPGh0dHA6Ly96ZXRhZmxlZXQuY29tPlxyXG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cclxuICovXHJcblxyXG4vLyBwcmV0dGllci1pZ25vcmVcclxuLy8gICAgICAgICAgICAgICAgMSBZWVlZICAgICAgICAgICAgICAgIDIgTU0gICAgICAgIDMgREQgICAgICAgICAgICAgIDQgSEggICAgIDUgbW0gICAgICAgIDYgc3MgICAgICAgICAgIDcgbXNlYyAgICAgICAgIDggWiA5IMKxICAgMTAgdHpISCAgICAxMSB0em1tXHJcbmNvbnN0IGlzb1JlZyA9IC9eKFxcZHs0fXxbKy1dXFxkezZ9KSg/Oi0/KFxcZHsyfSkoPzotPyhcXGR7Mn0pKT8pPyg/OlsgVF0/KFxcZHsyfSk6PyhcXGR7Mn0pKD86Oj8oXFxkezJ9KSg/OlssLl0oXFxkezEsfSkpPyk/KD86KFopfChbKy1dKShcXGR7Mn0pKD86Oj8oXFxkezJ9KSk/KT8pPyQvO1xyXG5mdW5jdGlvbiBwYXJzZUlzb0RhdGUoZGF0ZSkge1xyXG4gIGNvbnN0IHN0cnVjdCA9IHBhcnNlRGF0ZVN0cnVjdChkYXRlKTtcclxuICBpZiAoIXN0cnVjdCkgcmV0dXJuIERhdGUucGFyc2UgPyBEYXRlLnBhcnNlKGRhdGUpIDogTnVtYmVyLk5hTjtcclxuXHJcbiAgLy8gdGltZXN0YW1wcyB3aXRob3V0IHRpbWV6b25lIGlkZW50aWZpZXJzIHNob3VsZCBiZSBjb25zaWRlcmVkIGxvY2FsIHRpbWVcclxuICBpZiAoc3RydWN0LnogPT09IHVuZGVmaW5lZCAmJiBzdHJ1Y3QucGx1c01pbnVzID09PSB1bmRlZmluZWQpIHtcclxuICAgIHJldHVybiBuZXcgRGF0ZShzdHJ1Y3QueWVhciwgc3RydWN0Lm1vbnRoLCBzdHJ1Y3QuZGF5LCBzdHJ1Y3QuaG91ciwgc3RydWN0Lm1pbnV0ZSwgc3RydWN0LnNlY29uZCwgc3RydWN0Lm1pbGxpc2Vjb25kKS52YWx1ZU9mKCk7XHJcbiAgfVxyXG4gIGxldCB0b3RhbE1pbnV0ZXNPZmZzZXQgPSAwO1xyXG4gIGlmIChzdHJ1Y3QueiAhPT0gJ1onICYmIHN0cnVjdC5wbHVzTWludXMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgdG90YWxNaW51dGVzT2Zmc2V0ID0gc3RydWN0LmhvdXJPZmZzZXQgKiA2MCArIHN0cnVjdC5taW51dGVPZmZzZXQ7XHJcbiAgICBpZiAoc3RydWN0LnBsdXNNaW51cyA9PT0gJysnKSB0b3RhbE1pbnV0ZXNPZmZzZXQgPSAwIC0gdG90YWxNaW51dGVzT2Zmc2V0O1xyXG4gIH1cclxuICByZXR1cm4gRGF0ZS5VVEMoc3RydWN0LnllYXIsIHN0cnVjdC5tb250aCwgc3RydWN0LmRheSwgc3RydWN0LmhvdXIsIHN0cnVjdC5taW51dGUgKyB0b3RhbE1pbnV0ZXNPZmZzZXQsIHN0cnVjdC5zZWNvbmQsIHN0cnVjdC5taWxsaXNlY29uZCk7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VEYXRlU3RydWN0KGRhdGUpIHtcclxuICB2YXIgX3JlZ2V4UmVzdWx0JDckbGVuZ3RoLCBfcmVnZXhSZXN1bHQkO1xyXG4gIGNvbnN0IHJlZ2V4UmVzdWx0ID0gaXNvUmVnLmV4ZWMoZGF0ZSk7XHJcbiAgaWYgKCFyZWdleFJlc3VsdCkgcmV0dXJuIG51bGw7XHJcblxyXG4gIC8vIHVzZSBvZiB0b051bWJlcigpIGF2b2lkcyBOYU4gdGltZXN0YW1wcyBjYXVzZWQgYnkg4oCcdW5kZWZpbmVk4oCdXHJcbiAgLy8gdmFsdWVzIGJlaW5nIHBhc3NlZCB0byBEYXRlIGNvbnN0cnVjdG9yXHJcbiAgcmV0dXJuIHtcclxuICAgIHllYXI6IHRvTnVtYmVyKHJlZ2V4UmVzdWx0WzFdKSxcclxuICAgIG1vbnRoOiB0b051bWJlcihyZWdleFJlc3VsdFsyXSwgMSkgLSAxLFxyXG4gICAgZGF5OiB0b051bWJlcihyZWdleFJlc3VsdFszXSwgMSksXHJcbiAgICBob3VyOiB0b051bWJlcihyZWdleFJlc3VsdFs0XSksXHJcbiAgICBtaW51dGU6IHRvTnVtYmVyKHJlZ2V4UmVzdWx0WzVdKSxcclxuICAgIHNlY29uZDogdG9OdW1iZXIocmVnZXhSZXN1bHRbNl0pLFxyXG4gICAgbWlsbGlzZWNvbmQ6IHJlZ2V4UmVzdWx0WzddID9cclxuICAgIC8vIGFsbG93IGFyYml0cmFyeSBzdWItc2Vjb25kIHByZWNpc2lvbiBiZXlvbmQgbWlsbGlzZWNvbmRzXHJcbiAgICB0b051bWJlcihyZWdleFJlc3VsdFs3XS5zdWJzdHJpbmcoMCwgMykpIDogMCxcclxuICAgIHByZWNpc2lvbjogKF9yZWdleFJlc3VsdCQ3JGxlbmd0aCA9IChfcmVnZXhSZXN1bHQkID0gcmVnZXhSZXN1bHRbN10pID09IG51bGwgPyB2b2lkIDAgOiBfcmVnZXhSZXN1bHQkLmxlbmd0aCkgIT0gbnVsbCA/IF9yZWdleFJlc3VsdCQ3JGxlbmd0aCA6IHVuZGVmaW5lZCxcclxuICAgIHo6IHJlZ2V4UmVzdWx0WzhdIHx8IHVuZGVmaW5lZCxcclxuICAgIHBsdXNNaW51czogcmVnZXhSZXN1bHRbOV0gfHwgdW5kZWZpbmVkLFxyXG4gICAgaG91ck9mZnNldDogdG9OdW1iZXIocmVnZXhSZXN1bHRbMTBdKSxcclxuICAgIG1pbnV0ZU9mZnNldDogdG9OdW1iZXIocmVnZXhSZXN1bHRbMTFdKVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gdG9OdW1iZXIoc3RyLCBkZWZhdWx0VmFsdWUgPSAwKSB7XHJcbiAgcmV0dXJuIE51bWJlcihzdHIpIHx8IGRlZmF1bHRWYWx1ZTtcclxufVxyXG5cclxuLy8gVGFrZW4gZnJvbSBIVE1MIHNwZWM6IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2lucHV0Lmh0bWwjdmFsaWQtZS1tYWlsLWFkZHJlc3NcclxubGV0IHJFbWFpbCA9XHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG4vXlthLXpBLVowLTkuISMkJSYnKitcXC89P15fYHt8fX4tXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSokLztcclxubGV0IHJVcmwgPVxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuL14oKGh0dHBzP3xmdHApOik/XFwvXFwvKCgoKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDopKkApPygoKFxcZHxbMS05XVxcZHwxXFxkXFxkfDJbMC00XVxcZHwyNVswLTVdKVxcLihcXGR8WzEtOV1cXGR8MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC01XSlcXC4oXFxkfFsxLTldXFxkfDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNV0pXFwuKFxcZHxbMS05XVxcZHwxXFxkXFxkfDJbMC00XVxcZHwyNVswLTVdKSl8KCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKVxcLikrKChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpXFwuPykoOlxcZCopPykoXFwvKCgoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OnxAKSsoXFwvKChbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6fEApKikqKT8pPyhcXD8oKChbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6fEApfFtcXHVFMDAwLVxcdUY4RkZdfFxcL3xcXD8pKik/KFxcIygoKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDp8QCl8XFwvfFxcPykqKT8kL2k7XHJcblxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxubGV0IHJVVUlEID0gL14oPzpbMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMS01XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDApJC9pO1xyXG5sZXQgeWVhck1vbnRoRGF5ID0gJ15cXFxcZHs0fS1cXFxcZHsyfS1cXFxcZHsyfSc7XHJcbmxldCBob3VyTWludXRlU2Vjb25kID0gJ1xcXFxkezJ9OlxcXFxkezJ9OlxcXFxkezJ9JztcclxubGV0IHpPck9mZnNldCA9ICcoKFsrLV1cXFxcZHsyfSg6P1xcXFxkezJ9KT8pfFopJztcclxubGV0IHJJc29EYXRlVGltZSA9IG5ldyBSZWdFeHAoYCR7eWVhck1vbnRoRGF5fVQke2hvdXJNaW51dGVTZWNvbmR9KFxcXFwuXFxcXGQrKT8ke3pPck9mZnNldH0kYCk7XHJcbmxldCBpc1RyaW1tZWQgPSB2YWx1ZSA9PiBpc0Fic2VudCh2YWx1ZSkgfHwgdmFsdWUgPT09IHZhbHVlLnRyaW0oKTtcclxubGV0IG9ialN0cmluZ1RhZyA9IHt9LnRvU3RyaW5nKCk7XHJcbmZ1bmN0aW9uIGNyZWF0ZSQ2KCkge1xyXG4gIHJldHVybiBuZXcgU3RyaW5nU2NoZW1hKCk7XHJcbn1cclxuY2xhc3MgU3RyaW5nU2NoZW1hIGV4dGVuZHMgU2NoZW1hIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKHtcclxuICAgICAgdHlwZTogJ3N0cmluZycsXHJcbiAgICAgIGNoZWNrKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nKSB2YWx1ZSA9IHZhbHVlLnZhbHVlT2YoKTtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLndpdGhNdXRhdGlvbigoKSA9PiB7XHJcbiAgICAgIHRoaXMudHJhbnNmb3JtKCh2YWx1ZSwgX3JhdywgY3R4KSA9PiB7XHJcbiAgICAgICAgaWYgKCFjdHguc3BlYy5jb2VyY2UgfHwgY3R4LmlzVHlwZSh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcclxuXHJcbiAgICAgICAgLy8gZG9uJ3QgZXZlciBjb252ZXJ0IGFycmF5c1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIGNvbnN0IHN0clZhbHVlID0gdmFsdWUgIT0gbnVsbCAmJiB2YWx1ZS50b1N0cmluZyA/IHZhbHVlLnRvU3RyaW5nKCkgOiB2YWx1ZTtcclxuXHJcbiAgICAgICAgLy8gbm8gb25lIHdhbnRzIHBsYWluIG9iamVjdHMgY29udmVydGVkIHRvIFtPYmplY3Qgb2JqZWN0XVxyXG4gICAgICAgIGlmIChzdHJWYWx1ZSA9PT0gb2JqU3RyaW5nVGFnKSByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIHN0clZhbHVlO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXF1aXJlZChtZXNzYWdlKSB7XHJcbiAgICByZXR1cm4gc3VwZXIucmVxdWlyZWQobWVzc2FnZSkud2l0aE11dGF0aW9uKHNjaGVtYSA9PiBzY2hlbWEudGVzdCh7XHJcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UgfHwgbWl4ZWQucmVxdWlyZWQsXHJcbiAgICAgIG5hbWU6ICdyZXF1aXJlZCcsXHJcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXHJcbiAgICAgIHRlc3Q6IHZhbHVlID0+ICEhdmFsdWUubGVuZ3RoXHJcbiAgICB9KSk7XHJcbiAgfVxyXG4gIG5vdFJlcXVpcmVkKCkge1xyXG4gICAgcmV0dXJuIHN1cGVyLm5vdFJlcXVpcmVkKCkud2l0aE11dGF0aW9uKHNjaGVtYSA9PiB7XHJcbiAgICAgIHNjaGVtYS50ZXN0cyA9IHNjaGVtYS50ZXN0cy5maWx0ZXIodCA9PiB0Lk9QVElPTlMubmFtZSAhPT0gJ3JlcXVpcmVkJyk7XHJcbiAgICAgIHJldHVybiBzY2hlbWE7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgbGVuZ3RoKGxlbmd0aCwgbWVzc2FnZSA9IHN0cmluZy5sZW5ndGgpIHtcclxuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xyXG4gICAgICBtZXNzYWdlLFxyXG4gICAgICBuYW1lOiAnbGVuZ3RoJyxcclxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxyXG4gICAgICBwYXJhbXM6IHtcclxuICAgICAgICBsZW5ndGhcclxuICAgICAgfSxcclxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcclxuICAgICAgdGVzdCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPT09IHRoaXMucmVzb2x2ZShsZW5ndGgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgbWluKG1pbiwgbWVzc2FnZSA9IHN0cmluZy5taW4pIHtcclxuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xyXG4gICAgICBtZXNzYWdlLFxyXG4gICAgICBuYW1lOiAnbWluJyxcclxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxyXG4gICAgICBwYXJhbXM6IHtcclxuICAgICAgICBtaW5cclxuICAgICAgfSxcclxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcclxuICAgICAgdGVzdCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPj0gdGhpcy5yZXNvbHZlKG1pbik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICBtYXgobWF4LCBtZXNzYWdlID0gc3RyaW5nLm1heCkge1xyXG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XHJcbiAgICAgIG5hbWU6ICdtYXgnLFxyXG4gICAgICBleGNsdXNpdmU6IHRydWUsXHJcbiAgICAgIG1lc3NhZ2UsXHJcbiAgICAgIHBhcmFtczoge1xyXG4gICAgICAgIG1heFxyXG4gICAgICB9LFxyXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxyXG4gICAgICB0ZXN0KHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA8PSB0aGlzLnJlc29sdmUobWF4KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIG1hdGNoZXMocmVnZXgsIG9wdGlvbnMpIHtcclxuICAgIGxldCBleGNsdWRlRW1wdHlTdHJpbmcgPSBmYWxzZTtcclxuICAgIGxldCBtZXNzYWdlO1xyXG4gICAgbGV0IG5hbWU7XHJcbiAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgKHtcclxuICAgICAgICAgIGV4Y2x1ZGVFbXB0eVN0cmluZyA9IGZhbHNlLFxyXG4gICAgICAgICAgbWVzc2FnZSxcclxuICAgICAgICAgIG5hbWVcclxuICAgICAgICB9ID0gb3B0aW9ucyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbWVzc2FnZSA9IG9wdGlvbnM7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xyXG4gICAgICBuYW1lOiBuYW1lIHx8ICdtYXRjaGVzJyxcclxuICAgICAgbWVzc2FnZTogbWVzc2FnZSB8fCBzdHJpbmcubWF0Y2hlcyxcclxuICAgICAgcGFyYW1zOiB7XHJcbiAgICAgICAgcmVnZXhcclxuICAgICAgfSxcclxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcclxuICAgICAgdGVzdDogdmFsdWUgPT4gdmFsdWUgPT09ICcnICYmIGV4Y2x1ZGVFbXB0eVN0cmluZyB8fCB2YWx1ZS5zZWFyY2gocmVnZXgpICE9PSAtMVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGVtYWlsKG1lc3NhZ2UgPSBzdHJpbmcuZW1haWwpIHtcclxuICAgIHJldHVybiB0aGlzLm1hdGNoZXMockVtYWlsLCB7XHJcbiAgICAgIG5hbWU6ICdlbWFpbCcsXHJcbiAgICAgIG1lc3NhZ2UsXHJcbiAgICAgIGV4Y2x1ZGVFbXB0eVN0cmluZzogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHVybChtZXNzYWdlID0gc3RyaW5nLnVybCkge1xyXG4gICAgcmV0dXJuIHRoaXMubWF0Y2hlcyhyVXJsLCB7XHJcbiAgICAgIG5hbWU6ICd1cmwnLFxyXG4gICAgICBtZXNzYWdlLFxyXG4gICAgICBleGNsdWRlRW1wdHlTdHJpbmc6IHRydWVcclxuICAgIH0pO1xyXG4gIH1cclxuICB1dWlkKG1lc3NhZ2UgPSBzdHJpbmcudXVpZCkge1xyXG4gICAgcmV0dXJuIHRoaXMubWF0Y2hlcyhyVVVJRCwge1xyXG4gICAgICBuYW1lOiAndXVpZCcsXHJcbiAgICAgIG1lc3NhZ2UsXHJcbiAgICAgIGV4Y2x1ZGVFbXB0eVN0cmluZzogZmFsc2VcclxuICAgIH0pO1xyXG4gIH1cclxuICBkYXRldGltZShvcHRpb25zKSB7XHJcbiAgICBsZXQgbWVzc2FnZSA9ICcnO1xyXG4gICAgbGV0IGFsbG93T2Zmc2V0O1xyXG4gICAgbGV0IHByZWNpc2lvbjtcclxuICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAoe1xyXG4gICAgICAgICAgbWVzc2FnZSA9ICcnLFxyXG4gICAgICAgICAgYWxsb3dPZmZzZXQgPSBmYWxzZSxcclxuICAgICAgICAgIHByZWNpc2lvbiA9IHVuZGVmaW5lZFxyXG4gICAgICAgIH0gPSBvcHRpb25zKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBtZXNzYWdlID0gb3B0aW9ucztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMubWF0Y2hlcyhySXNvRGF0ZVRpbWUsIHtcclxuICAgICAgbmFtZTogJ2RhdGV0aW1lJyxcclxuICAgICAgbWVzc2FnZTogbWVzc2FnZSB8fCBzdHJpbmcuZGF0ZXRpbWUsXHJcbiAgICAgIGV4Y2x1ZGVFbXB0eVN0cmluZzogdHJ1ZVxyXG4gICAgfSkudGVzdCh7XHJcbiAgICAgIG5hbWU6ICdkYXRldGltZV9vZmZzZXQnLFxyXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlIHx8IHN0cmluZy5kYXRldGltZV9vZmZzZXQsXHJcbiAgICAgIHBhcmFtczoge1xyXG4gICAgICAgIGFsbG93T2Zmc2V0XHJcbiAgICAgIH0sXHJcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXHJcbiAgICAgIHRlc3Q6IHZhbHVlID0+IHtcclxuICAgICAgICBpZiAoIXZhbHVlIHx8IGFsbG93T2Zmc2V0KSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBjb25zdCBzdHJ1Y3QgPSBwYXJzZURhdGVTdHJ1Y3QodmFsdWUpO1xyXG4gICAgICAgIGlmICghc3RydWN0KSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuICEhc3RydWN0Lno7XHJcbiAgICAgIH1cclxuICAgIH0pLnRlc3Qoe1xyXG4gICAgICBuYW1lOiAnZGF0ZXRpbWVfcHJlY2lzaW9uJyxcclxuICAgICAgbWVzc2FnZTogbWVzc2FnZSB8fCBzdHJpbmcuZGF0ZXRpbWVfcHJlY2lzaW9uLFxyXG4gICAgICBwYXJhbXM6IHtcclxuICAgICAgICBwcmVjaXNpb25cclxuICAgICAgfSxcclxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcclxuICAgICAgdGVzdDogdmFsdWUgPT4ge1xyXG4gICAgICAgIGlmICghdmFsdWUgfHwgcHJlY2lzaW9uID09IHVuZGVmaW5lZCkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgY29uc3Qgc3RydWN0ID0gcGFyc2VEYXRlU3RydWN0KHZhbHVlKTtcclxuICAgICAgICBpZiAoIXN0cnVjdCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHJldHVybiBzdHJ1Y3QucHJlY2lzaW9uID09PSBwcmVjaXNpb247XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8tLSB0cmFuc2Zvcm1zIC0tXHJcbiAgZW5zdXJlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdCgnJykudHJhbnNmb3JtKHZhbCA9PiB2YWwgPT09IG51bGwgPyAnJyA6IHZhbCk7XHJcbiAgfVxyXG4gIHRyaW0obWVzc2FnZSA9IHN0cmluZy50cmltKSB7XHJcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0odmFsID0+IHZhbCAhPSBudWxsID8gdmFsLnRyaW0oKSA6IHZhbCkudGVzdCh7XHJcbiAgICAgIG1lc3NhZ2UsXHJcbiAgICAgIG5hbWU6ICd0cmltJyxcclxuICAgICAgdGVzdDogaXNUcmltbWVkXHJcbiAgICB9KTtcclxuICB9XHJcbiAgbG93ZXJjYXNlKG1lc3NhZ2UgPSBzdHJpbmcubG93ZXJjYXNlKSB7XHJcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0odmFsdWUgPT4gIWlzQWJzZW50KHZhbHVlKSA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiB2YWx1ZSkudGVzdCh7XHJcbiAgICAgIG1lc3NhZ2UsXHJcbiAgICAgIG5hbWU6ICdzdHJpbmdfY2FzZScsXHJcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcclxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcclxuICAgICAgdGVzdDogdmFsdWUgPT4gaXNBYnNlbnQodmFsdWUpIHx8IHZhbHVlID09PSB2YWx1ZS50b0xvd2VyQ2FzZSgpXHJcbiAgICB9KTtcclxuICB9XHJcbiAgdXBwZXJjYXNlKG1lc3NhZ2UgPSBzdHJpbmcudXBwZXJjYXNlKSB7XHJcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0odmFsdWUgPT4gIWlzQWJzZW50KHZhbHVlKSA/IHZhbHVlLnRvVXBwZXJDYXNlKCkgOiB2YWx1ZSkudGVzdCh7XHJcbiAgICAgIG1lc3NhZ2UsXHJcbiAgICAgIG5hbWU6ICdzdHJpbmdfY2FzZScsXHJcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcclxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcclxuICAgICAgdGVzdDogdmFsdWUgPT4gaXNBYnNlbnQodmFsdWUpIHx8IHZhbHVlID09PSB2YWx1ZS50b1VwcGVyQ2FzZSgpXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuY3JlYXRlJDYucHJvdG90eXBlID0gU3RyaW5nU2NoZW1hLnByb3RvdHlwZTtcclxuXHJcbi8vXHJcbi8vIFN0cmluZyBJbnRlcmZhY2VzXHJcbi8vXHJcblxyXG5sZXQgaXNOYU4kMSA9IHZhbHVlID0+IHZhbHVlICE9ICt2YWx1ZTtcclxuZnVuY3Rpb24gY3JlYXRlJDUoKSB7XHJcbiAgcmV0dXJuIG5ldyBOdW1iZXJTY2hlbWEoKTtcclxufVxyXG5jbGFzcyBOdW1iZXJTY2hlbWEgZXh0ZW5kcyBTY2hlbWEge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoe1xyXG4gICAgICB0eXBlOiAnbnVtYmVyJyxcclxuICAgICAgY2hlY2sodmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpIHZhbHVlID0gdmFsdWUudmFsdWVPZigpO1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTiQxKHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLndpdGhNdXRhdGlvbigoKSA9PiB7XHJcbiAgICAgIHRoaXMudHJhbnNmb3JtKCh2YWx1ZSwgX3JhdywgY3R4KSA9PiB7XHJcbiAgICAgICAgaWYgKCFjdHguc3BlYy5jb2VyY2UpIHJldHVybiB2YWx1ZTtcclxuICAgICAgICBsZXQgcGFyc2VkID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJzZWQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICBwYXJzZWQgPSBwYXJzZWQucmVwbGFjZSgvXFxzL2csICcnKTtcclxuICAgICAgICAgIGlmIChwYXJzZWQgPT09ICcnKSByZXR1cm4gTmFOO1xyXG4gICAgICAgICAgLy8gZG9uJ3QgdXNlIHBhcnNlRmxvYXQgdG8gYXZvaWQgcG9zaXRpdmVzIG9uIGFscGhhLW51bWVyaWMgc3RyaW5nc1xyXG4gICAgICAgICAgcGFyc2VkID0gK3BhcnNlZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIG51bGwgLT4gTmFOIGlzbid0IHVzZWZ1bDsgdHJlYXQgYWxsIG51bGxzIGFzIG51bGwgYW5kIGxldCBpdCBmYWlsIG9uXHJcbiAgICAgICAgLy8gbnVsbGFiaWxpdHkgY2hlY2sgdnMgVHlwZUVycm9yc1xyXG4gICAgICAgIGlmIChjdHguaXNUeXBlKHBhcnNlZCkgfHwgcGFyc2VkID09PSBudWxsKSByZXR1cm4gcGFyc2VkO1xyXG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHBhcnNlZCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIG1pbihtaW4sIG1lc3NhZ2UgPSBudW1iZXIubWluKSB7XHJcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcclxuICAgICAgbWVzc2FnZSxcclxuICAgICAgbmFtZTogJ21pbicsXHJcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcclxuICAgICAgcGFyYW1zOiB7XHJcbiAgICAgICAgbWluXHJcbiAgICAgIH0sXHJcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXHJcbiAgICAgIHRlc3QodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUgPj0gdGhpcy5yZXNvbHZlKG1pbik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICBtYXgobWF4LCBtZXNzYWdlID0gbnVtYmVyLm1heCkge1xyXG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XHJcbiAgICAgIG1lc3NhZ2UsXHJcbiAgICAgIG5hbWU6ICdtYXgnLFxyXG4gICAgICBleGNsdXNpdmU6IHRydWUsXHJcbiAgICAgIHBhcmFtczoge1xyXG4gICAgICAgIG1heFxyXG4gICAgICB9LFxyXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxyXG4gICAgICB0ZXN0KHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlIDw9IHRoaXMucmVzb2x2ZShtYXgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgbGVzc1RoYW4obGVzcywgbWVzc2FnZSA9IG51bWJlci5sZXNzVGhhbikge1xyXG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XHJcbiAgICAgIG1lc3NhZ2UsXHJcbiAgICAgIG5hbWU6ICdtYXgnLFxyXG4gICAgICBleGNsdXNpdmU6IHRydWUsXHJcbiAgICAgIHBhcmFtczoge1xyXG4gICAgICAgIGxlc3NcclxuICAgICAgfSxcclxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcclxuICAgICAgdGVzdCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSA8IHRoaXMucmVzb2x2ZShsZXNzKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIG1vcmVUaGFuKG1vcmUsIG1lc3NhZ2UgPSBudW1iZXIubW9yZVRoYW4pIHtcclxuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xyXG4gICAgICBtZXNzYWdlLFxyXG4gICAgICBuYW1lOiAnbWluJyxcclxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxyXG4gICAgICBwYXJhbXM6IHtcclxuICAgICAgICBtb3JlXHJcbiAgICAgIH0sXHJcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXHJcbiAgICAgIHRlc3QodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUgPiB0aGlzLnJlc29sdmUobW9yZSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICBwb3NpdGl2ZShtc2cgPSBudW1iZXIucG9zaXRpdmUpIHtcclxuICAgIHJldHVybiB0aGlzLm1vcmVUaGFuKDAsIG1zZyk7XHJcbiAgfVxyXG4gIG5lZ2F0aXZlKG1zZyA9IG51bWJlci5uZWdhdGl2ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMubGVzc1RoYW4oMCwgbXNnKTtcclxuICB9XHJcbiAgaW50ZWdlcihtZXNzYWdlID0gbnVtYmVyLmludGVnZXIpIHtcclxuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xyXG4gICAgICBuYW1lOiAnaW50ZWdlcicsXHJcbiAgICAgIG1lc3NhZ2UsXHJcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXHJcbiAgICAgIHRlc3Q6IHZhbCA9PiBOdW1iZXIuaXNJbnRlZ2VyKHZhbClcclxuICAgIH0pO1xyXG4gIH1cclxuICB0cnVuY2F0ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh2YWx1ZSA9PiAhaXNBYnNlbnQodmFsdWUpID8gdmFsdWUgfCAwIDogdmFsdWUpO1xyXG4gIH1cclxuICByb3VuZChtZXRob2QpIHtcclxuICAgIHZhciBfbWV0aG9kO1xyXG4gICAgbGV0IGF2YWlsID0gWydjZWlsJywgJ2Zsb29yJywgJ3JvdW5kJywgJ3RydW5jJ107XHJcbiAgICBtZXRob2QgPSAoKF9tZXRob2QgPSBtZXRob2QpID09IG51bGwgPyB2b2lkIDAgOiBfbWV0aG9kLnRvTG93ZXJDYXNlKCkpIHx8ICdyb3VuZCc7XHJcblxyXG4gICAgLy8gdGhpcyBleGlzdHMgZm9yIHN5bWVtdHJ5IHdpdGggdGhlIG5ldyBNYXRoLnRydW5jXHJcbiAgICBpZiAobWV0aG9kID09PSAndHJ1bmMnKSByZXR1cm4gdGhpcy50cnVuY2F0ZSgpO1xyXG4gICAgaWYgKGF2YWlsLmluZGV4T2YobWV0aG9kLnRvTG93ZXJDYXNlKCkpID09PSAtMSkgdGhyb3cgbmV3IFR5cGVFcnJvcignT25seSB2YWxpZCBvcHRpb25zIGZvciByb3VuZCgpIGFyZTogJyArIGF2YWlsLmpvaW4oJywgJykpO1xyXG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHZhbHVlID0+ICFpc0Fic2VudCh2YWx1ZSkgPyBNYXRoW21ldGhvZF0odmFsdWUpIDogdmFsdWUpO1xyXG4gIH1cclxufVxyXG5jcmVhdGUkNS5wcm90b3R5cGUgPSBOdW1iZXJTY2hlbWEucHJvdG90eXBlO1xyXG5cclxuLy9cclxuLy8gTnVtYmVyIEludGVyZmFjZXNcclxuLy9cclxuXHJcbmxldCBpbnZhbGlkRGF0ZSA9IG5ldyBEYXRlKCcnKTtcclxubGV0IGlzRGF0ZSA9IG9iaiA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xyXG5mdW5jdGlvbiBjcmVhdGUkNCgpIHtcclxuICByZXR1cm4gbmV3IERhdGVTY2hlbWEoKTtcclxufVxyXG5jbGFzcyBEYXRlU2NoZW1hIGV4dGVuZHMgU2NoZW1hIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKHtcclxuICAgICAgdHlwZTogJ2RhdGUnLFxyXG4gICAgICBjaGVjayh2KSB7XHJcbiAgICAgICAgcmV0dXJuIGlzRGF0ZSh2KSAmJiAhaXNOYU4odi5nZXRUaW1lKCkpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHRoaXMud2l0aE11dGF0aW9uKCgpID0+IHtcclxuICAgICAgdGhpcy50cmFuc2Zvcm0oKHZhbHVlLCBfcmF3LCBjdHgpID0+IHtcclxuICAgICAgICAvLyBudWxsIC0+IEludmFsaWREYXRlIGlzbid0IHVzZWZ1bDsgdHJlYXQgYWxsIG51bGxzIGFzIG51bGwgYW5kIGxldCBpdCBmYWlsIG9uXHJcbiAgICAgICAgLy8gbnVsbGFiaWxpdHkgY2hlY2sgdnMgVHlwZUVycm9yc1xyXG4gICAgICAgIGlmICghY3R4LnNwZWMuY29lcmNlIHx8IGN0eC5pc1R5cGUodmFsdWUpIHx8IHZhbHVlID09PSBudWxsKSByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgdmFsdWUgPSBwYXJzZUlzb0RhdGUodmFsdWUpO1xyXG5cclxuICAgICAgICAvLyAwIGlzIGEgdmFsaWQgdGltZXN0YW1wIGVxdWl2YWxlbnQgdG8gMTk3MC0wMS0wMVQwMDowMDowMFoodW5peCBlcG9jaCkgb3IgYmVmb3JlLlxyXG4gICAgICAgIHJldHVybiAhaXNOYU4odmFsdWUpID8gbmV3IERhdGUodmFsdWUpIDogRGF0ZVNjaGVtYS5JTlZBTElEX0RBVEU7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHByZXBhcmVQYXJhbShyZWYsIG5hbWUpIHtcclxuICAgIGxldCBwYXJhbTtcclxuICAgIGlmICghUmVmZXJlbmNlLmlzUmVmKHJlZikpIHtcclxuICAgICAgbGV0IGNhc3QgPSB0aGlzLmNhc3QocmVmKTtcclxuICAgICAgaWYgKCF0aGlzLl90eXBlQ2hlY2soY2FzdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoYFxcYCR7bmFtZX1cXGAgbXVzdCBiZSBhIERhdGUgb3IgYSB2YWx1ZSB0aGF0IGNhbiBiZSBcXGBjYXN0KClcXGAgdG8gYSBEYXRlYCk7XHJcbiAgICAgIHBhcmFtID0gY2FzdDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBhcmFtID0gcmVmO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhcmFtO1xyXG4gIH1cclxuICBtaW4obWluLCBtZXNzYWdlID0gZGF0ZS5taW4pIHtcclxuICAgIGxldCBsaW1pdCA9IHRoaXMucHJlcGFyZVBhcmFtKG1pbiwgJ21pbicpO1xyXG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XHJcbiAgICAgIG1lc3NhZ2UsXHJcbiAgICAgIG5hbWU6ICdtaW4nLFxyXG4gICAgICBleGNsdXNpdmU6IHRydWUsXHJcbiAgICAgIHBhcmFtczoge1xyXG4gICAgICAgIG1pblxyXG4gICAgICB9LFxyXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxyXG4gICAgICB0ZXN0KHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlID49IHRoaXMucmVzb2x2ZShsaW1pdCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICBtYXgobWF4LCBtZXNzYWdlID0gZGF0ZS5tYXgpIHtcclxuICAgIGxldCBsaW1pdCA9IHRoaXMucHJlcGFyZVBhcmFtKG1heCwgJ21heCcpO1xyXG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XHJcbiAgICAgIG1lc3NhZ2UsXHJcbiAgICAgIG5hbWU6ICdtYXgnLFxyXG4gICAgICBleGNsdXNpdmU6IHRydWUsXHJcbiAgICAgIHBhcmFtczoge1xyXG4gICAgICAgIG1heFxyXG4gICAgICB9LFxyXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxyXG4gICAgICB0ZXN0KHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlIDw9IHRoaXMucmVzb2x2ZShsaW1pdCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5EYXRlU2NoZW1hLklOVkFMSURfREFURSA9IGludmFsaWREYXRlO1xyXG5jcmVhdGUkNC5wcm90b3R5cGUgPSBEYXRlU2NoZW1hLnByb3RvdHlwZTtcclxuY3JlYXRlJDQuSU5WQUxJRF9EQVRFID0gaW52YWxpZERhdGU7XHJcblxyXG4vLyBAdHMtZXhwZWN0LWVycm9yXHJcbmZ1bmN0aW9uIHNvcnRGaWVsZHMoZmllbGRzLCBleGNsdWRlZEVkZ2VzID0gW10pIHtcclxuICBsZXQgZWRnZXMgPSBbXTtcclxuICBsZXQgbm9kZXMgPSBuZXcgU2V0KCk7XHJcbiAgbGV0IGV4Y2x1ZGVzID0gbmV3IFNldChleGNsdWRlZEVkZ2VzLm1hcCgoW2EsIGJdKSA9PiBgJHthfS0ke2J9YCkpO1xyXG4gIGZ1bmN0aW9uIGFkZE5vZGUoZGVwUGF0aCwga2V5KSB7XHJcbiAgICBsZXQgbm9kZSA9IHNwbGl0KGRlcFBhdGgpWzBdO1xyXG4gICAgbm9kZXMuYWRkKG5vZGUpO1xyXG4gICAgaWYgKCFleGNsdWRlcy5oYXMoYCR7a2V5fS0ke25vZGV9YCkpIGVkZ2VzLnB1c2goW2tleSwgbm9kZV0pO1xyXG4gIH1cclxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhmaWVsZHMpKSB7XHJcbiAgICBsZXQgdmFsdWUgPSBmaWVsZHNba2V5XTtcclxuICAgIG5vZGVzLmFkZChrZXkpO1xyXG4gICAgaWYgKFJlZmVyZW5jZS5pc1JlZih2YWx1ZSkgJiYgdmFsdWUuaXNTaWJsaW5nKSBhZGROb2RlKHZhbHVlLnBhdGgsIGtleSk7ZWxzZSBpZiAoaXNTY2hlbWEodmFsdWUpICYmICdkZXBzJyBpbiB2YWx1ZSkgdmFsdWUuZGVwcy5mb3JFYWNoKHBhdGggPT4gYWRkTm9kZShwYXRoLCBrZXkpKTtcclxuICB9XHJcbiAgcmV0dXJuIHRvcG9zb3J0LmFycmF5KEFycmF5LmZyb20obm9kZXMpLCBlZGdlcykucmV2ZXJzZSgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCBlcnIpIHtcclxuICBsZXQgaWR4ID0gSW5maW5pdHk7XHJcbiAgYXJyLnNvbWUoKGtleSwgaWkpID0+IHtcclxuICAgIHZhciBfZXJyJHBhdGg7XHJcbiAgICBpZiAoKF9lcnIkcGF0aCA9IGVyci5wYXRoKSAhPSBudWxsICYmIF9lcnIkcGF0aC5pbmNsdWRlcyhrZXkpKSB7XHJcbiAgICAgIGlkeCA9IGlpO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gaWR4O1xyXG59XHJcbmZ1bmN0aW9uIHNvcnRCeUtleU9yZGVyKGtleXMpIHtcclxuICByZXR1cm4gKGEsIGIpID0+IHtcclxuICAgIHJldHVybiBmaW5kSW5kZXgoa2V5cywgYSkgLSBmaW5kSW5kZXgoa2V5cywgYik7XHJcbiAgfTtcclxufVxyXG5cclxuY29uc3QgcGFyc2VKc29uID0gKHZhbHVlLCBfLCBjdHgpID0+IHtcclxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH1cclxuICBsZXQgcGFyc2VkID0gdmFsdWU7XHJcbiAgdHJ5IHtcclxuICAgIHBhcnNlZCA9IEpTT04ucGFyc2UodmFsdWUpO1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgLyogKi9cclxuICB9XHJcbiAgcmV0dXJuIGN0eC5pc1R5cGUocGFyc2VkKSA/IHBhcnNlZCA6IHZhbHVlO1xyXG59O1xyXG5cclxuLy8gQHRzLWlnbm9yZVxyXG5mdW5jdGlvbiBkZWVwUGFydGlhbChzY2hlbWEpIHtcclxuICBpZiAoJ2ZpZWxkcycgaW4gc2NoZW1hKSB7XHJcbiAgICBjb25zdCBwYXJ0aWFsID0ge307XHJcbiAgICBmb3IgKGNvbnN0IFtrZXksIGZpZWxkU2NoZW1hXSBvZiBPYmplY3QuZW50cmllcyhzY2hlbWEuZmllbGRzKSkge1xyXG4gICAgICBwYXJ0aWFsW2tleV0gPSBkZWVwUGFydGlhbChmaWVsZFNjaGVtYSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2NoZW1hLnNldEZpZWxkcyhwYXJ0aWFsKTtcclxuICB9XHJcbiAgaWYgKHNjaGVtYS50eXBlID09PSAnYXJyYXknKSB7XHJcbiAgICBjb25zdCBuZXh0QXJyYXkgPSBzY2hlbWEub3B0aW9uYWwoKTtcclxuICAgIGlmIChuZXh0QXJyYXkuaW5uZXJUeXBlKSBuZXh0QXJyYXkuaW5uZXJUeXBlID0gZGVlcFBhcnRpYWwobmV4dEFycmF5LmlubmVyVHlwZSk7XHJcbiAgICByZXR1cm4gbmV4dEFycmF5O1xyXG4gIH1cclxuICBpZiAoc2NoZW1hLnR5cGUgPT09ICd0dXBsZScpIHtcclxuICAgIHJldHVybiBzY2hlbWEub3B0aW9uYWwoKS5jbG9uZSh7XHJcbiAgICAgIHR5cGVzOiBzY2hlbWEuc3BlYy50eXBlcy5tYXAoZGVlcFBhcnRpYWwpXHJcbiAgICB9KTtcclxuICB9XHJcbiAgaWYgKCdvcHRpb25hbCcgaW4gc2NoZW1hKSB7XHJcbiAgICByZXR1cm4gc2NoZW1hLm9wdGlvbmFsKCk7XHJcbiAgfVxyXG4gIHJldHVybiBzY2hlbWE7XHJcbn1cclxuY29uc3QgZGVlcEhhcyA9IChvYmosIHApID0+IHtcclxuICBjb25zdCBwYXRoID0gWy4uLm5vcm1hbGl6ZVBhdGgocCldO1xyXG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHBhdGhbMF0gaW4gb2JqO1xyXG4gIGxldCBsYXN0ID0gcGF0aC5wb3AoKTtcclxuICBsZXQgcGFyZW50ID0gZ2V0dGVyKGpvaW4ocGF0aCksIHRydWUpKG9iaik7XHJcbiAgcmV0dXJuICEhKHBhcmVudCAmJiBsYXN0IGluIHBhcmVudCk7XHJcbn07XHJcbmxldCBpc09iamVjdCA9IG9iaiA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XHJcbmZ1bmN0aW9uIHVua25vd24oY3R4LCB2YWx1ZSkge1xyXG4gIGxldCBrbm93biA9IE9iamVjdC5rZXlzKGN0eC5maWVsZHMpO1xyXG4gIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkuZmlsdGVyKGtleSA9PiBrbm93bi5pbmRleE9mKGtleSkgPT09IC0xKTtcclxufVxyXG5jb25zdCBkZWZhdWx0U29ydCA9IHNvcnRCeUtleU9yZGVyKFtdKTtcclxuZnVuY3Rpb24gY3JlYXRlJDMoc3BlYykge1xyXG4gIHJldHVybiBuZXcgT2JqZWN0U2NoZW1hKHNwZWMpO1xyXG59XHJcbmNsYXNzIE9iamVjdFNjaGVtYSBleHRlbmRzIFNjaGVtYSB7XHJcbiAgY29uc3RydWN0b3Ioc3BlYykge1xyXG4gICAgc3VwZXIoe1xyXG4gICAgICB0eXBlOiAnb2JqZWN0JyxcclxuICAgICAgY2hlY2sodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLmZpZWxkcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICB0aGlzLl9zb3J0RXJyb3JzID0gZGVmYXVsdFNvcnQ7XHJcbiAgICB0aGlzLl9ub2RlcyA9IFtdO1xyXG4gICAgdGhpcy5fZXhjbHVkZWRFZGdlcyA9IFtdO1xyXG4gICAgdGhpcy53aXRoTXV0YXRpb24oKCkgPT4ge1xyXG4gICAgICBpZiAoc3BlYykge1xyXG4gICAgICAgIHRoaXMuc2hhcGUoc3BlYyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICBfY2FzdChfdmFsdWUsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgdmFyIF9vcHRpb25zJHN0cmlwVW5rbm93bjtcclxuICAgIGxldCB2YWx1ZSA9IHN1cGVyLl9jYXN0KF92YWx1ZSwgb3B0aW9ucyk7XHJcblxyXG4gICAgLy9zaG91bGQgaWdub3JlIG51bGxzIGhlcmVcclxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5nZXREZWZhdWx0KG9wdGlvbnMpO1xyXG4gICAgaWYgKCF0aGlzLl90eXBlQ2hlY2sodmFsdWUpKSByZXR1cm4gdmFsdWU7XHJcbiAgICBsZXQgZmllbGRzID0gdGhpcy5maWVsZHM7XHJcbiAgICBsZXQgc3RyaXAgPSAoX29wdGlvbnMkc3RyaXBVbmtub3duID0gb3B0aW9ucy5zdHJpcFVua25vd24pICE9IG51bGwgPyBfb3B0aW9ucyRzdHJpcFVua25vd24gOiB0aGlzLnNwZWMubm9Vbmtub3duO1xyXG4gICAgbGV0IHByb3BzID0gW10uY29uY2F0KHRoaXMuX25vZGVzLCBPYmplY3Qua2V5cyh2YWx1ZSkuZmlsdGVyKHYgPT4gIXRoaXMuX25vZGVzLmluY2x1ZGVzKHYpKSk7XHJcbiAgICBsZXQgaW50ZXJtZWRpYXRlVmFsdWUgPSB7fTsgLy8gaXMgZmlsbGVkIGR1cmluZyB0aGUgdHJhbnNmb3JtIGJlbG93XHJcbiAgICBsZXQgaW5uZXJPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xyXG4gICAgICBwYXJlbnQ6IGludGVybWVkaWF0ZVZhbHVlLFxyXG4gICAgICBfX3ZhbGlkYXRpbmc6IG9wdGlvbnMuX192YWxpZGF0aW5nIHx8IGZhbHNlXHJcbiAgICB9KTtcclxuICAgIGxldCBpc0NoYW5nZWQgPSBmYWxzZTtcclxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wcykge1xyXG4gICAgICBsZXQgZmllbGQgPSBmaWVsZHNbcHJvcF07XHJcbiAgICAgIGxldCBleGlzdHMgPSAocHJvcCBpbiB2YWx1ZSk7XHJcbiAgICAgIGlmIChmaWVsZCkge1xyXG4gICAgICAgIGxldCBmaWVsZFZhbHVlO1xyXG4gICAgICAgIGxldCBpbnB1dFZhbHVlID0gdmFsdWVbcHJvcF07XHJcblxyXG4gICAgICAgIC8vIHNhZmUgdG8gbXV0YXRlIHNpbmNlIHRoaXMgaXMgZmlyZWQgaW4gc2VxdWVuY2VcclxuICAgICAgICBpbm5lck9wdGlvbnMucGF0aCA9IChvcHRpb25zLnBhdGggPyBgJHtvcHRpb25zLnBhdGh9LmAgOiAnJykgKyBwcm9wO1xyXG4gICAgICAgIGZpZWxkID0gZmllbGQucmVzb2x2ZSh7XHJcbiAgICAgICAgICB2YWx1ZTogaW5wdXRWYWx1ZSxcclxuICAgICAgICAgIGNvbnRleHQ6IG9wdGlvbnMuY29udGV4dCxcclxuICAgICAgICAgIHBhcmVudDogaW50ZXJtZWRpYXRlVmFsdWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXQgZmllbGRTcGVjID0gZmllbGQgaW5zdGFuY2VvZiBTY2hlbWEgPyBmaWVsZC5zcGVjIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGxldCBzdHJpY3QgPSBmaWVsZFNwZWMgPT0gbnVsbCA/IHZvaWQgMCA6IGZpZWxkU3BlYy5zdHJpY3Q7XHJcbiAgICAgICAgaWYgKGZpZWxkU3BlYyAhPSBudWxsICYmIGZpZWxkU3BlYy5zdHJpcCkge1xyXG4gICAgICAgICAgaXNDaGFuZ2VkID0gaXNDaGFuZ2VkIHx8IHByb3AgaW4gdmFsdWU7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmllbGRWYWx1ZSA9ICFvcHRpb25zLl9fdmFsaWRhdGluZyB8fCAhc3RyaWN0ID9cclxuICAgICAgICAvLyBUT0RPOiB1c2UgX2Nhc3QsIHRoaXMgaXMgZG91YmxlIHJlc29sdmluZ1xyXG4gICAgICAgIGZpZWxkLmNhc3QodmFsdWVbcHJvcF0sIGlubmVyT3B0aW9ucykgOiB2YWx1ZVtwcm9wXTtcclxuICAgICAgICBpZiAoZmllbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBpbnRlcm1lZGlhdGVWYWx1ZVtwcm9wXSA9IGZpZWxkVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKGV4aXN0cyAmJiAhc3RyaXApIHtcclxuICAgICAgICBpbnRlcm1lZGlhdGVWYWx1ZVtwcm9wXSA9IHZhbHVlW3Byb3BdO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChleGlzdHMgIT09IHByb3AgaW4gaW50ZXJtZWRpYXRlVmFsdWUgfHwgaW50ZXJtZWRpYXRlVmFsdWVbcHJvcF0gIT09IHZhbHVlW3Byb3BdKSB7XHJcbiAgICAgICAgaXNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlzQ2hhbmdlZCA/IGludGVybWVkaWF0ZVZhbHVlIDogdmFsdWU7XHJcbiAgfVxyXG4gIF92YWxpZGF0ZShfdmFsdWUsIG9wdGlvbnMgPSB7fSwgcGFuaWMsIG5leHQpIHtcclxuICAgIGxldCB7XHJcbiAgICAgIGZyb20gPSBbXSxcclxuICAgICAgb3JpZ2luYWxWYWx1ZSA9IF92YWx1ZSxcclxuICAgICAgcmVjdXJzaXZlID0gdGhpcy5zcGVjLnJlY3Vyc2l2ZVxyXG4gICAgfSA9IG9wdGlvbnM7XHJcbiAgICBvcHRpb25zLmZyb20gPSBbe1xyXG4gICAgICBzY2hlbWE6IHRoaXMsXHJcbiAgICAgIHZhbHVlOiBvcmlnaW5hbFZhbHVlXHJcbiAgICB9LCAuLi5mcm9tXTtcclxuICAgIC8vIHRoaXMgZmxhZyBpcyBuZWVkZWQgZm9yIGhhbmRsaW5nIGBzdHJpY3RgIGNvcnJlY3RseSBpbiB0aGUgY29udGV4dCBvZlxyXG4gICAgLy8gdmFsaWRhdGlvbiB2cyBqdXN0IGNhc3RpbmcuIGUuZyBzdHJpY3QoKSBvbiBhIGZpZWxkIGlzIG9ubHkgdXNlZCB3aGVuIHZhbGlkYXRpbmdcclxuICAgIG9wdGlvbnMuX192YWxpZGF0aW5nID0gdHJ1ZTtcclxuICAgIG9wdGlvbnMub3JpZ2luYWxWYWx1ZSA9IG9yaWdpbmFsVmFsdWU7XHJcbiAgICBzdXBlci5fdmFsaWRhdGUoX3ZhbHVlLCBvcHRpb25zLCBwYW5pYywgKG9iamVjdEVycm9ycywgdmFsdWUpID0+IHtcclxuICAgICAgaWYgKCFyZWN1cnNpdmUgfHwgIWlzT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICAgIG5leHQob2JqZWN0RXJyb3JzLCB2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIG9yaWdpbmFsVmFsdWUgPSBvcmlnaW5hbFZhbHVlIHx8IHZhbHVlO1xyXG4gICAgICBsZXQgdGVzdHMgPSBbXTtcclxuICAgICAgZm9yIChsZXQga2V5IG9mIHRoaXMuX25vZGVzKSB7XHJcbiAgICAgICAgbGV0IGZpZWxkID0gdGhpcy5maWVsZHNba2V5XTtcclxuICAgICAgICBpZiAoIWZpZWxkIHx8IFJlZmVyZW5jZS5pc1JlZihmaWVsZCkpIHtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0ZXN0cy5wdXNoKGZpZWxkLmFzTmVzdGVkVGVzdCh7XHJcbiAgICAgICAgICBvcHRpb25zLFxyXG4gICAgICAgICAga2V5LFxyXG4gICAgICAgICAgcGFyZW50OiB2YWx1ZSxcclxuICAgICAgICAgIHBhcmVudFBhdGg6IG9wdGlvbnMucGF0aCxcclxuICAgICAgICAgIG9yaWdpbmFsUGFyZW50OiBvcmlnaW5hbFZhbHVlXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMucnVuVGVzdHMoe1xyXG4gICAgICAgIHRlc3RzLFxyXG4gICAgICAgIHZhbHVlLFxyXG4gICAgICAgIG9yaWdpbmFsVmFsdWUsXHJcbiAgICAgICAgb3B0aW9uc1xyXG4gICAgICB9LCBwYW5pYywgZmllbGRFcnJvcnMgPT4ge1xyXG4gICAgICAgIG5leHQoZmllbGRFcnJvcnMuc29ydCh0aGlzLl9zb3J0RXJyb3JzKS5jb25jYXQob2JqZWN0RXJyb3JzKSwgdmFsdWUpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBjbG9uZShzcGVjKSB7XHJcbiAgICBjb25zdCBuZXh0ID0gc3VwZXIuY2xvbmUoc3BlYyk7XHJcbiAgICBuZXh0LmZpZWxkcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZmllbGRzKTtcclxuICAgIG5leHQuX25vZGVzID0gdGhpcy5fbm9kZXM7XHJcbiAgICBuZXh0Ll9leGNsdWRlZEVkZ2VzID0gdGhpcy5fZXhjbHVkZWRFZGdlcztcclxuICAgIG5leHQuX3NvcnRFcnJvcnMgPSB0aGlzLl9zb3J0RXJyb3JzO1xyXG4gICAgcmV0dXJuIG5leHQ7XHJcbiAgfVxyXG4gIGNvbmNhdChzY2hlbWEpIHtcclxuICAgIGxldCBuZXh0ID0gc3VwZXIuY29uY2F0KHNjaGVtYSk7XHJcbiAgICBsZXQgbmV4dEZpZWxkcyA9IG5leHQuZmllbGRzO1xyXG4gICAgZm9yIChsZXQgW2ZpZWxkLCBzY2hlbWFPclJlZl0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5maWVsZHMpKSB7XHJcbiAgICAgIGNvbnN0IHRhcmdldCA9IG5leHRGaWVsZHNbZmllbGRdO1xyXG4gICAgICBuZXh0RmllbGRzW2ZpZWxkXSA9IHRhcmdldCA9PT0gdW5kZWZpbmVkID8gc2NoZW1hT3JSZWYgOiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV4dC53aXRoTXV0YXRpb24ocyA9PlxyXG4gICAgLy8gWFhYOiBleGNsdWRlcyBoZXJlIGlzIHdyb25nXHJcbiAgICBzLnNldEZpZWxkcyhuZXh0RmllbGRzLCBbLi4udGhpcy5fZXhjbHVkZWRFZGdlcywgLi4uc2NoZW1hLl9leGNsdWRlZEVkZ2VzXSkpO1xyXG4gIH1cclxuICBfZ2V0RGVmYXVsdChvcHRpb25zKSB7XHJcbiAgICBpZiAoJ2RlZmF1bHQnIGluIHRoaXMuc3BlYykge1xyXG4gICAgICByZXR1cm4gc3VwZXIuX2dldERlZmF1bHQob3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgdGhlcmUgaXMgbm8gZGVmYXVsdCBzZXQgaW52ZW50IG9uZVxyXG4gICAgaWYgKCF0aGlzLl9ub2Rlcy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGxldCBkZnQgPSB7fTtcclxuICAgIHRoaXMuX25vZGVzLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgdmFyIF9pbm5lck9wdGlvbnM7XHJcbiAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5maWVsZHNba2V5XTtcclxuICAgICAgbGV0IGlubmVyT3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgIGlmICgoX2lubmVyT3B0aW9ucyA9IGlubmVyT3B0aW9ucykgIT0gbnVsbCAmJiBfaW5uZXJPcHRpb25zLnZhbHVlKSB7XHJcbiAgICAgICAgaW5uZXJPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgaW5uZXJPcHRpb25zLCB7XHJcbiAgICAgICAgICBwYXJlbnQ6IGlubmVyT3B0aW9ucy52YWx1ZSxcclxuICAgICAgICAgIHZhbHVlOiBpbm5lck9wdGlvbnMudmFsdWVba2V5XVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGRmdFtrZXldID0gZmllbGQgJiYgJ2dldERlZmF1bHQnIGluIGZpZWxkID8gZmllbGQuZ2V0RGVmYXVsdChpbm5lck9wdGlvbnMpIDogdW5kZWZpbmVkO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZGZ0O1xyXG4gIH1cclxuICBzZXRGaWVsZHMoc2hhcGUsIGV4Y2x1ZGVkRWRnZXMpIHtcclxuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xyXG4gICAgbmV4dC5maWVsZHMgPSBzaGFwZTtcclxuICAgIG5leHQuX25vZGVzID0gc29ydEZpZWxkcyhzaGFwZSwgZXhjbHVkZWRFZGdlcyk7XHJcbiAgICBuZXh0Ll9zb3J0RXJyb3JzID0gc29ydEJ5S2V5T3JkZXIoT2JqZWN0LmtleXMoc2hhcGUpKTtcclxuICAgIC8vIFhYWDogdGhpcyBjYXJyaWVzIG92ZXIgZWRnZXMgd2hpY2ggbWF5IG5vdCBiZSB3aGF0IHlvdSB3YW50XHJcbiAgICBpZiAoZXhjbHVkZWRFZGdlcykgbmV4dC5fZXhjbHVkZWRFZGdlcyA9IGV4Y2x1ZGVkRWRnZXM7XHJcbiAgICByZXR1cm4gbmV4dDtcclxuICB9XHJcbiAgc2hhcGUoYWRkaXRpb25zLCBleGNsdWRlcyA9IFtdKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLndpdGhNdXRhdGlvbihuZXh0ID0+IHtcclxuICAgICAgbGV0IGVkZ2VzID0gbmV4dC5fZXhjbHVkZWRFZGdlcztcclxuICAgICAgaWYgKGV4Y2x1ZGVzLmxlbmd0aCkge1xyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShleGNsdWRlc1swXSkpIGV4Y2x1ZGVzID0gW2V4Y2x1ZGVzXTtcclxuICAgICAgICBlZGdlcyA9IFsuLi5uZXh0Ll9leGNsdWRlZEVkZ2VzLCAuLi5leGNsdWRlc107XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFhYWDogZXhjbHVkZXMgaGVyZSBpcyB3cm9uZ1xyXG4gICAgICByZXR1cm4gbmV4dC5zZXRGaWVsZHMoT2JqZWN0LmFzc2lnbihuZXh0LmZpZWxkcywgYWRkaXRpb25zKSwgZWRnZXMpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHBhcnRpYWwoKSB7XHJcbiAgICBjb25zdCBwYXJ0aWFsID0ge307XHJcbiAgICBmb3IgKGNvbnN0IFtrZXksIHNjaGVtYV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5maWVsZHMpKSB7XHJcbiAgICAgIHBhcnRpYWxba2V5XSA9ICdvcHRpb25hbCcgaW4gc2NoZW1hICYmIHNjaGVtYS5vcHRpb25hbCBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gc2NoZW1hLm9wdGlvbmFsKCkgOiBzY2hlbWE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5zZXRGaWVsZHMocGFydGlhbCk7XHJcbiAgfVxyXG4gIGRlZXBQYXJ0aWFsKCkge1xyXG4gICAgY29uc3QgbmV4dCA9IGRlZXBQYXJ0aWFsKHRoaXMpO1xyXG4gICAgcmV0dXJuIG5leHQ7XHJcbiAgfVxyXG4gIHBpY2soa2V5cykge1xyXG4gICAgY29uc3QgcGlja2VkID0ge307XHJcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XHJcbiAgICAgIGlmICh0aGlzLmZpZWxkc1trZXldKSBwaWNrZWRba2V5XSA9IHRoaXMuZmllbGRzW2tleV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5zZXRGaWVsZHMocGlja2VkLCB0aGlzLl9leGNsdWRlZEVkZ2VzLmZpbHRlcigoW2EsIGJdKSA9PiBrZXlzLmluY2x1ZGVzKGEpICYmIGtleXMuaW5jbHVkZXMoYikpKTtcclxuICB9XHJcbiAgb21pdChrZXlzKSB7XHJcbiAgICBjb25zdCByZW1haW5pbmcgPSBbXTtcclxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuZmllbGRzKSkge1xyXG4gICAgICBpZiAoa2V5cy5pbmNsdWRlcyhrZXkpKSBjb250aW51ZTtcclxuICAgICAgcmVtYWluaW5nLnB1c2goa2V5KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLnBpY2socmVtYWluaW5nKTtcclxuICB9XHJcbiAgZnJvbShmcm9tLCB0bywgYWxpYXMpIHtcclxuICAgIGxldCBmcm9tR2V0dGVyID0gZ2V0dGVyKGZyb20sIHRydWUpO1xyXG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKG9iaiA9PiB7XHJcbiAgICAgIGlmICghb2JqKSByZXR1cm4gb2JqO1xyXG4gICAgICBsZXQgbmV3T2JqID0gb2JqO1xyXG4gICAgICBpZiAoZGVlcEhhcyhvYmosIGZyb20pKSB7XHJcbiAgICAgICAgbmV3T2JqID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcclxuICAgICAgICBpZiAoIWFsaWFzKSBkZWxldGUgbmV3T2JqW2Zyb21dO1xyXG4gICAgICAgIG5ld09ialt0b10gPSBmcm9tR2V0dGVyKG9iaik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5ld09iajtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqIFBhcnNlIGFuIGlucHV0IEpTT04gc3RyaW5nIHRvIGFuIG9iamVjdCAqL1xyXG4gIGpzb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ocGFyc2VKc29uKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNpbWlsYXIgdG8gYG5vVW5rbm93bmAgYnV0IG9ubHkgdmFsaWRhdGVzIHRoYXQgYW4gb2JqZWN0IGlzIHRoZSByaWdodCBzaGFwZSB3aXRob3V0IHN0cmlwcGluZyB0aGUgdW5rbm93biBrZXlzXHJcbiAgICovXHJcbiAgZXhhY3QobWVzc2FnZSkge1xyXG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XHJcbiAgICAgIG5hbWU6ICdleGFjdCcsXHJcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcclxuICAgICAgbWVzc2FnZTogbWVzc2FnZSB8fCBvYmplY3QuZXhhY3QsXHJcbiAgICAgIHRlc3QodmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgY29uc3QgdW5rbm93bktleXMgPSB1bmtub3duKHRoaXMuc2NoZW1hLCB2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHVua25vd25LZXlzLmxlbmd0aCA9PT0gMCB8fCB0aGlzLmNyZWF0ZUVycm9yKHtcclxuICAgICAgICAgIHBhcmFtczoge1xyXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB1bmtub3duS2V5cy5qb2luKCcsICcpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICBzdHJpcFVua25vd24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jbG9uZSh7XHJcbiAgICAgIG5vVW5rbm93bjogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIG5vVW5rbm93bihub0FsbG93ID0gdHJ1ZSwgbWVzc2FnZSA9IG9iamVjdC5ub1Vua25vd24pIHtcclxuICAgIGlmICh0eXBlb2Ygbm9BbGxvdyAhPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgIG1lc3NhZ2UgPSBub0FsbG93O1xyXG4gICAgICBub0FsbG93ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGxldCBuZXh0ID0gdGhpcy50ZXN0KHtcclxuICAgICAgbmFtZTogJ25vVW5rbm93bicsXHJcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcclxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcclxuICAgICAgdGVzdCh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBjb25zdCB1bmtub3duS2V5cyA9IHVua25vd24odGhpcy5zY2hlbWEsIHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gIW5vQWxsb3cgfHwgdW5rbm93bktleXMubGVuZ3RoID09PSAwIHx8IHRoaXMuY3JlYXRlRXJyb3Ioe1xyXG4gICAgICAgICAgcGFyYW1zOiB7XHJcbiAgICAgICAgICAgIHVua25vd246IHVua25vd25LZXlzLmpvaW4oJywgJylcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBuZXh0LnNwZWMubm9Vbmtub3duID0gbm9BbGxvdztcclxuICAgIHJldHVybiBuZXh0O1xyXG4gIH1cclxuICB1bmtub3duKGFsbG93ID0gdHJ1ZSwgbWVzc2FnZSA9IG9iamVjdC5ub1Vua25vd24pIHtcclxuICAgIHJldHVybiB0aGlzLm5vVW5rbm93bighYWxsb3csIG1lc3NhZ2UpO1xyXG4gIH1cclxuICB0cmFuc2Zvcm1LZXlzKGZuKSB7XHJcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ob2JqID0+IHtcclxuICAgICAgaWYgKCFvYmopIHJldHVybiBvYmo7XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xyXG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmopKSByZXN1bHRbZm4oa2V5KV0gPSBvYmpba2V5XTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0pO1xyXG4gIH1cclxuICBjYW1lbENhc2UoKSB7XHJcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1LZXlzKGNhbWVsQ2FzZSk7XHJcbiAgfVxyXG4gIHNuYWtlQ2FzZSgpIHtcclxuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUtleXMoc25ha2VDYXNlKTtcclxuICB9XHJcbiAgY29uc3RhbnRDYXNlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtS2V5cyhrZXkgPT4gc25ha2VDYXNlKGtleSkudG9VcHBlckNhc2UoKSk7XHJcbiAgfVxyXG4gIGRlc2NyaWJlKG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IG5leHQgPSAob3B0aW9ucyA/IHRoaXMucmVzb2x2ZShvcHRpb25zKSA6IHRoaXMpLmNsb25lKCk7XHJcbiAgICBjb25zdCBiYXNlID0gc3VwZXIuZGVzY3JpYmUob3B0aW9ucyk7XHJcbiAgICBiYXNlLmZpZWxkcyA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobmV4dC5maWVsZHMpKSB7XHJcbiAgICAgIHZhciBfaW5uZXJPcHRpb25zMjtcclxuICAgICAgbGV0IGlubmVyT3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgIGlmICgoX2lubmVyT3B0aW9uczIgPSBpbm5lck9wdGlvbnMpICE9IG51bGwgJiYgX2lubmVyT3B0aW9uczIudmFsdWUpIHtcclxuICAgICAgICBpbm5lck9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBpbm5lck9wdGlvbnMsIHtcclxuICAgICAgICAgIHBhcmVudDogaW5uZXJPcHRpb25zLnZhbHVlLFxyXG4gICAgICAgICAgdmFsdWU6IGlubmVyT3B0aW9ucy52YWx1ZVtrZXldXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgYmFzZS5maWVsZHNba2V5XSA9IHZhbHVlLmRlc2NyaWJlKGlubmVyT3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYmFzZTtcclxuICB9XHJcbn1cclxuY3JlYXRlJDMucHJvdG90eXBlID0gT2JqZWN0U2NoZW1hLnByb3RvdHlwZTtcclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZSQyKHR5cGUpIHtcclxuICByZXR1cm4gbmV3IEFycmF5U2NoZW1hKHR5cGUpO1xyXG59XHJcbmNsYXNzIEFycmF5U2NoZW1hIGV4dGVuZHMgU2NoZW1hIHtcclxuICBjb25zdHJ1Y3Rvcih0eXBlKSB7XHJcbiAgICBzdXBlcih7XHJcbiAgICAgIHR5cGU6ICdhcnJheScsXHJcbiAgICAgIHNwZWM6IHtcclxuICAgICAgICB0eXBlczogdHlwZVxyXG4gICAgICB9LFxyXG4gICAgICBjaGVjayh2KSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGB1bmRlZmluZWRgIHNwZWNpZmljYWxseSBtZWFucyB1bmluaXRpYWxpemVkLCBhcyBvcHBvc2VkIHRvIFwibm8gc3VidHlwZVwiXHJcbiAgICB0aGlzLmlubmVyVHlwZSA9IHZvaWQgMDtcclxuICAgIHRoaXMuaW5uZXJUeXBlID0gdHlwZTtcclxuICB9XHJcbiAgX2Nhc3QoX3ZhbHVlLCBfb3B0cykge1xyXG4gICAgY29uc3QgdmFsdWUgPSBzdXBlci5fY2FzdChfdmFsdWUsIF9vcHRzKTtcclxuXHJcbiAgICAvLyBzaG91bGQgaWdub3JlIG51bGxzIGhlcmVcclxuICAgIGlmICghdGhpcy5fdHlwZUNoZWNrKHZhbHVlKSB8fCAhdGhpcy5pbm5lclR5cGUpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgbGV0IGlzQ2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgY29uc3QgY2FzdEFycmF5ID0gdmFsdWUubWFwKCh2LCBpZHgpID0+IHtcclxuICAgICAgY29uc3QgY2FzdEVsZW1lbnQgPSB0aGlzLmlubmVyVHlwZS5jYXN0KHYsIE9iamVjdC5hc3NpZ24oe30sIF9vcHRzLCB7XHJcbiAgICAgICAgcGF0aDogYCR7X29wdHMucGF0aCB8fCAnJ31bJHtpZHh9XWBcclxuICAgICAgfSkpO1xyXG4gICAgICBpZiAoY2FzdEVsZW1lbnQgIT09IHYpIHtcclxuICAgICAgICBpc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjYXN0RWxlbWVudDtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGlzQ2hhbmdlZCA/IGNhc3RBcnJheSA6IHZhbHVlO1xyXG4gIH1cclxuICBfdmFsaWRhdGUoX3ZhbHVlLCBvcHRpb25zID0ge30sIHBhbmljLCBuZXh0KSB7XHJcbiAgICB2YXIgX29wdGlvbnMkcmVjdXJzaXZlO1xyXG4gICAgLy8gbGV0IHN5bmMgPSBvcHRpb25zLnN5bmM7XHJcbiAgICAvLyBsZXQgcGF0aCA9IG9wdGlvbnMucGF0aDtcclxuICAgIGxldCBpbm5lclR5cGUgPSB0aGlzLmlubmVyVHlwZTtcclxuICAgIC8vIGxldCBlbmRFYXJseSA9IG9wdGlvbnMuYWJvcnRFYXJseSA/PyB0aGlzLnNwZWMuYWJvcnRFYXJseTtcclxuICAgIGxldCByZWN1cnNpdmUgPSAoX29wdGlvbnMkcmVjdXJzaXZlID0gb3B0aW9ucy5yZWN1cnNpdmUpICE9IG51bGwgPyBfb3B0aW9ucyRyZWN1cnNpdmUgOiB0aGlzLnNwZWMucmVjdXJzaXZlO1xyXG4gICAgb3B0aW9ucy5vcmlnaW5hbFZhbHVlICE9IG51bGwgPyBvcHRpb25zLm9yaWdpbmFsVmFsdWUgOiBfdmFsdWU7XHJcbiAgICBzdXBlci5fdmFsaWRhdGUoX3ZhbHVlLCBvcHRpb25zLCBwYW5pYywgKGFycmF5RXJyb3JzLCB2YWx1ZSkgPT4ge1xyXG4gICAgICB2YXIgX29wdGlvbnMkb3JpZ2luYWxWYWx1MjtcclxuICAgICAgaWYgKCFyZWN1cnNpdmUgfHwgIWlubmVyVHlwZSB8fCAhdGhpcy5fdHlwZUNoZWNrKHZhbHVlKSkge1xyXG4gICAgICAgIG5leHQoYXJyYXlFcnJvcnMsIHZhbHVlKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vICM5NTAgRW5zdXJlIHRoYXQgc3BhcnNlIGFycmF5IGVtcHR5IHNsb3RzIGFyZSB2YWxpZGF0ZWRcclxuICAgICAgbGV0IHRlc3RzID0gbmV3IEFycmF5KHZhbHVlLmxlbmd0aCk7XHJcbiAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB2YWx1ZS5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICB2YXIgX29wdGlvbnMkb3JpZ2luYWxWYWx1O1xyXG4gICAgICAgIHRlc3RzW2luZGV4XSA9IGlubmVyVHlwZS5hc05lc3RlZFRlc3Qoe1xyXG4gICAgICAgICAgb3B0aW9ucyxcclxuICAgICAgICAgIGluZGV4LFxyXG4gICAgICAgICAgcGFyZW50OiB2YWx1ZSxcclxuICAgICAgICAgIHBhcmVudFBhdGg6IG9wdGlvbnMucGF0aCxcclxuICAgICAgICAgIG9yaWdpbmFsUGFyZW50OiAoX29wdGlvbnMkb3JpZ2luYWxWYWx1ID0gb3B0aW9ucy5vcmlnaW5hbFZhbHVlKSAhPSBudWxsID8gX29wdGlvbnMkb3JpZ2luYWxWYWx1IDogX3ZhbHVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5ydW5UZXN0cyh7XHJcbiAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgdGVzdHMsXHJcbiAgICAgICAgb3JpZ2luYWxWYWx1ZTogKF9vcHRpb25zJG9yaWdpbmFsVmFsdTIgPSBvcHRpb25zLm9yaWdpbmFsVmFsdWUpICE9IG51bGwgPyBfb3B0aW9ucyRvcmlnaW5hbFZhbHUyIDogX3ZhbHVlLFxyXG4gICAgICAgIG9wdGlvbnNcclxuICAgICAgfSwgcGFuaWMsIGlubmVyVHlwZUVycm9ycyA9PiBuZXh0KGlubmVyVHlwZUVycm9ycy5jb25jYXQoYXJyYXlFcnJvcnMpLCB2YWx1ZSkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGNsb25lKHNwZWMpIHtcclxuICAgIGNvbnN0IG5leHQgPSBzdXBlci5jbG9uZShzcGVjKTtcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgcmVhZG9ubHlcclxuICAgIG5leHQuaW5uZXJUeXBlID0gdGhpcy5pbm5lclR5cGU7XHJcbiAgICByZXR1cm4gbmV4dDtcclxuICB9XHJcblxyXG4gIC8qKiBQYXJzZSBhbiBpbnB1dCBKU09OIHN0cmluZyB0byBhbiBvYmplY3QgKi9cclxuICBqc29uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHBhcnNlSnNvbik7XHJcbiAgfVxyXG4gIGNvbmNhdChzY2hlbWEpIHtcclxuICAgIGxldCBuZXh0ID0gc3VwZXIuY29uY2F0KHNjaGVtYSk7XHJcblxyXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciByZWFkb25seVxyXG4gICAgbmV4dC5pbm5lclR5cGUgPSB0aGlzLmlubmVyVHlwZTtcclxuICAgIGlmIChzY2hlbWEuaW5uZXJUeXBlKVxyXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHJlYWRvbmx5XHJcbiAgICAgIG5leHQuaW5uZXJUeXBlID0gbmV4dC5pbm5lclR5cGUgP1xyXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIExhenkgZG9lc24ndCBoYXZlIGNvbmNhdCBhbmQgd2lsbCBicmVha1xyXG4gICAgICBuZXh0LmlubmVyVHlwZS5jb25jYXQoc2NoZW1hLmlubmVyVHlwZSkgOiBzY2hlbWEuaW5uZXJUeXBlO1xyXG4gICAgcmV0dXJuIG5leHQ7XHJcbiAgfVxyXG4gIG9mKHNjaGVtYSkge1xyXG4gICAgLy8gRklYTUU6IHRoaXMgc2hvdWxkIHJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBhcnJheSB3aXRob3V0IHRoZSBkZWZhdWx0IHRvIGJlXHJcbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcclxuICAgIGlmICghaXNTY2hlbWEoc2NoZW1hKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYGFycmF5Lm9mKClgIHN1Yi1zY2hlbWEgbXVzdCBiZSBhIHZhbGlkIHl1cCBzY2hlbWEgbm90OiAnICsgcHJpbnRWYWx1ZShzY2hlbWEpKTtcclxuXHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHJlYWRvbmx5XHJcbiAgICBuZXh0LmlubmVyVHlwZSA9IHNjaGVtYTtcclxuICAgIG5leHQuc3BlYyA9IE9iamVjdC5hc3NpZ24oe30sIG5leHQuc3BlYywge1xyXG4gICAgICB0eXBlczogc2NoZW1hXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBuZXh0O1xyXG4gIH1cclxuICBsZW5ndGgobGVuZ3RoLCBtZXNzYWdlID0gYXJyYXkubGVuZ3RoKSB7XHJcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcclxuICAgICAgbWVzc2FnZSxcclxuICAgICAgbmFtZTogJ2xlbmd0aCcsXHJcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcclxuICAgICAgcGFyYW1zOiB7XHJcbiAgICAgICAgbGVuZ3RoXHJcbiAgICAgIH0sXHJcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXHJcbiAgICAgIHRlc3QodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID09PSB0aGlzLnJlc29sdmUobGVuZ3RoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIG1pbihtaW4sIG1lc3NhZ2UpIHtcclxuICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8IGFycmF5Lm1pbjtcclxuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xyXG4gICAgICBtZXNzYWdlLFxyXG4gICAgICBuYW1lOiAnbWluJyxcclxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxyXG4gICAgICBwYXJhbXM6IHtcclxuICAgICAgICBtaW5cclxuICAgICAgfSxcclxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcclxuICAgICAgLy8gRklYTUUodHMpOiBBcnJheTx0eXBlb2YgVD5cclxuICAgICAgdGVzdCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPj0gdGhpcy5yZXNvbHZlKG1pbik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICBtYXgobWF4LCBtZXNzYWdlKSB7XHJcbiAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCBhcnJheS5tYXg7XHJcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcclxuICAgICAgbWVzc2FnZSxcclxuICAgICAgbmFtZTogJ21heCcsXHJcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcclxuICAgICAgcGFyYW1zOiB7XHJcbiAgICAgICAgbWF4XHJcbiAgICAgIH0sXHJcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXHJcbiAgICAgIHRlc3QodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoIDw9IHRoaXMucmVzb2x2ZShtYXgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgZW5zdXJlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdCgoKSA9PiBbXSkudHJhbnNmb3JtKCh2YWwsIG9yaWdpbmFsKSA9PiB7XHJcbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gcmV0dXJuIGBudWxsYCBmb3IgbnVsbGFibGUgc2NoZW1hXHJcbiAgICAgIGlmICh0aGlzLl90eXBlQ2hlY2sodmFsKSkgcmV0dXJuIHZhbDtcclxuICAgICAgcmV0dXJuIG9yaWdpbmFsID09IG51bGwgPyBbXSA6IFtdLmNvbmNhdChvcmlnaW5hbCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgY29tcGFjdChyZWplY3Rvcikge1xyXG4gICAgbGV0IHJlamVjdCA9ICFyZWplY3RvciA/IHYgPT4gISF2IDogKHYsIGksIGEpID0+ICFyZWplY3Rvcih2LCBpLCBhKTtcclxuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh2YWx1ZXMgPT4gdmFsdWVzICE9IG51bGwgPyB2YWx1ZXMuZmlsdGVyKHJlamVjdCkgOiB2YWx1ZXMpO1xyXG4gIH1cclxuICBkZXNjcmliZShvcHRpb25zKSB7XHJcbiAgICBjb25zdCBuZXh0ID0gKG9wdGlvbnMgPyB0aGlzLnJlc29sdmUob3B0aW9ucykgOiB0aGlzKS5jbG9uZSgpO1xyXG4gICAgY29uc3QgYmFzZSA9IHN1cGVyLmRlc2NyaWJlKG9wdGlvbnMpO1xyXG4gICAgaWYgKG5leHQuaW5uZXJUeXBlKSB7XHJcbiAgICAgIHZhciBfaW5uZXJPcHRpb25zO1xyXG4gICAgICBsZXQgaW5uZXJPcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgaWYgKChfaW5uZXJPcHRpb25zID0gaW5uZXJPcHRpb25zKSAhPSBudWxsICYmIF9pbm5lck9wdGlvbnMudmFsdWUpIHtcclxuICAgICAgICBpbm5lck9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBpbm5lck9wdGlvbnMsIHtcclxuICAgICAgICAgIHBhcmVudDogaW5uZXJPcHRpb25zLnZhbHVlLFxyXG4gICAgICAgICAgdmFsdWU6IGlubmVyT3B0aW9ucy52YWx1ZVswXVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGJhc2UuaW5uZXJUeXBlID0gbmV4dC5pbm5lclR5cGUuZGVzY3JpYmUoaW5uZXJPcHRpb25zKTtcclxuICAgIH1cclxuICAgIHJldHVybiBiYXNlO1xyXG4gIH1cclxufVxyXG5jcmVhdGUkMi5wcm90b3R5cGUgPSBBcnJheVNjaGVtYS5wcm90b3R5cGU7XHJcblxyXG4vLyBAdHMtaWdub3JlXHJcbmZ1bmN0aW9uIGNyZWF0ZSQxKHNjaGVtYXMpIHtcclxuICByZXR1cm4gbmV3IFR1cGxlU2NoZW1hKHNjaGVtYXMpO1xyXG59XHJcbmNsYXNzIFR1cGxlU2NoZW1hIGV4dGVuZHMgU2NoZW1hIHtcclxuICBjb25zdHJ1Y3RvcihzY2hlbWFzKSB7XHJcbiAgICBzdXBlcih7XHJcbiAgICAgIHR5cGU6ICd0dXBsZScsXHJcbiAgICAgIHNwZWM6IHtcclxuICAgICAgICB0eXBlczogc2NoZW1hc1xyXG4gICAgICB9LFxyXG4gICAgICBjaGVjayh2KSB7XHJcbiAgICAgICAgY29uc3QgdHlwZXMgPSB0aGlzLnNwZWMudHlwZXM7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodikgJiYgdi5sZW5ndGggPT09IHR5cGVzLmxlbmd0aDtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLndpdGhNdXRhdGlvbigoKSA9PiB7XHJcbiAgICAgIHRoaXMudHlwZUVycm9yKHR1cGxlLm5vdFR5cGUpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIF9jYXN0KGlucHV0VmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgdHlwZXNcclxuICAgIH0gPSB0aGlzLnNwZWM7XHJcbiAgICBjb25zdCB2YWx1ZSA9IHN1cGVyLl9jYXN0KGlucHV0VmFsdWUsIG9wdGlvbnMpO1xyXG4gICAgaWYgKCF0aGlzLl90eXBlQ2hlY2sodmFsdWUpKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIGxldCBpc0NoYW5nZWQgPSBmYWxzZTtcclxuICAgIGNvbnN0IGNhc3RBcnJheSA9IHR5cGVzLm1hcCgodHlwZSwgaWR4KSA9PiB7XHJcbiAgICAgIGNvbnN0IGNhc3RFbGVtZW50ID0gdHlwZS5jYXN0KHZhbHVlW2lkeF0sIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcclxuICAgICAgICBwYXRoOiBgJHtvcHRpb25zLnBhdGggfHwgJyd9WyR7aWR4fV1gXHJcbiAgICAgIH0pKTtcclxuICAgICAgaWYgKGNhc3RFbGVtZW50ICE9PSB2YWx1ZVtpZHhdKSBpc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICByZXR1cm4gY2FzdEVsZW1lbnQ7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBpc0NoYW5nZWQgPyBjYXN0QXJyYXkgOiB2YWx1ZTtcclxuICB9XHJcbiAgX3ZhbGlkYXRlKF92YWx1ZSwgb3B0aW9ucyA9IHt9LCBwYW5pYywgbmV4dCkge1xyXG4gICAgbGV0IGl0ZW1UeXBlcyA9IHRoaXMuc3BlYy50eXBlcztcclxuICAgIHN1cGVyLl92YWxpZGF0ZShfdmFsdWUsIG9wdGlvbnMsIHBhbmljLCAodHVwbGVFcnJvcnMsIHZhbHVlKSA9PiB7XHJcbiAgICAgIHZhciBfb3B0aW9ucyRvcmlnaW5hbFZhbHUyO1xyXG4gICAgICAvLyBpbnRlbnRpb25hbGx5IG5vdCByZXNwZWN0aW5nIHJlY3Vyc2l2ZVxyXG4gICAgICBpZiAoIXRoaXMuX3R5cGVDaGVjayh2YWx1ZSkpIHtcclxuICAgICAgICBuZXh0KHR1cGxlRXJyb3JzLCB2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCB0ZXN0cyA9IFtdO1xyXG4gICAgICBmb3IgKGxldCBbaW5kZXgsIGl0ZW1TY2hlbWFdIG9mIGl0ZW1UeXBlcy5lbnRyaWVzKCkpIHtcclxuICAgICAgICB2YXIgX29wdGlvbnMkb3JpZ2luYWxWYWx1O1xyXG4gICAgICAgIHRlc3RzW2luZGV4XSA9IGl0ZW1TY2hlbWEuYXNOZXN0ZWRUZXN0KHtcclxuICAgICAgICAgIG9wdGlvbnMsXHJcbiAgICAgICAgICBpbmRleCxcclxuICAgICAgICAgIHBhcmVudDogdmFsdWUsXHJcbiAgICAgICAgICBwYXJlbnRQYXRoOiBvcHRpb25zLnBhdGgsXHJcbiAgICAgICAgICBvcmlnaW5hbFBhcmVudDogKF9vcHRpb25zJG9yaWdpbmFsVmFsdSA9IG9wdGlvbnMub3JpZ2luYWxWYWx1ZSkgIT0gbnVsbCA/IF9vcHRpb25zJG9yaWdpbmFsVmFsdSA6IF92YWx1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMucnVuVGVzdHMoe1xyXG4gICAgICAgIHZhbHVlLFxyXG4gICAgICAgIHRlc3RzLFxyXG4gICAgICAgIG9yaWdpbmFsVmFsdWU6IChfb3B0aW9ucyRvcmlnaW5hbFZhbHUyID0gb3B0aW9ucy5vcmlnaW5hbFZhbHVlKSAhPSBudWxsID8gX29wdGlvbnMkb3JpZ2luYWxWYWx1MiA6IF92YWx1ZSxcclxuICAgICAgICBvcHRpb25zXHJcbiAgICAgIH0sIHBhbmljLCBpbm5lclR5cGVFcnJvcnMgPT4gbmV4dChpbm5lclR5cGVFcnJvcnMuY29uY2F0KHR1cGxlRXJyb3JzKSwgdmFsdWUpKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBkZXNjcmliZShvcHRpb25zKSB7XHJcbiAgICBjb25zdCBuZXh0ID0gKG9wdGlvbnMgPyB0aGlzLnJlc29sdmUob3B0aW9ucykgOiB0aGlzKS5jbG9uZSgpO1xyXG4gICAgY29uc3QgYmFzZSA9IHN1cGVyLmRlc2NyaWJlKG9wdGlvbnMpO1xyXG4gICAgYmFzZS5pbm5lclR5cGUgPSBuZXh0LnNwZWMudHlwZXMubWFwKChzY2hlbWEsIGluZGV4KSA9PiB7XHJcbiAgICAgIHZhciBfaW5uZXJPcHRpb25zO1xyXG4gICAgICBsZXQgaW5uZXJPcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgaWYgKChfaW5uZXJPcHRpb25zID0gaW5uZXJPcHRpb25zKSAhPSBudWxsICYmIF9pbm5lck9wdGlvbnMudmFsdWUpIHtcclxuICAgICAgICBpbm5lck9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBpbm5lck9wdGlvbnMsIHtcclxuICAgICAgICAgIHBhcmVudDogaW5uZXJPcHRpb25zLnZhbHVlLFxyXG4gICAgICAgICAgdmFsdWU6IGlubmVyT3B0aW9ucy52YWx1ZVtpbmRleF1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc2NoZW1hLmRlc2NyaWJlKGlubmVyT3B0aW9ucyk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBiYXNlO1xyXG4gIH1cclxufVxyXG5jcmVhdGUkMS5wcm90b3R5cGUgPSBUdXBsZVNjaGVtYS5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBjcmVhdGUoYnVpbGRlcikge1xyXG4gIHJldHVybiBuZXcgTGF6eShidWlsZGVyKTtcclxufVxyXG5mdW5jdGlvbiBjYXRjaFZhbGlkYXRpb25FcnJvcihmbikge1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gZm4oKTtcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIGlmIChWYWxpZGF0aW9uRXJyb3IuaXNFcnJvcihlcnIpKSByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcclxuICAgIHRocm93IGVycjtcclxuICB9XHJcbn1cclxuY2xhc3MgTGF6eSB7XHJcbiAgY29uc3RydWN0b3IoYnVpbGRlcikge1xyXG4gICAgdGhpcy50eXBlID0gJ2xhenknO1xyXG4gICAgdGhpcy5fX2lzWXVwU2NoZW1hX18gPSB0cnVlO1xyXG4gICAgdGhpcy5zcGVjID0gdm9pZCAwO1xyXG4gICAgdGhpcy5fcmVzb2x2ZSA9ICh2YWx1ZSwgb3B0aW9ucyA9IHt9KSA9PiB7XHJcbiAgICAgIGxldCBzY2hlbWEgPSB0aGlzLmJ1aWxkZXIodmFsdWUsIG9wdGlvbnMpO1xyXG4gICAgICBpZiAoIWlzU2NoZW1hKHNjaGVtYSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xhenkoKSBmdW5jdGlvbnMgbXVzdCByZXR1cm4gYSB2YWxpZCBzY2hlbWEnKTtcclxuICAgICAgaWYgKHRoaXMuc3BlYy5vcHRpb25hbCkgc2NoZW1hID0gc2NoZW1hLm9wdGlvbmFsKCk7XHJcbiAgICAgIHJldHVybiBzY2hlbWEucmVzb2x2ZShvcHRpb25zKTtcclxuICAgIH07XHJcbiAgICB0aGlzLmJ1aWxkZXIgPSBidWlsZGVyO1xyXG4gICAgdGhpcy5zcGVjID0ge1xyXG4gICAgICBtZXRhOiB1bmRlZmluZWQsXHJcbiAgICAgIG9wdGlvbmFsOiBmYWxzZVxyXG4gICAgfTtcclxuICB9XHJcbiAgY2xvbmUoc3BlYykge1xyXG4gICAgY29uc3QgbmV4dCA9IG5ldyBMYXp5KHRoaXMuYnVpbGRlcik7XHJcbiAgICBuZXh0LnNwZWMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnNwZWMsIHNwZWMpO1xyXG4gICAgcmV0dXJuIG5leHQ7XHJcbiAgfVxyXG4gIG9wdGlvbmFsaXR5KG9wdGlvbmFsKSB7XHJcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5jbG9uZSh7XHJcbiAgICAgIG9wdGlvbmFsXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBuZXh0O1xyXG4gIH1cclxuICBvcHRpb25hbCgpIHtcclxuICAgIHJldHVybiB0aGlzLm9wdGlvbmFsaXR5KHRydWUpO1xyXG4gIH1cclxuICByZXNvbHZlKG9wdGlvbnMpIHtcclxuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKG9wdGlvbnMudmFsdWUsIG9wdGlvbnMpO1xyXG4gIH1cclxuICBjYXN0KHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZSh2YWx1ZSwgb3B0aW9ucykuY2FzdCh2YWx1ZSwgb3B0aW9ucyk7XHJcbiAgfVxyXG4gIGFzTmVzdGVkVGVzdChjb25maWcpIHtcclxuICAgIGxldCB7XHJcbiAgICAgIGtleSxcclxuICAgICAgaW5kZXgsXHJcbiAgICAgIHBhcmVudCxcclxuICAgICAgb3B0aW9uc1xyXG4gICAgfSA9IGNvbmZpZztcclxuICAgIGxldCB2YWx1ZSA9IHBhcmVudFtpbmRleCAhPSBudWxsID8gaW5kZXggOiBrZXldO1xyXG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUodmFsdWUsIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcclxuICAgICAgdmFsdWUsXHJcbiAgICAgIHBhcmVudFxyXG4gICAgfSkpLmFzTmVzdGVkVGVzdChjb25maWcpO1xyXG4gIH1cclxuICB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGNhdGNoVmFsaWRhdGlvbkVycm9yKCgpID0+IHRoaXMuX3Jlc29sdmUodmFsdWUsIG9wdGlvbnMpLnZhbGlkYXRlKHZhbHVlLCBvcHRpb25zKSk7XHJcbiAgfVxyXG4gIHZhbGlkYXRlU3luYyh2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUodmFsdWUsIG9wdGlvbnMpLnZhbGlkYXRlU3luYyh2YWx1ZSwgb3B0aW9ucyk7XHJcbiAgfVxyXG4gIHZhbGlkYXRlQXQocGF0aCwgdmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBjYXRjaFZhbGlkYXRpb25FcnJvcigoKSA9PiB0aGlzLl9yZXNvbHZlKHZhbHVlLCBvcHRpb25zKS52YWxpZGF0ZUF0KHBhdGgsIHZhbHVlLCBvcHRpb25zKSk7XHJcbiAgfVxyXG4gIHZhbGlkYXRlU3luY0F0KHBhdGgsIHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZSh2YWx1ZSwgb3B0aW9ucykudmFsaWRhdGVTeW5jQXQocGF0aCwgdmFsdWUsIG9wdGlvbnMpO1xyXG4gIH1cclxuICBpc1ZhbGlkKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZSh2YWx1ZSwgb3B0aW9ucykuaXNWYWxpZCh2YWx1ZSwgb3B0aW9ucyk7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgaWYgKFZhbGlkYXRpb25FcnJvci5pc0Vycm9yKGVycikpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcclxuICAgICAgfVxyXG4gICAgICB0aHJvdyBlcnI7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlzVmFsaWRTeW5jKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZSh2YWx1ZSwgb3B0aW9ucykuaXNWYWxpZFN5bmModmFsdWUsIG9wdGlvbnMpO1xyXG4gIH1cclxuICBkZXNjcmliZShvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gb3B0aW9ucyA/IHRoaXMucmVzb2x2ZShvcHRpb25zKS5kZXNjcmliZShvcHRpb25zKSA6IHtcclxuICAgICAgdHlwZTogJ2xhenknLFxyXG4gICAgICBtZXRhOiB0aGlzLnNwZWMubWV0YSxcclxuICAgICAgbGFiZWw6IHVuZGVmaW5lZFxyXG4gICAgfTtcclxuICB9XHJcbiAgbWV0YSguLi5hcmdzKSB7XHJcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLnNwZWMubWV0YTtcclxuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xyXG4gICAgbmV4dC5zcGVjLm1ldGEgPSBPYmplY3QuYXNzaWduKG5leHQuc3BlYy5tZXRhIHx8IHt9LCBhcmdzWzBdKTtcclxuICAgIHJldHVybiBuZXh0O1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc2V0TG9jYWxlKGN1c3RvbSkge1xyXG4gIE9iamVjdC5rZXlzKGN1c3RvbSkuZm9yRWFjaCh0eXBlID0+IHtcclxuICAgIC8vIEB0cy1pZ25vcmVcclxuICAgIE9iamVjdC5rZXlzKGN1c3RvbVt0eXBlXSkuZm9yRWFjaChtZXRob2QgPT4ge1xyXG4gICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgIGxvY2FsZVt0eXBlXVttZXRob2RdID0gY3VzdG9tW3R5cGVdW21ldGhvZF07XHJcbiAgICB9KTtcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkTWV0aG9kKHNjaGVtYVR5cGUsIG5hbWUsIGZuKSB7XHJcbiAgaWYgKCFzY2hlbWFUeXBlIHx8ICFpc1NjaGVtYShzY2hlbWFUeXBlLnByb3RvdHlwZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgYSB5dXAgc2NoZW1hIGNvbnN0cnVjdG9yIGZ1bmN0aW9uJyk7XHJcbiAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBNZXRob2QgbmFtZSBtdXN0IGJlIHByb3ZpZGVkJyk7XHJcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcignTWV0aG9kIGZ1bmN0aW9uIG11c3QgYmUgcHJvdmlkZWQnKTtcclxuICBzY2hlbWFUeXBlLnByb3RvdHlwZVtuYW1lXSA9IGZuO1xyXG59XHJcblxyXG5leHBvcnQgeyBBcnJheVNjaGVtYSwgQm9vbGVhblNjaGVtYSwgRGF0ZVNjaGVtYSwgTGF6eSBhcyBMYXp5U2NoZW1hLCBNaXhlZFNjaGVtYSwgTnVtYmVyU2NoZW1hLCBPYmplY3RTY2hlbWEsIFNjaGVtYSwgU3RyaW5nU2NoZW1hLCBUdXBsZVNjaGVtYSwgVmFsaWRhdGlvbkVycm9yLCBhZGRNZXRob2QsIGNyZWF0ZSQyIGFzIGFycmF5LCBjcmVhdGUkNyBhcyBib29sLCBjcmVhdGUkNyBhcyBib29sZWFuLCBjcmVhdGUkNCBhcyBkYXRlLCBsb2NhbGUgYXMgZGVmYXVsdExvY2FsZSwgZ2V0SW4sIGlzU2NoZW1hLCBjcmVhdGUgYXMgbGF6eSwgY3JlYXRlJDggYXMgbWl4ZWQsIGNyZWF0ZSQ1IGFzIG51bWJlciwgY3JlYXRlJDMgYXMgb2JqZWN0LCBwcmludFZhbHVlLCByZWFjaCwgY3JlYXRlJDkgYXMgcmVmLCBzZXRMb2NhbGUsIGNyZWF0ZSQ2IGFzIHN0cmluZywgY3JlYXRlJDEgYXMgdHVwbGUgfTtcclxuIl0sIm5hbWVzIjpbImdldHRlciIsImZvckVhY2giLCJzcGxpdCIsIm5vcm1hbGl6ZVBhdGgiLCJqb2luIiwiY2FtZWxDYXNlIiwic25ha2VDYXNlIiwidG9wb3NvcnQiLCJ0b1N0cmluZyIsIk9iamVjdCIsInByb3RvdHlwZSIsImVycm9yVG9TdHJpbmciLCJFcnJvciIsInJlZ0V4cFRvU3RyaW5nIiwiUmVnRXhwIiwic3ltYm9sVG9TdHJpbmciLCJTeW1ib2wiLCJTWU1CT0xfUkVHRVhQIiwicHJpbnROdW1iZXIiLCJ2YWwiLCJpc05lZ2F0aXZlWmVybyIsInByaW50U2ltcGxlVmFsdWUiLCJxdW90ZVN0cmluZ3MiLCJ0eXBlT2YiLCJuYW1lIiwiY2FsbCIsInJlcGxhY2UiLCJ0YWciLCJzbGljZSIsImlzTmFOIiwiZ2V0VGltZSIsInRvSVNPU3RyaW5nIiwicHJpbnRWYWx1ZSIsInZhbHVlIiwicmVzdWx0IiwiSlNPTiIsInN0cmluZ2lmeSIsImtleSIsInRvQXJyYXkiLCJjb25jYXQiLCJfU3ltYm9sJHRvU3RyaW5nVGFnIiwiX1N5bWJvbCRoYXNJbnN0YW5jZSIsIl9TeW1ib2wkdG9TdHJpbmdUYWcyIiwic3RyUmVnIiwidG9TdHJpbmdUYWciLCJWYWxpZGF0aW9uRXJyb3JOb1N0YWNrIiwiY29uc3RydWN0b3IiLCJlcnJvck9yRXJyb3JzIiwiZmllbGQiLCJ0eXBlIiwibWVzc2FnZSIsInBhdGgiLCJwYXJhbXMiLCJlcnJvcnMiLCJpbm5lciIsImVyciIsIlZhbGlkYXRpb25FcnJvciIsImlzRXJyb3IiLCJwdXNoIiwiaW5uZXJFcnJvcnMiLCJsZW5ndGgiLCJoYXNJbnN0YW5jZSIsImZvcm1hdEVycm9yIiwibGFiZWwiLCJhc3NpZ24iLCJvcmlnaW5hbFBhdGgiLCJfIiwiZGlzYWJsZVN0YWNrIiwiZXJyb3JOb1N0YWNrIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJpbnN0IiwibWl4ZWQiLCJkZWZhdWx0IiwicmVxdWlyZWQiLCJkZWZpbmVkIiwibm90TnVsbCIsIm9uZU9mIiwibm90T25lT2YiLCJub3RUeXBlIiwib3JpZ2luYWxWYWx1ZSIsImNhc3RNc2ciLCJzdHJpbmciLCJtaW4iLCJtYXgiLCJtYXRjaGVzIiwiZW1haWwiLCJ1cmwiLCJ1dWlkIiwiZGF0ZXRpbWUiLCJkYXRldGltZV9wcmVjaXNpb24iLCJkYXRldGltZV9vZmZzZXQiLCJ0cmltIiwibG93ZXJjYXNlIiwidXBwZXJjYXNlIiwibnVtYmVyIiwibGVzc1RoYW4iLCJtb3JlVGhhbiIsInBvc2l0aXZlIiwibmVnYXRpdmUiLCJpbnRlZ2VyIiwiZGF0ZSIsImJvb2xlYW4iLCJpc1ZhbHVlIiwib2JqZWN0Iiwibm9Vbmtub3duIiwiZXhhY3QiLCJhcnJheSIsInR1cGxlIiwic3BlYyIsInR5cGVMZW4iLCJ0eXBlcyIsIkFycmF5IiwiaXNBcnJheSIsImxvY2FsZSIsImNyZWF0ZSIsImlzU2NoZW1hIiwib2JqIiwiX19pc1l1cFNjaGVtYV9fIiwiQ29uZGl0aW9uIiwiZnJvbU9wdGlvbnMiLCJyZWZzIiwiY29uZmlnIiwidGhlbiIsIm90aGVyd2lzZSIsIlR5cGVFcnJvciIsImlzIiwiY2hlY2siLCJ2YWx1ZXMiLCJldmVyeSIsInNjaGVtYSIsIl9icmFuY2giLCJicmFuY2giLCJidWlsZGVyIiwiZm4iLCJyZXNvbHZlIiwiYmFzZSIsIm9wdGlvbnMiLCJtYXAiLCJyZWYiLCJnZXRWYWx1ZSIsInBhcmVudCIsImNvbnRleHQiLCJ1bmRlZmluZWQiLCJwcmVmaXhlcyIsImNyZWF0ZSQ5IiwiUmVmZXJlbmNlIiwiaXNDb250ZXh0IiwiaXNTaWJsaW5nIiwicHJlZml4IiwiY2FzdCIsImRlc2NyaWJlIiwiaXNSZWYiLCJfX2lzWXVwUmVmIiwiaXNBYnNlbnQiLCJjcmVhdGVWYWxpZGF0aW9uIiwidmFsaWRhdGUiLCJwYW5pYyIsIm5leHQiLCJ0ZXN0Iiwic2tpcEFic2VudCIsImFib3J0RWFybHkiLCJkaXNhYmxlU3RhY2tUcmFjZSIsIml0ZW0iLCJjcmVhdGVFcnJvciIsIm92ZXJyaWRlcyIsIm5leHRQYXJhbXMiLCJrZXlzIiwiZXJyb3IiLCJpbnZhbGlkIiwiY3R4IiwiZnJvbSIsImhhbmRsZVJlc3VsdCIsInZhbGlkT3JFcnJvciIsImhhbmRsZUVycm9yIiwic2hvdWxkU2tpcCIsIl9yZXN1bHQiLCJzeW5jIiwiUHJvbWlzZSIsIk9QVElPTlMiLCJnZXRJbiIsImxhc3RQYXJ0IiwibGFzdFBhcnREZWJ1ZyIsInBhcmVudFBhdGgiLCJfcGFydCIsImlzQnJhY2tldCIsInBhcnQiLCJpc1R1cGxlIiwiaWR4IiwicGFyc2VJbnQiLCJpbm5lclR5cGUiLCJmaWVsZHMiLCJyZWFjaCIsIlJlZmVyZW5jZVNldCIsIlNldCIsImRlc2NyaXB0aW9uIiwicmVzb2x2ZUFsbCIsImNsb25lIiwibWVyZ2UiLCJuZXdJdGVtcyIsInJlbW92ZUl0ZW1zIiwiYWRkIiwiZGVsZXRlIiwic3JjIiwic2VlbiIsIk1hcCIsImhhcyIsImdldCIsImNvcHkiLCJEYXRlIiwic2V0IiwiaSIsImsiLCJ2IiwiZW50cmllcyIsIlNjaGVtYSIsImRlcHMiLCJ0ZXN0cyIsInRyYW5zZm9ybXMiLCJjb25kaXRpb25zIiwiX211dGF0ZSIsImludGVybmFsVGVzdHMiLCJfd2hpdGVsaXN0IiwiX2JsYWNrbGlzdCIsImV4Y2x1c2l2ZVRlc3RzIiwiX3R5cGVDaGVjayIsIndpdGhNdXRhdGlvbiIsInR5cGVFcnJvciIsInN0cmlwIiwic3RyaWN0IiwicmVjdXJzaXZlIiwibnVsbGFibGUiLCJvcHRpb25hbCIsImNvZXJjZSIsInMiLCJub25OdWxsYWJsZSIsIl90eXBlIiwiZ2V0UHJvdG90eXBlT2YiLCJtZXRhIiwiYXJncyIsImJlZm9yZSIsImNvbWJpbmVkIiwibWVyZ2VkU3BlYyIsImlzVHlwZSIsInJlZHVjZSIsInByZXZTY2hlbWEiLCJjb25kaXRpb24iLCJyZXNvbHZlT3B0aW9ucyIsIl9vcHRpb25zJHN0cmljdCIsIl9vcHRpb25zJGFib3J0RWFybHkiLCJfb3B0aW9ucyRyZWN1cnNpdmUiLCJfb3B0aW9ucyRkaXNhYmxlU3RhY2siLCJyZXNvbHZlZFNjaGVtYSIsImFsbG93T3B0aW9uYWxpdHkiLCJhc3NlcnQiLCJfY2FzdCIsImZvcm1hdHRlZFZhbHVlIiwiZm9ybWF0dGVkUmVzdWx0IiwicmF3VmFsdWUiLCJwcmV2VmFsdWUiLCJnZXREZWZhdWx0IiwiX3ZhbGlkYXRlIiwiX3ZhbHVlIiwiaW5pdGlhbFRlc3RzIiwicnVuVGVzdHMiLCJpbml0aWFsRXJyb3JzIiwicnVuT3B0aW9ucyIsImZpcmVkIiwicGFuaWNPbmNlIiwiYXJnIiwibmV4dE9uY2UiLCJjb3VudCIsIm5lc3RlZEVycm9ycyIsImZpbmlzaFRlc3RSdW4iLCJhc05lc3RlZFRlc3QiLCJpbmRleCIsIm9yaWdpbmFsUGFyZW50IiwiaXNJbmRleCIsInRlc3RPcHRpb25zIiwiaW5jbHVkZXMiLCJfb3B0aW9ucyRkaXNhYmxlU3RhY2syIiwicmVqZWN0IiwicGFyc2VkIiwidmFsaWRhdGVkIiwidmFsaWRhdGVTeW5jIiwiX29wdGlvbnMkZGlzYWJsZVN0YWNrMyIsImlzVmFsaWQiLCJpc1ZhbGlkU3luYyIsIl9nZXREZWZhdWx0IiwiZGVmYXVsdFZhbHVlIiwiZGVmIiwiYXJndW1lbnRzIiwiaXNTdHJpY3QiLCJudWxsYWJpbGl0eSIsIm9wdGlvbmFsaXR5Iiwibm90UmVxdWlyZWQiLCJ0cmFuc2Zvcm0iLCJvcHRzIiwiaXNFeGNsdXNpdmUiLCJleGNsdXNpdmUiLCJmaWx0ZXIiLCJ3aGVuIiwiZGVwIiwiZW51bXMiLCJ3aGl0ZUxpc3QiLCJ2YWxpZHMiLCJyZXNvbHZlZCIsImJsYWNrbGlzdCIsImludmFsaWRzIiwibiIsImxpc3QiLCJmaW5kSW5kZXgiLCJjIiwibWV0aG9kIiwiYWxpYXMiLCJyZXR1cm5zVHJ1ZSIsImNyZWF0ZSQ4IiwiTWl4ZWRTY2hlbWEiLCJjcmVhdGUkNyIsIkJvb2xlYW5TY2hlbWEiLCJCb29sZWFuIiwidmFsdWVPZiIsIl9yYXciLCJTdHJpbmciLCJpc1RydWUiLCJpc0ZhbHNlIiwibXNnIiwiaXNvUmVnIiwicGFyc2VJc29EYXRlIiwic3RydWN0IiwicGFyc2VEYXRlU3RydWN0IiwicGFyc2UiLCJOdW1iZXIiLCJOYU4iLCJ6IiwicGx1c01pbnVzIiwieWVhciIsIm1vbnRoIiwiZGF5IiwiaG91ciIsIm1pbnV0ZSIsInNlY29uZCIsIm1pbGxpc2Vjb25kIiwidG90YWxNaW51dGVzT2Zmc2V0IiwiaG91ck9mZnNldCIsIm1pbnV0ZU9mZnNldCIsIlVUQyIsIl9yZWdleFJlc3VsdCQ3JGxlbmd0aCIsIl9yZWdleFJlc3VsdCQiLCJyZWdleFJlc3VsdCIsImV4ZWMiLCJ0b051bWJlciIsInN1YnN0cmluZyIsInByZWNpc2lvbiIsInN0ciIsInJFbWFpbCIsInJVcmwiLCJyVVVJRCIsInllYXJNb250aERheSIsImhvdXJNaW51dGVTZWNvbmQiLCJ6T3JPZmZzZXQiLCJySXNvRGF0ZVRpbWUiLCJpc1RyaW1tZWQiLCJvYmpTdHJpbmdUYWciLCJjcmVhdGUkNiIsIlN0cmluZ1NjaGVtYSIsInN0clZhbHVlIiwidCIsInJlZ2V4IiwiZXhjbHVkZUVtcHR5U3RyaW5nIiwic2VhcmNoIiwiYWxsb3dPZmZzZXQiLCJlbnN1cmUiLCJ0b0xvd2VyQ2FzZSIsInRvVXBwZXJDYXNlIiwiaXNOYU4kMSIsImNyZWF0ZSQ1IiwiTnVtYmVyU2NoZW1hIiwicGFyc2VGbG9hdCIsImxlc3MiLCJtb3JlIiwiaXNJbnRlZ2VyIiwidHJ1bmNhdGUiLCJyb3VuZCIsIl9tZXRob2QiLCJhdmFpbCIsImluZGV4T2YiLCJNYXRoIiwiaW52YWxpZERhdGUiLCJpc0RhdGUiLCJjcmVhdGUkNCIsIkRhdGVTY2hlbWEiLCJJTlZBTElEX0RBVEUiLCJwcmVwYXJlUGFyYW0iLCJwYXJhbSIsImxpbWl0Iiwic29ydEZpZWxkcyIsImV4Y2x1ZGVkRWRnZXMiLCJlZGdlcyIsIm5vZGVzIiwiZXhjbHVkZXMiLCJhIiwiYiIsImFkZE5vZGUiLCJkZXBQYXRoIiwibm9kZSIsInJldmVyc2UiLCJhcnIiLCJJbmZpbml0eSIsInNvbWUiLCJpaSIsIl9lcnIkcGF0aCIsInNvcnRCeUtleU9yZGVyIiwicGFyc2VKc29uIiwiZGVlcFBhcnRpYWwiLCJwYXJ0aWFsIiwiZmllbGRTY2hlbWEiLCJzZXRGaWVsZHMiLCJuZXh0QXJyYXkiLCJkZWVwSGFzIiwicCIsImxhc3QiLCJwb3AiLCJpc09iamVjdCIsInVua25vd24iLCJrbm93biIsImRlZmF1bHRTb3J0IiwiY3JlYXRlJDMiLCJPYmplY3RTY2hlbWEiLCJfc29ydEVycm9ycyIsIl9ub2RlcyIsIl9leGNsdWRlZEVkZ2VzIiwic2hhcGUiLCJfb3B0aW9ucyRzdHJpcFVua25vd24iLCJzdHJpcFVua25vd24iLCJwcm9wcyIsImludGVybWVkaWF0ZVZhbHVlIiwiaW5uZXJPcHRpb25zIiwiX192YWxpZGF0aW5nIiwiaXNDaGFuZ2VkIiwicHJvcCIsImV4aXN0cyIsImZpZWxkVmFsdWUiLCJpbnB1dFZhbHVlIiwiZmllbGRTcGVjIiwib2JqZWN0RXJyb3JzIiwiZmllbGRFcnJvcnMiLCJzb3J0IiwibmV4dEZpZWxkcyIsInNjaGVtYU9yUmVmIiwidGFyZ2V0IiwiZGZ0IiwiX2lubmVyT3B0aW9ucyIsImFkZGl0aW9ucyIsIkZ1bmN0aW9uIiwicGljayIsInBpY2tlZCIsIm9taXQiLCJyZW1haW5pbmciLCJ0byIsImZyb21HZXR0ZXIiLCJuZXdPYmoiLCJqc29uIiwidW5rbm93bktleXMiLCJwcm9wZXJ0aWVzIiwibm9BbGxvdyIsImFsbG93IiwidHJhbnNmb3JtS2V5cyIsImNvbnN0YW50Q2FzZSIsIl9pbm5lck9wdGlvbnMyIiwiY3JlYXRlJDIiLCJBcnJheVNjaGVtYSIsIl9vcHRzIiwiY2FzdEFycmF5IiwiY2FzdEVsZW1lbnQiLCJhcnJheUVycm9ycyIsIl9vcHRpb25zJG9yaWdpbmFsVmFsdTIiLCJfb3B0aW9ucyRvcmlnaW5hbFZhbHUiLCJpbm5lclR5cGVFcnJvcnMiLCJvZiIsIm9yaWdpbmFsIiwiY29tcGFjdCIsInJlamVjdG9yIiwiY3JlYXRlJDEiLCJzY2hlbWFzIiwiVHVwbGVTY2hlbWEiLCJpdGVtVHlwZXMiLCJ0dXBsZUVycm9ycyIsIml0ZW1TY2hlbWEiLCJMYXp5IiwiY2F0Y2hWYWxpZGF0aW9uRXJyb3IiLCJfcmVzb2x2ZSIsInZhbGlkYXRlQXQiLCJ2YWxpZGF0ZVN5bmNBdCIsInNldExvY2FsZSIsImN1c3RvbSIsImFkZE1ldGhvZCIsInNjaGVtYVR5cGUiLCJMYXp5U2NoZW1hIiwiYm9vbCIsImRlZmF1bHRMb2NhbGUiLCJsYXp5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/yup/index.esm.js\n");

/***/ })

};
;